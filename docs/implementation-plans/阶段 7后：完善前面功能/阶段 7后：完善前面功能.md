我先对语言规范文档和前端实现（lexer/parser/AST 等）做一次全面扫描，然后根据“规范 vs 实现”的差异，把当前尚未实现或不完整的语法能力整理成一个分模块的 TODO 清单。接下来会结合实现计划文档里的阶段划分，把 TODO 细化到“词法/语法/语义/IR/测试”等具体子任务。
## 总体判断

**从代码和规范对比来看：**  
- 目前编译器已经支持：整数/字符串、函数、`主程序`、`如果/否则`、`当/循环`、`break/continue`、数组字面量与索引、指针 `&`/`*`、结构体与枚举等。  
- 但**很多“关键字已经在词法层存在、规范里写了、示例里在用”的语法，在语法分析/语义/后端上是缺失或不完整的**，这就是你感觉“基础语法支持未实现”的主要来源。

下面我按“特性 → 当前状态 → 需要做的 TODO”给你列一个**分模块、可实施的 TODO 列表**，优先关注核心子集（规范文档）和你 `examples` 里的用法。

---

## 已大致实现的核心能力（简略）

- **v0 最小子集（规范 0 章）**  
  - `整数` / `变量` 声明、整数算术表达式、简单函数定义/调用、`主程序` 入口、`打印` 调用：  
    - 词法在 [`lexer.c`](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/src/frontend/lexer/lexer.c) 已有，  
    - 语法在 [`parser.c`](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/src/frontend/parser/parser.c) 的 `parse_statement` / `parse_expression` / `parse_function_decl`，  
    - 语义和 IR/C 后端在 `src/semantics`、`src/ir`、`src/backend/cgen` 下基本打通。  
- **控制流与复合类型（部分超出 v0）**  
  - `如果/否则`、`当`（while）、`循环`（for）、`break/continue`、数组字面量和索引、结构体/枚举定义、指针类型与 `&`/`*` 运算、函数指针等，已经在 AST / 语义 / IR 中实现并有示例。

下面主要列**未实现/不完整的基础语法**。

---

## 未实现 / 不完整基础语法 TODO 列表

### 1. 布尔类型与布尔字面量（`布尔`、`真`、`假`）

**当前状态**

- 词法层：  
  - `"布尔"` 已被扫描为 `CN_TOKEN_KEYWORD_BOOL`（见 [`lexer.c`](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/src/frontend/lexer/lexer.c) 的 `keyword_kind`）。  
  - `"真"` / `"假"` 已被识别为 `CN_TOKEN_KEYWORD_TRUE` / `CN_TOKEN_KEYWORD_FALSE`。  
  - 类型系统中有 `CN_TYPE_BOOL`（见 [`semantics.h`](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/include/cnlang/frontend/semantics.h)）。  
- 语法层：  
  - **变量声明**只接受 `变量/整数/字符串`（`parse_statement` 里只检查 `CN_TOKEN_KEYWORD_VAR/INT/STRING`），**不接受 `布尔`**。  
  - `parse_factor` 只把整数/字符串/标识符/括号/数组字面量当作表达式，**不识别 `真` / `假`**，会走到“无法解析表达式”错误分支。  
- 语义/后端：  
  - 类型系统和 C 后端已经支持 `CN_TYPE_BOOL -> _Bool` 的映射（[`cgen.c`](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/src/backend/cgen/cgen.c) 中 `get_c_type_string`），但前端没法构造这种类型。

**TODO**

- **语法层 TODO**
  - **变量声明支持 `布尔` 类型**  
    - 在 [`parser.c`](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/src/frontend/parser/parser.c) 的 `parse_statement` 中，将  
      `if (current.kind == VAR/INT/STRING)` 扩展为包含 `CN_TOKEN_KEYWORD_BOOL`，并对 `布尔` 构造 `cn_type_new_primitive(CN_TYPE_BOOL)`。
    - 在 `parse_struct_decl` 中，字段类型目前只支持 `整数/字符串`，同样扩展为允许 `布尔`（以及后面的其它类型，见后续 TODO）。
  - **函数参数支持 `布尔` 类型**  
    - 在 `parse_function_decl` 参数解析处，目前只处理 `CN_TOKEN_KEYWORD_INT` 或 `CN_TOKEN_KEYWORD_VAR`，扩展为支持 `CN_TOKEN_KEYWORD_BOOL`，生成 `CN_TYPE_BOOL`。
  - **布尔字面量表达式**  
    - 在 `parse_factor` 中增加分支：遇到 `CN_TOKEN_KEYWORD_TRUE`/`FALSE` 时，构造一个新的 `CN_AST_EXPR_*`（可以重用整数 literal 的形式，或新增布尔 literal kind），对应类型设为 `CN_TYPE_BOOL`。

- **语义层 TODO**
  - **条件表达式类型检查**  
    - 在 [`semantic_passes.c`](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/src/semantics/checker/semantic_passes.c) 的 `check_stmt_types` 中，对 `if`/`while`/`for` 条件调用 `infer_expr_type` 后，检查返回类型是否为 `CN_TYPE_BOOL`，否则报“条件必须为布尔类型”的语义错误（规范 4.3/4.4）。
  - **比较/逻辑运算结果类型**  
    - 在 `infer_expr_type` 对比较运算（`==, !=, <, ...`）和逻辑运算（`&&, ||, !`）的分支中，统一将结果标记为 `CN_TYPE_BOOL`。

- **测试 TODO**
  - 在 `tests/integration/compiler` 增加：  
    - 布尔变量声明/赋值/传参/返回值的正反例。  
    - `如果 (真)` / `当 (假)` 等用法。

---

### 2. 小数类型与浮点字面量（`小数`、`1.0` 等）

**当前状态**

- 词法：  
  - `"小数"` 已被映射为 `CN_TOKEN_KEYWORD_FLOAT`。  
  - **没有独立的“浮点数字面量” token**，只有 `CN_TOKEN_INTEGER` 和 `CN_TOKEN_STRING_LITERAL`。
- 语法：
  - 变量/字段/参数类型解析中都**没处理 `CN_TOKEN_KEYWORD_FLOAT`**（同布尔问题）。  
  - 数值字面量 `1.23` 当前会被切成 `INTEGER(1)` + `DOT` + `INTEGER(23)`，没有按规范 2.4.2 的“小数字面量”处理。
- 语义/后端：
  - 类型枚举有 `CN_TYPE_FLOAT`，C 后端能把它映射到 `double`，但前端目前几乎不会构造这种类型。

**TODO**

- **语法层 TODO**
  - 变量声明/结构体字段/函数参数：在上述和布尔类似的位置加入对 `CN_TOKEN_KEYWORD_FLOAT` 的处理，构造 `CN_TYPE_FLOAT`。
  - 浮点字面量：  
    - 在 [`lexer.c`](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/src/frontend/lexer/lexer.c) 的数字扫描逻辑中，增加 `digit+ '.' digit+` 的识别，生成新的 `CN_TOKEN_FLOAT_LITERAL`。  
    - 在 `parse_factor` 里为 `CN_TOKEN_FLOAT_LITERAL` 增加分支，并新增 `CN_AST_EXPR_FLOAT_LITERAL` 及对应的 union 成员和构造函数。

- **语义层 TODO**
  - 在 `infer_expr_type` 处理二元运算时，增加 `int`/`float` 混算规则（例如 `int + float -> float`），并修改 `cn_type_compatible`（[`type_system.c`](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/src/semantics/symbols/type_system.c)）支持必要的隐式转换策略（或暂时禁止混合算术）。

- **测试 TODO**
  - 新增 `examples/float_examples.cn` 和对应 integration test：浮点声明、运算、传参、返回。

---

### 3. 数组类型关键字与显式数组声明（`数组`）

**当前状态**

- 词法：  
  - `"数组"` 已是 `CN_TOKEN_KEYWORD_ARRAY`。  
- 语法：  
  - 示例 [array_examples.cn](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/examples/array_examples.cn) 使用语法：  
    - `数组 arr = [1, 2, 3];`  
  - 但在 `parse_statement` 中，**变量声明分支并不识别 `CN_TOKEN_KEYWORD_ARRAY`**，因此这类代码会被当作普通表达式起始，然后在 `parse_factor` 中报错（`数组` 不是合法表达式开头）。  
  - 目前数组类型只能通过**数组字面量 + 类型推断**出现（`[]` 会被解析为 `CN_AST_EXPR_ARRAY_LITERAL`，类型在语义阶段推断为 `CN_TYPE_ARRAY`），而非通过关键字 `数组` 显式声明。
- 语义/运行时：  
  - 类型系统和运行时已经有 `CN_TYPE_ARRAY`、`cn_rt_array_alloc`、`cn_rt_array_length` 等支持（见运行时绑定规范和 `runtime/memory` 相关代码）。

**TODO**

- **语法层 TODO**
  - **支持 `数组` 作为显式类型**  
    - 在 `parse_statement` 变量声明分支中，加入 `CN_TOKEN_KEYWORD_ARRAY` 分支，将其解析为“数组类型 + 可选元素类型”（与规范 3.3 示例 `数组 数字列表 = [1,2,3]` 对齐，具体语法你可以自己定：例如仅支持 `数组` + 推断，或 `数组 整数 列表`）。  
  - **函数参数与结构体字段的数组类型**  
    - 在 `parse_function_decl` 参数解析、`parse_struct_decl` 字段解析中，同样允许 `CN_TOKEN_KEYWORD_ARRAY` 作为类型前缀，并构造 `cn_type_new_array(element_type, UNKNOWN_LENGTH)` 或某种“数组句柄”类型。

- **语义层 TODO**
  - 在 `infer_expr_type` 中：  
    - 对数组字面量推导出的 `CN_TYPE_ARRAY` 与显式 `数组` 类型保持一致；  
    - 数组赋值/参数传递时检查元素类型是否兼容。  

- **测试 TODO**
  - 让 `examples/array_examples.cn` 真正通过编译，并加入到 `tests/integration/compiler` 的编译通过用例里。  
  - 增加编译失败测试：`数组` 与非数组赋值、索引非整数等。

---

### 4. 模块与导入系统（`模块`、`导入`、`模块名.成员`）

**当前状态**

- 词法：  
  - `"模块"` / `"导入"` 已经映射为 `CN_TOKEN_KEYWORD_MODULE` / `CN_TOKEN_KEYWORD_IMPORT`。  
- AST / 语法 / 语义 / 后端：  
  - AST 中**没有模块相关节点**（[`ast.h`](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/include/cnlang/frontend/ast.h) 里只有函数/结构体/枚举等）。  
  - `parse_program_internal` 顶层只接受 `struct/enum/fn` 三种开头，不识别 `模块`、`导入`。  
  - 语义和 IR 中也不存在模块粒度的符号/IR 模块（当前 `CnIrModule` 是“编译单元”而不是语言层模块）。

**TODO**

- **语法/AST 设计 TODO**
  - 在 `ast.h` 中增加模块相关节点，例如：  
    - `CnAstModuleDecl { name, body_block }` + 新的 `CN_AST_STMT_MODULE_DECL`。  
    - `CnAstImportStmt { name }` + 新的 `CN_AST_STMT_IMPORT`。  
  - 在 `parse_program_internal` 中识别 `CN_TOKEN_KEYWORD_MODULE`、`CN_TOKEN_KEYWORD_IMPORT`，构造对应 AST。  
  - 确定 `模块名.成员` 是用现有的 `CN_AST_EXPR_MEMBER_ACCESS` 表示（当前用于结构体成员），还是引入模块专用节点（建议先复用成员访问）。

- **语义层 TODO**
  - 在 `scope_builder.c` 中增加模块作用域：  
    - 模块名作为顶层符号，模块内部的函数/常量作为子符号表。  
  - `导入` 语义：将被导入模块的符号引入当前编译单元的可见性范围（可以先限制为“同一 `.cn` 文件内声明的模块”，再扩展到多文件）。

- **后端 TODO**
  - 可以先不为模块生成单独的 C 文件，只是把模块名编成 C 名字前缀（例如 `数学工具.加` → `cn_mod_数学工具_加`），与现在的 `get_c_function_name` 逻辑整合。

- **测试 TODO**
  - 添加最小模块用例（来自规范第 6 章的示例），检查模块定义、导入和 `模块名.成员` 调用。

---

### 5. 选择语句：`选择/情况/默认`（switch/case）

**当前状态**

- 词法：  
  - `"选择"` / `"情况"` / `"默认"` 已经映射为 `CN_TOKEN_KEYWORD_SWITCH/CASE/DEFAULT`。  
- AST / 语法 / 语义 / 后端：  
  - AST 中没有 `switch` 相关的语句种类。  
  - `parser.c` 完全没有对这些 token 的处理。  
  - 语义和 IR 也没有相应的逻辑。

**TODO**

- **AST / 语法 TODO**
  - 在 `ast.h` 中增加：  
    - `CnAstSwitchCase { expr, CnAstBlockStmt* body, bool is_default }`  
    - `CnAstSwitchStmt { CnAstExpr* expr, CnAstSwitchCase* cases, size_t case_count }`  
    - 新的 `CN_AST_STMT_SWITCH`。  
  - 在 `parse_statement` 中，当遇到 `CN_TOKEN_KEYWORD_SWITCH` 时：  
    - 解析 `选择 (表达式) { [情况 值: 块]* [默认: 块]? }`（具体语法可根据中文风格调整）。  

- **语义层 TODO**
  - 在 `resolve_stmt_names` / `check_stmt_types` 中增加 `switch` 分支：  
    - `switch` 表达式需为整数或枚举类型。  
    - `case` 值必须是常量表达式，且类型与 `switch` 表达式一致。  

- **IR / 后端 TODO**
  - 在 `cn_ir_gen_stmt` 中增加 `CN_AST_STMT_SWITCH` 的 lowering：  
    - 生成一系列 `if`/`goto` 或 `switch` 风格的 C 代码。

- **测试 TODO**
  - 示例：`选择 x { 情况 1: ... 情况 2: ... 默认: ... }`，以及重复 `case`、缺失 `default` 等错误用例。

---

### 6. 函数参数与结构体字段的类型覆盖不全

除了上面特定类型外，还有一类“看起来支持，但参数/字段位置没完全打通”的问题：

**当前状态**

- 函数参数：  
  - `parse_function_decl` 里，参数类型只支持：  
    - `整数`（`CN_TOKEN_KEYWORD_INT`）→ `CN_TYPE_INT`；  
    - `变量`（类型推断，不创建显式类型）；  
  - 不支持：`字符串`、`布尔`、`小数`、`数组`、`结构体` 类型作为参数类型。  
- 结构体字段：  
  - `parse_struct_decl` 中字段类型仅支持 `整数` 和 `字符串`；不支持布尔、小数、数组、嵌套结构体/枚举。

**TODO**

- **统一的“类型非终结符”解析函数**  
  - 在 `parser.c` 新增一个 `parse_type` 函数，专门解析：  
    - `整数` / `小数` / `布尔` / `字符串` / `数组 ...` / `结构体 名` / `枚举 名` / 指针 `T*` 等。  
  - 将目前 `parse_function_decl` 参数类型解析、`parse_statement` 中显式变量类型、`parse_struct_decl` 字段类型，全部改为调用 `parse_type`。  
  - 这样可以在一个地方集中扩展类型系统。

- **语义层关联**  
  - 确保 `scope_builder.c` 在构建符号表时，把参数/字段的 `declared_type` 一并挂到符号上，后续 IR/CGen 就能使用 `CN_TYPE_FLOAT/BOOL/ARRAY/STRUCT/...` 做正确映射。

---

### 7. 布尔/数组相关内建与“方法风格”调用（例：`arr.长度()`、`是数组(x)`）

**当前状态**

- 规范中主张 `长度(对象)` 作为内建函数（运行时绑定规范中也这么写），但 `array_examples.cn` 中多处使用：  
  - `arr.长度()`、`空数组.长度()`、`是数组(arr)` 等**方法/谓词风格**用法。  
- 目前实现：  
  - 语义分析中对内建函数 `长度(...)` 有特殊处理（在 [`semantic_passes.c`](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/src/semantics/checker/semantic_passes.c) 中识别 callee 为标识符 `"长度"` 时，做字符串/数组判断）。  
  - 但对于 `arr.长度()`：  
    - 解析结果是 `member_access(arr, "长度")` 再调用，这时 `callee` 不再是标识符 `"长度"`，而是一个成员访问表达式，**当前逻辑不会把它识别为内建**。  
  - `是数组` 在源码中没有任何实现。

**TODO**

- **语法/语义约定选择**
  - 确定最终规范：  
    - A. 保持函数风格 `长度(arr)`，那就需要把示例改回来；  
    - B. 支持方法风格 `arr.长度()`，则语义/运行时要对 `member_access` + 调用做特殊处理。  

- **如果选择方法风格（B）**  
  - 在 `infer_expr_type` 中：  
    - 检测形如 `call( member_access(obj, "长度"), ... )` 的模式，映射为对 `数组长度`/`字符串长度` 的内建调用。  
  - 在 IR 生成中：  
    - 为上述模式生成调用 `cn_rt_array_length` 或 `cn_rt_string_length` 的 IR。  
  - 为 `是数组(x)` 增加内建实现：  
    - 作为返回 `布尔` 的内建函数，统一在 `semantic_passes.c` 中处理并映射到运行时（如果需要的话）。

---

### 8. 高级特性关键字（类/接口/模板/命名空间/访问控制等）

这些属于**未来扩展**，严格来说不在“基础语法”范畴，但因为在词法层已经暴露，会让用户误以为已经支持：

- `类`、`接口`、`模板`、`命名空间`、`常量`、`静态`、`公开/私有/保护`、`虚拟/重写/抽象` 等：
  - 词法层：都有对应的 `CN_TOKEN_KEYWORD_*`。  
  - 语法/语义/IR：完全没有对应实现和 AST。

**TODO（建议阶段性处理）**

- **短期**：在文档中明确这些关键字目前只是“预留”状态，不在当前版本支持范围，避免误用。  
- **中长期**：等阶段 8/后续阶段时，按模块化设计分别为：类/接口系统、可见性与访问控制、模板/泛型等增加完整的 AST/语义/后端设计与实现。

---

## 小结

- **已实现**：整数/字符串、函数与 `主程序`、`如果/否则`、`当/循环`、break/continue、数组字面量与索引、结构体/枚举、指针与函数指针等核心能力已经打通，并在多个示例和测试中使用。  
- **缺口最大的“基础语法”** 主要集中在：**布尔/小数类型和字面量、`数组` 关键字及显式数组声明、模块/导入系统、`选择/情况/默认` 语句，以及你示例中使用的 `arr.长度()`/`是数组` 这种方法风格/内建**。  
- 上面每一节都拆成了“词法/语法/语义/IR/测试”维度的 TODO，你可以按优先级（先补布尔/小数/数组，再做模块和 switch，最后才是 OOP 关键字）逐步实现。  

如果你愿意，我可以下一步帮你**选一个你最想先补的特性（比如布尔 + 小数）**，直接给出对应 `parser.c` / `semantic_passes.c` 的具体修改方案。