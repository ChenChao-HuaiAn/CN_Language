根据《阶段 7后：完善前面功能.md》中的分析，整理出可执行的编译器完善 TODO 列表：

### 阶段 7后：完善前面功能 TODO 列表

#### 一、布尔类型与布尔字面量（`布尔`、`真`、`假`）

- [ ] **词法与标记复查**  
  - [ ] 在 `include/cnlang/frontend/token.h` / `src/frontend/lexer/lexer.c` 中确认 `CN_TOKEN_KEYWORD_BOOL/TRUE/FALSE` 定义与关键字匹配，无多余或冲突标记。
- [ ] **语法层：变量/字段/参数支持布尔类型**  
  - [ ] 在 `parse_statement` 中将变量声明起始 token 扩展为包含 `CN_TOKEN_KEYWORD_BOOL`，并构造 `cn_type_new_primitive(CN_TYPE_BOOL)`。  
  - [ ] 在 `parse_struct_decl` 中允许字段类型为 `布尔`，并支持布尔指针字段（`布尔*`）。  
  - [ ] 在 `parse_function_decl` 参数解析中支持 `布尔` 形参类型及其指针形式。
- [ ] **语法层：布尔字面量表达式**  
  - [ ] 在 `parse_factor` 中为 `CN_TOKEN_KEYWORD_TRUE` / `CN_TOKEN_KEYWORD_FALSE` 增加分支。  
  - [ ] 在 AST 中新增或重用布尔字面量表达式节点（例如 `CN_AST_EXPR_BOOL_LITERAL`），并在构造函数中将类型设为 `CN_TYPE_BOOL`（或留待语义阶段填充）。
- [ ] **语义层：条件与运算结果类型为布尔**  
  - [ ] 在 `infer_expr_type` 中将比较运算（`==, !=, <, <=, >, >=`）结果统一标记为 `CN_TYPE_BOOL`。  
  - [ ] 在 `infer_expr_type` 中将逻辑运算（`&&, ||, !`）结果统一标记为 `CN_TYPE_BOOL`。  
  - [ ] 在 `check_stmt_types` 中对 `if/while/for` 条件调用 `infer_expr_type` 后，检查结果为布尔，否则通过 diagnostics 报“条件必须为布尔类型”的语义错误。  
- [ ] **测试与文档**  
  - [ ] 在 `tests/integration/compiler` 中增加布尔变量声明、赋值、参数传递、返回值及条件表达式的正反例。  
  - [ ] 在语言规范草案与测试规范中补充布尔类型与布尔字面量的实现状态与限制说明。

---

#### 二、小数类型与浮点字面量（`小数`、`1.0` 等）

- [ ] **语法层：类型声明支持 `小数`**  
  - [ ] 在变量声明、结构体字段、函数参数解析中，新增对 `CN_TOKEN_KEYWORD_FLOAT` 的处理，构造 `CN_TYPE_FLOAT` 及其指针类型。  
- [ ] **词法层：浮点字面量 token**  
  - [ ] 在 `lexer.c` 中扩展数字扫描逻辑，识别 `digit+ '.' digit+` 形式为新的 `CN_TOKEN_FLOAT_LITERAL`。  
  - [ ] 确保整数与浮点字面量在回溯和错误路径上行为一致，避免拆成 `INTEGER + DOT + INTEGER`。  
- [ ] **语法层：浮点字面量表达式**  
  - [ ] 在 AST 中为浮点字面量增加节点（如 `CN_AST_EXPR_FLOAT_LITERAL`），并在 `parse_factor` 中解析 `CN_TOKEN_FLOAT_LITERAL`。  
- [ ] **语义层：整数与小数混合运算规则**  
  - [ ] 在 `infer_expr_type` 中为二元算术运算添加 `int/float` 组合处理策略（如 `int + float -> float`）。  
  - [ ] 扩展 `cn_type_compatible` 与相关类型比较函数，支持必要的隐式数值提升或在不支持时给出清晰错误。  
- [ ] **测试与文档**  
  - [ ] 新增 `examples/float_examples.cn`，覆盖浮点声明、算术运算、参数传递与返回值。  
  - [ ] 在集成测试中加入浮点编译通过/失败用例，并在语言规范的字面量章节标注当前实现范围与未支持情况。

---

#### 三、`数组` 关键字与显式数组声明

- [ ] **语法层：`数组` 变量声明**  
  - [ ] 在 `parse_statement` 的变量声明分支中，增加对 `CN_TOKEN_KEYWORD_ARRAY` 的识别。  
  - [ ] 设计并实现显式数组声明语法（例如 `数组 整数 列表 = [1, 2, 3];` 或 `数组 列表 = [1, 2, 3];`），与现有数组字面量/类型推断机制兼容。  
- [ ] **语法层：数组参数与数组字段**  
  - [ ] 在 `parse_function_decl` 参数列表中支持以 `数组` 开头的类型说明（可配合元素类型关键字）。  
  - [ ] 在 `parse_struct_decl` 中支持数组字段的显式类型（如 `数组 整数 数据;`）。  
- [ ] **语义层：显式数组类型与字面量统一**  
  - [ ] 在 `infer_expr_type` 中统一显式 `数组` 类型与数组字面量推导得到的 `CN_TYPE_ARRAY` 表示。  
  - [ ] 在赋值、参数传递等场景检查数组元素类型一致性，并在不匹配时给出诊断。  
- [ ] **测试与文档**  
  - [ ] 让 `examples/array_examples.cn` 在新语法下完整通过编译，并加入到集成测试流水线。  
  - [ ] 补充编译失败用例：将非数组赋给 `数组` 变量、数组索引非整数等。  
  - [ ] 在语言规范和运行时绑定规范中记录显式数组类型语法与运行时表示。

---

#### 四、模块与导入系统（`模块`、`导入`、`模块名.成员`）

- [ ] **AST 与语法设计**  
  - [ ] 在 `ast.h` 中为模块与导入新增节点类型（如 `CN_AST_STMT_MODULE_DECL`、`CN_AST_STMT_IMPORT` 以及相应结构体）。  
  - [ ] 在 `parse_program_internal` 中识别 `CN_TOKEN_KEYWORD_MODULE`、`CN_TOKEN_KEYWORD_IMPORT`，构造模块定义与导入语句 AST。  
  - [ ] 定义 `模块 名 { ... }` 与 `导入 模块名;` 的准确语法，并确定 `模块名.成员` 是复用 `CN_AST_EXPR_MEMBER_ACCESS` 还是增加模块专用表达式节点。  
- [ ] **语义层：模块作用域与导入语义**  
  - [ ] 在 `scope_builder.c` 中为模块引入新的作用域层级，将模块名作为顶层符号，内部函数/常量作为子符号表中的条目。  
  - [ ] 实现 `导入` 语义：将被导入模块的公共符号引入当前编译单元可见集合（初期可限制为同一 `.cn` 文件中的模块）。  
- [ ] **IR / 后端：模块名到 C 名字映射**  
  - [ ] 在 C 后端（`cgen.c`）中定义模块作用域到 C 标识符的映射规则，例如 `数学工具.加` → `cn_mod_数学工具_加`，并与现有 `get_c_function_name` 逻辑集成。  
- [ ] **测试与文档**  
  - [ ] 基于语言规范第 6 章示例，新增最小模块定义/导入/成员访问的编译通过与失败用例。  
  - [ ] 在语言规范和开发计划中更新模块系统的实现状态与约束（如暂不支持跨文件模块等）。

---

#### 五、选择语句：`选择/情况/默认`（switch/case）

- [ ] **AST 与语法实现**  
  - [ ] 在 `ast.h` 中为 `switch` 语句新增节点定义（如 `CnAstSwitchCase`、`CnAstSwitchStmt` 与 `CN_AST_STMT_SWITCH`）。  
  - [ ] 在 `parse_statement` 中识别 `CN_TOKEN_KEYWORD_SWITCH`，实现 `选择 (表达式) { [情况 值: 块]* [默认: 块]? }` 的解析逻辑。  
- [ ] **语义层：选择语句约束**  
  - [ ] 在 `resolve_stmt_names` / `check_stmt_types` 中增加 `switch` 分支：检查 `switch` 表达式类型为整数或枚举。  
  - [ ] 检查每个 `case` 常量表达式类型与 `switch` 表达式一致，并处理重复 `case`、多重 `默认` 等错误。  
- [ ] **IR / 后端生成**  
  - [ ] 在 `cn_ir_gen_stmt` 中为 `CN_AST_STMT_SWITCH` 实现 lowering，初期可以生成一系列 `if`/`goto`，后续再考虑结构化为 C `switch`。  
- [ ] **测试与文档**  
  - [ ] 添加包含多个 `情况` 和 `默认` 分支的示例，覆盖正常流程与错误场景（如缺少 `默认`、重复 `case` 等）。  
  - [ ] 在语言规范中补充 `选择/情况/默认` 的精确定义、支持的表达式类型与限制。

---

#### 六、函数参数与结构体字段的类型覆盖补全

- [ ] **统一类型解析入口 `parse_type`**  
  - [ ] 在 `parser.c` 中新增 `parse_type` 函数，集中解析 `整数/小数/布尔/字符串/数组/结构体/枚举/指针` 等类型组合。  
  - [ ] 将 `parse_function_decl` 参数类型解析、`parse_statement` 中显式变量类型、`parse_struct_decl` 字段类型均改为调用 `parse_type`，消除重复逻辑。  
- [ ] **参数与字段类型使用场景补全**  
  - [ ] 确保函数参数可声明为上述所有基础和复合类型（包括指针和数组），并正确写入 `CnAstParameter.declared_type`。  
  - [ ] 确保结构体字段支持对应类型，并在 AST 中正确保存 `field_type`。  
- [ ] **语义层：类型信息贯通**  
  - [ ] 在 `scope_builder.c` 中，构建符号表时将参数和字段的 `declared_type` 挂到符号条目上，便于类型检查与 C 后端使用。  
  - [ ] 检查现有类型推断/兼容性逻辑是否需要针对新增类型组合扩展（例如数组/指针/结构体参数传递）。  
- [ ] **测试与文档**  
  - [ ] 编写覆盖多种类型组合的函数声明/调用与结构体定义/使用示例，验证类型信息在 AST → 语义 → IR → C 代码路径上正确传递。  
  - [ ] 在语言规范的类型系统章节中补全目前真正实现/支持的参数与字段类型组合。

---

#### 七、布尔/数组相关内建与“方法风格”调用（`arr.长度()`、`是数组(x)`）

- [ ] **规范层决策：函数风格 vs 方法风格**  
  - [ ] 在规范与实现中统一决策：是仅支持 `长度(arr)` 函数风格，还是额外支持 `arr.长度()` 方法风格；必要时调整示例程序以与最终方案一致。  
- [ ] **方法风格支持方案（如选择支持）**  
  - [ ] 在 `infer_expr_type` 中识别 `call( member_access(obj, "长度"), ... )` 模式，将其视为对 `数组长度`/`字符串长度` 内建函数的特殊调用，并返回 `整数` 类型。  
  - [ ] 在 IR 生成阶段，将上述模式映射为 `cn_rt_array_length` 或 `cn_rt_string_length` 调用，而非普通成员函数调用。  
  - [ ] 为 `是数组(x)` 设计内建语义：在语义层识别该调用，并检查参数类型返回 `布尔`，后端映射到运行时实现（可选）。  
- [ ] **测试与文档**  
  - [ ] 针对 `arr.长度()` / `长度(arr)` / `是数组(x)` 等形式编写正反例，确认诊断与运行时行为符合预期。  
  - [ ] 在运行时绑定规范与语言规范中明确这些内建的调用形式、支持的参数类型与返回值类型。

---

#### 八、高级特性关键字（类/接口/模板/命名空间/访问控制等）

- [ ] **当前阶段的支持范围声明**  
  - [ ] 在语言规范中显式标注：`类`、`接口`、`模板`、`命名空间`、`常量`、`静态`、`公开/私有/保护`、`虚拟/重写/抽象` 等关键字目前仅为**预留**，词法上可识别但不在本阶段实现的核心语法范围内。  
- [ ] **未来阶段的设计预研（可选）**  
  - [ ] 为上述每一类特性（类/接口、访问控制、模板等）在设计文档中建立占位章节，简要记录潜在的 AST/语义/后端设计方向，但不在当前阶段实现。  
  - [ ] 确保当前编译器在遇到相关关键字时给出清晰诊断，而不是出现未定义行为或崩溃。
