根据《阶段 7后：完善前面功能.md》中的分析，整理出可执行的编译器完善 TODO 列表：

### 阶段 7后：完善前面功能 TODO 列表

#### 一、布尔类型与布尔字面量（`布尔`、`真`、`假`）

- [x] **词法与标记复查**  
  - [x] 在 `include/cnlang/frontend/token.h` / `src/frontend/lexer/lexer.c` 中确认 `CN_TOKEN_KEYWORD_BOOL/TRUE/FALSE` 定义与关键字匹配，无多余或冲突标记。
- [x] **语法层：变量/字段/参数支持布尔类型**  
  - [x] 在 `parse_statement` 中将变量声明起始 token 扩展为包含 `CN_TOKEN_KEYWORD_BOOL`，并构造 `cn_type_new_primitive(CN_TYPE_BOOL)`。  
  - [x] 在 `parse_struct_decl` 中允许字段类型为 `布尔`，并支持布尔指针字段（`布尔*`）。  
  - [x] 在 `parse_function_decl` 参数解析中支持 `布尔` 形参类型及其指针形式。
- [x] **语法层：布尔字面量表达式**  
  - [x] 在 `parse_factor` 中为 `CN_TOKEN_KEYWORD_TRUE` / `CN_TOKEN_KEYWORD_FALSE` 增加分支。  
  - [x] 在 AST 中新增布尔字面量表达式节点（`CN_AST_EXPR_BOOL_LITERAL`），并在构造函数中将类型设为 `CN_TYPE_BOOL`。
- [x] **语义层：条件与运算结果类型为布尔**  
  - [x] 在 `infer_expr_type` 中将比较运算（`==, !=, <, <=, >, >=`）结果统一标记为 `CN_TYPE_BOOL`。  
  - [x] 在 `infer_expr_type` 中将逻辑运算（`&&, ||, !`）结果统一标记为 `CN_TYPE_BOOL`。  
  - [x] 在 `check_stmt_types` 中对 `if/while/for` 条件调用 `infer_expr_type` 后，检查结果为布尔，否则通过 diagnostics 报“条件必须为布尔类型”的语义错误。  
- [x] **IR生成层：布尔字面量支持**
  - [x] 在 `irgen.c` 的 `cn_ir_gen_expr` 中为 `CN_AST_EXPR_BOOL_LITERAL` 添加处理，生成立即数（0/1）并标记为 `CN_TYPE_BOOL`。
- [x] **后端代码生成：布尔寄存器声明**
  - [x] 在 `cgen.c` 中为 `CN_TYPE_BOOL` 类型的寄存器添加专门的声明逻辑，生成 `_Bool rN;` 声明。
- [x] **测试与文档**  
  - [x] 在 `examples/` 中增加布尔变量声明、赋值、参数传递、返回值及条件表达式的示例。  
  - [x] 在语言规范草案与测试规范中补充布尔类型与布尔字面量的实现状态与限制说明。

---

#### 二、小数类型与浮点字面量（`小数`、`1.0` 等）

- [x] **语法层：类型声明支持 `小数`**  
  - [x] 在变量声明、结构体字段、函数参数解析中，新增对 `CN_TOKEN_KEYWORD_FLOAT` 的处理，构造 `CN_TYPE_FLOAT` 及其指针类型。  
- [x] **词法层：浮点字面量 token**  
  - [x] 在 `lexer.c` 中扩展数字扫描逻辑，识别 `digit+ '.' digit+` 形式为新的 `CN_TOKEN_FLOAT_LITERAL`。  
  - [x] 确保整数与浮点字面量在回溯和错误路径上行为一致，避免拆成 `INTEGER + DOT + INTEGER`。  
- [x] **语法层：浮点字面量表达式**  
  - [x] 在 AST 中为浮点字面量增加节点（如 `CN_AST_EXPR_FLOAT_LITERAL`），并在 `parse_factor` 中解析 `CN_TOKEN_FLOAT_LITERAL`。  
- [x] **语义层：整数与小数混合运算规则**  
  - [x] 在 `infer_expr_type` 中为二元算术运算添加 `int/float` 组合处理策略（如 `int + float -> float`）。  
  - [x] 扩展 `cn_type_compatible` 与相关类型比较函数，支持必要的隐式数值提升或在不支持时给出清晰错误。  
- [x] **IR 层：浮点立即数支持**
  - [x] 在 `ir.h` 中添加 `CN_IR_OP_IMM_FLOAT` 操作数类型。
  - [x] 在 `ir.c` 中实现 `cn_ir_op_imm_float` 辅助函数。
  - [x] 在 `irgen.c` 中处理 `CN_AST_EXPR_FLOAT_LITERAL` 表达式。
- [x] **代码生成层：浮点寄存器支持**
  - [x] 在 `cgen.c` 的 `print_operand` 中处理 `CN_IR_OP_IMM_FLOAT`。
  - [x] 在 `cn_cgen_function` 中为浮点类型寄存器声明 `double`。
- [x] **测试与文档**  
  - [x] 新增 `examples/float_examples.cn`、`examples/float_ops.cn`、`examples/float_mixed.cn`，覆盖浮点声明、算术运算、混合运算。  
  - [x] 在集成测试中加入浮点编译通过用例 (`integration_compile_full_test.c`)。  
  - [x] 在语言规范的字面量章节标注当前实现范围与未支持情况。

---

#### 三、`数组` 关键字与显式数组声明

- [x] **语法层：`数组` 变量声明**  
  - [x] 在 `parse_statement` 的变量声明分支中，增加对 `CN_TOKEN_KEYWORD_ARRAY` 的识别。  
  - [x] 设计并实现显式数组声明语法（例如 `数组 整数 列表 = [1, 2, 3];` 或 `数组 列表 = [1, 2, 3];`），与现有数组字面量/类型推断机制兼容。  
- [x] **语法层：数组参数与数组字段**  
  - [x] 在 `parse_function_decl` 参数列表中支持以 `数组` 开头的类型说明（可配合元素类型关键字）。  
  - [x] 在 `parse_struct_decl` 中支持数组字段的显式类型（如 `数组 整数 数据;`）。  
- [x] **语义层：显式数组类型与字面量统一**  
  - [x] 在 `infer_expr_type` 中统一显式 `数组` 类型与数组字面量推导得到的 `CN_TYPE_ARRAY` 表示。  
  - [x] 在赋值、参数传递等场景检查数组元素类型一致性，并在不匹配时给出诊断。  
- [x] **测试与文档**  
  - [x] 让 `examples/array_examples.cn` 在新语法下完整通过编译，并加入到集成测试流水线。  
  - [x] 补充编译失败用例：将非数组赋给 `数组` 变量、数组索引非整数等。  
  - [x] 在语言规范和运行时绑定规范中记录显式数组类型语法与运行时表示。

---

### 四、模块与导入系统（`模块`、`导入`、`模块名.成员`）
    按需引入：可指定需要的内容
    命名空间控制：避免命名冲突
    显式依赖：清晰看到依赖关系
- [x] **AST 与语法设计**  
  - [x] 在 `ast.h` 中为模块与导入新增节点类型（如 `CN_AST_STMT_MODULE_DECL`、`CN_AST_STMT_IMPORT` 以及相应结构体）。  
  - [x] 在 `parse_program_internal` 中识别 `CN_TOKEN_KEYWORD_MODULE`、`CN_TOKEN_KEYWORD_IMPORT`，构造模块定义与导入语句 AST。  
  - [x] 定义 `模块 名 { ... }` 与 `导入 模块名;` 的准确语法，并确定 `模块名.成员` 是复用 `CN_AST_EXPR_MEMBER_ACCESS` 还是增加模块专用表达式节点。  
- [x] **语义层：模块作用域与导入语义**  
  - [x] 在 `scope_builder.c` 中为模块引入新的作用域层级，将模块名作为顶层符号，内部函数/常量作为子符号表中的条目。  
  - [x] 实现 `导入` 语义：将被导入模块的公共符号引入当前编译单元可见集合（初期可限制为同一 `.cn` 文件中的模块）。
  - [x] 在 `semantic_passes.c` 中实现模块成员访问（`模块名.成员`）的语义检查和类型推断。
- [x] **IR / 后端：模块名到 C 名字映射**  
  - [x] 在 IR 生成器（`irgen.c`）中实现模块成员访问的特殊处理，生成带模块前缀的符号名（格式：`模块名__成员名`）。
  - [x] 在 C 后端（`cgen.c`）中定义模块作用域到 C 标识符的映射规则，例如 `数学工具.常量值` → `cn_module_数学工具__常量值`。
  - [x] 在程序生成阶段输出模块变量的全局定义。  
- [x] **测试与文档**  
  - [x] 基于语言规范第 6 章示例，新增最小模块定义/导入/成员访问的编译通过与失败用例。  
  - [x] 在语言规范和开发计划中更新模块系统的实现状态与约束（如暂不支持跨文件模块等）。

---

#### 五、选择语句：`选择/情况/默认`（switch/case）

- [x] **AST 与语法实现**  
  - [x] 在 `ast.h` 中为 `switch` 语句新增节点定义（如 `CnAstSwitchCase`、`CnAstSwitchStmt` 与 `CN_AST_STMT_SWITCH`）。  
  - [x] 在 `parse_statement` 中识别 `CN_TOKEN_KEYWORD_SWITCH`，实现 `选择 (表达式) { [情况 值: 块]* [默认: 块]? }` 的解析逻辑。  
- [x] **语义层：选择语句约束**  
  - [x] 在 `resolve_stmt_names` / `check_stmt_types` 中增加 `switch` 分支：检查 `switch` 表达式类型为整数或枚举。  
  - [x] 检查每个 `case` 常量表达式类型与 `switch` 表达式一致，并处理重复 `case`、多重 `默认` 等错误。  
- [x] **IR / 后端生成**  
  - [x] 在 `cn_ir_gen_stmt` 中为 `CN_AST_STMT_SWITCH` 实现 lowering，初期可以生成一系列 `if`/`goto`，后续再考虑结构化为 C `switch`。  
- [x] **测试与文档**  
  - [x] 添加包含多个 `情况` 和 `默认` 分支的示例，覆盖正常流程与错误场景（如缺少 `默认`、重复 `case` 等）。  
  - [x] 在语言规范中补充 `选择/情况/默认` 的精确定义、支持的表达式类型与限制。

---

#### 六、函数参数与结构体字段的类型覆盖补全 ✅ **已完成**

- [x] **统一类型解析入口 `parse_type`**  
  - [x] 在 `parser.c` 中新增 `parse_type` 函数，集中解析 `整数/小数/布尔/字符串/数组/结构体/枚举/指针` 等类型组合。  
  - [x] 将 `parse_function_decl` 参数类型解析、`parse_statement` 中显式变量类型、`parse_struct_decl` 字段类型均改为调用 `parse_type`，消除重复逻辑。  
- [x] **参数与字段类型使用场景补全**  
  - [x] 确保函数参数可声明为上述所有基础和复合类型（包括指针和数组），并正确写入 `CnAstParameter.declared_type`。  
  - [x] 确保结构体字段支持对应类型，并在 AST 中正确保存 `field_type`。  
- [x] **语义层：类型信息贯通**  
  - [x] 在 `scope_builder.c` 中，构建符号表时将参数和字段的 `declared_type` 挂到符号条目上，便于类型检查与 C 后端使用。  
  - [x] 检查现有类型推断/兼容性逻辑是否需要针对新增类型组合扩展（例如数组/指针/结构体参数传递）。  
- [x] **测试与文档**  
  - [x] 编写覆盖多种类型组合的函数声明/调用与结构体定义/使用示例，验证类型信息在 AST → 语义 → IR → C 代码路径上正确传递。  
  - [x] 在语言规范的类型系统章节中补全目前真正实现/支持的参数与字段类型组合。

---

#### 七、布尔/数组相关内建与“方法风格”调用（`arr.长度()`、`是数组(x)`）

- [x] **规范层决策：函数风格 vs 方法风格**  
  - [x] 在规范与实现中统一决策：同时支持 `长度(arr)` 函数风格和 `arr.长度()` 方法风格；两种方式等价，都返回整数类型。  
- [x] **方法风格支持方案**  
  - [x] 在 `infer_expr_type` 中识别 `call( member_access(obj, "长度"), ... )` 模式，将其视为对 `数组长度`/`字符串长度` 内建函数的特殊调用，并返回 `整数` 类型。  
  - [x] 在 IR 生成阶段，将上述模式映射为 `cn_rt_array_length` 或 `cn_rt_string_length` 调用，而非普通成员函数调用。  
  - [x] 在 `member_access` 类型推断中特殊处理 `对象.长度` 访问，当对象为数组或字符串时不报错。
- [x] **测试与文档**  
  - [x] 针对 `arr.长度()` / `长度(arr)`  等形式编写正反例，确认诊断与运行时行为符合预期。  
  - [x] 在运行时绑定规范与语言规范中明确这些内建的调用形式、支持的参数类型与返回值类型。

---

#### 八、高级特性关键字（类/接口/模板/命名空间/访问控制等）

- [x] **当前阶段的支持范围声明**  
  - [x] 在语言规范中显式标注：`类`、`接口`、`模板`、`命名空间`、`常量`、`静态`、`公开/私有/保护`、`虚拟/重写/抽象` 等关键字目前仅为**预留**，词法上可识别但不在本阶段实现的核心语法范围内。  
    - 完成时间：2026-01-25
    - 实现详情：
      - 在 `CN_Language 语言规范草案（核心子集）.md` 中新增了 2.3.1 预留关键字章节
      - 详细列出了 12 个预留关键字，分为四大类：类型系统扩展、面向对象特性、访问控制、泛型与命名空间
      - 明确了使用约束和未来计划
      - 在第 8 章增加了详细的未来扩展说明
  - [x] 在诊断系统中添加预留特性错误码 `CN_DIAG_CODE_PARSE_RESERVED_FEATURE`
    - 完成时间：2026-01-25
    - 实现详情：在 `diagnostics.h` 中添加了新的诊断错误码
  - [x] 在 parser 中实现预留关键字检测和诊断功能
    - 完成时间：2026-01-25
    - 实现详情：
      - 实现了 `is_reserved_keyword()` 函数判断是否为预留关键字
      - 实现了 `get_reserved_keyword_error_msg()` 返回针对每个预留关键字的中文错误消息
      - 实现了 `check_reserved_keyword()` 在解析过程中自动检测预留关键字
      - 在 `parse_program_internal()` 主循环中调用检测逻辑
  - [x] 创建测试用例 `test_reserved_keywords.cn` 验证功能
    - 完成时间：2026-01-25
    - 实现详情：
      - 创建了综合测试文件，覆盖所有 12 个预留关键字
      - 测试通过，所有预留关键字都正确报告错误：「语法错误：关键字 'XXX' 为预留特性，当前版本暂不支持」
- [x] **未来阶段的设计预研**  
  - [x] 为上述每一类特性（类/接口、访问控制、模板等）在设计文档中建立占位章节，简要记录潜在的 AST/语义/后端设计方向，但不在当前阶段实现。  
    - 完成时间：2026-01-25
    - 实现详情：
      - 在 `CN_Language 开发计划.md` 中新增了第 4 章「未来高级特性设计占位」
      - 详细设计了 5 大类特性：
        1. 面向对象编程扩展（类、接口、虚函数、抽象类）
        2. 访问控制系统（公开、私有、保护）
        3. 泛型与模板系统
        4. 高级类型特性（常量、静态）
        5. 命名空间系统
      - 每个特性都记录了 AST、语义、IR、后端的设计要点
      - 定义了实现优先级（P0/P1/P2）
      - 规划了阶段 9-12 的实现路线图（约 19-26 周）
      - 明确了测试策略和文档要求
  - [x] 确保当前编译器在遇到相关关键字时给出清晰诊断，而不是出现未定义行为或崩溃。
    - 完成时间：2026-01-25
    - 验证结果：所有预留关键字都会在解析阶段被检测并报告清晰错误，不会崩溃

**总结**：
- 所有预留关键字已在语言规范中明确标注为预留状态
- 编译器已实现对预留关键字的检测和清晰诊断
- 测试用例验证了功能的正确性
- 开发计划中已为未来实现建立了完整的设计占位章节

---

#### 九、模块系统高级功能深化

基于第四小节已完成的模块系统基础功能，本小节将实现以下高级特性：

- [x] **导入语句的自动符号导入**
  - [x] 在 `scope_builder.c` 中处理 `CN_AST_STMT_IMPORT` 节点时，查找被导入模块的符号表。
  - [x] 将被导入模块的所有公开符号添加到当前作用域，使其可直接访问（无需模块名前缀）。
  - [x] 处理名称冲突：如果导入的符号与当前作用域已有符号名称相同，发出诊断错误。
  - [x] 测试：创建测试用例验证 `导入 模块名;` 后可以直接使用 `成员名` 而无需 `模块名.成员名`。

- [x] **模块内函数声明支持**
  - [x] 在 `parser.c` 的 `parse_module_decl` 中扩展支持函数声明解析。
  - [x] 调整 AST 设计：将函数声明作为语句类型，或者在模块结构中单独存储函数列表。
  - [x] 在 `scope_builder.c` 中将模块内的函数添加到模块作用域的符号表中。
  - [x] 在 `cgen.c` 中生成模块函数的 C 代码，函数名格式：`cn_module_模块名__函数名`。
  - [x] 测试：创建包含模块函数定义和调用的测试用例。
  
- [x] **模块可见性控制（公开/私有）**
  - [x] 词法层：确认 `公开` 和 `私有` 关键字已在 `lexer.c` 中支持。
  - [x] AST 层：在模块成员声明中添加可见性属性（`is_public`/`is_private`）。
  - [x] 解析层：支持解析 `公开: 整数 变量名;` 和 `私有: 整数 变量名;` 语法。
  - [x] 语义层：在符号表中记录成员的可见性，检查访问权限（私有成员仅模块内可访问）。
  - [x] 测试：验证公开成员可以从模块外访问，私有成员访问时报错。

- [x] **模块变量的复杂初始化**
  - [x] 在 `cgen.c` 中扩展模块变量初始化逻辑，支持非字面量表达式。
  - [x] 对于复杂表达式，生成初始化函数（如 `__cn_init_module_模块名()`）。
  - [x] 在 `main` 函数开始时或程序启动时调用模块初始化函数。
  - [x] 测试：验证模块变量可以用表达式初始化（如 `整数 x = 1 + 2;`）。

- [ ] **按需导入（选择性导入）**
  - [ ] 语法设计：支持 `导入 模块名::成员名;` 或 `导入 模块名 { 成员名1, 成员名2 };` 语法。
  - [ ] AST 层：扩展 `CnAstImportStmt` 支持成员列表。
  - [ ] 解析层：解析选择性导入语句。
  - [ ] 语义层：仅导入指定的成员到当前作用域。
  - [ ] 测试：验证只有指定的成员可直接访问，其他成员需要模块前缀。

- [ ] **模块别名支持**
  - [ ] 语法设计：支持 `导入 模块名 为 别名;` 语法。
  - [ ] AST 层：在 `CnAstImportStmt` 中添加别名字段。
  - [ ] 语义层：将模块以别名注册到当前作用域。
  - [ ] 测试：验证可以使用 `别名.成员名` 访问模块成员。

- [ ] **集成测试与文档**
  - [ ] 编写综合性测试用例，覆盖以上所有高级特性。
  - [ ] 更新语言规范，说明模块系统的完整功能和用法。
  - [ ] 在开发计划中更新模块系统的实现状态。
