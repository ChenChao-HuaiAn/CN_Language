## 整体结论

- **当前实现中，词法层已经定义了约 50 个“关键字类” token**（`CN_TOKEN_KEYWORD_*`），远超核心子集文档里列出的那一小撮。  
- 按语言规范和实现情况来看，**真正“核心、现在就需要”的关键字其实只有十几二十个**，其余要么是**预留关键字**，要么是**OS/内存/中断等系统特化指令**，要么是**语法糖/还没实现的设想**，完全可以在当前阶段视为“不必要”。

下面我先把关键字完整列出来，再帮你分层标出“现在不必要”的部分，方便后面你做裁剪设计。

---

## 1. 当前代码中所有关键字（一览表）

以下列表来自词法枚举 [`CnTokenKind`](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/include/cnlang/frontend/token.h) 和关键字匹配函数 [`keyword_kind`](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/src/frontend/lexer/lexer.c)：

### 1.1 程序结构 / 函数相关

- **`函数`** → `CN_TOKEN_KEYWORD_FN`  
- **`主程序`** → `CN_TOKEN_KEYWORD_MAIN`（函数名特殊对待）  
- **`返回`** → `CN_TOKEN_KEYWORD_RETURN`

### 1.2 变量与类型相关

- **`变量`** → `CN_TOKEN_KEYWORD_VAR`
- **`整数`** → `CN_TOKEN_KEYWORD_INT`
- **`小数`** → `CN_TOKEN_KEYWORD_FLOAT`
- **`字符串`** → `CN_TOKEN_KEYWORD_STRING`
- **`布尔`** → `CN_TOKEN_KEYWORD_BOOL`
- **`数组`** → `CN_TOKEN_KEYWORD_ARRAY`
- **`结构体`** → `CN_TOKEN_KEYWORD_STRUCT`
- **`枚举`** → `CN_TOKEN_KEYWORD_ENUM`
- **`常量`** → `CN_TOKEN_KEYWORD_CONST`
- **`空`**（注释里写“空类型”）→ `CN_TOKEN_KEYWORD_VOID`
- **`无`**（null 概念）→ `CN_TOKEN_KEYWORD_NULL`

### 1.3 控制流关键字

- **`如果`** → `CN_TOKEN_KEYWORD_IF`
- **`否则`** → `CN_TOKEN_KEYWORD_ELSE`
- **`当`** → `CN_TOKEN_KEYWORD_WHILE`
- **`循环`** → `CN_TOKEN_KEYWORD_FOR`
- **`从`** → 映射成 `CN_TOKEN_KEYWORD_FOR`（`keyword_kind` 里把 `从` 也当作 for）
- **`中断`** → `CN_TOKEN_KEYWORD_BREAK`
- **`继续`** → `CN_TOKEN_KEYWORD_CONTINUE`
- **`选择`** → `CN_TOKEN_KEYWORD_SWITCH`
- **`情况`** → `CN_TOKEN_KEYWORD_CASE`
- **`默认`** → `CN_TOKEN_KEYWORD_DEFAULT`

### 1.4 布尔字面量

- **`真`** → `CN_TOKEN_KEYWORD_TRUE`
- **`假`** → `CN_TOKEN_KEYWORD_FALSE`

（规范 2.4.4 中也明确把 `真` / `假` 作为布尔字面量，这里在实现上用“KEYWORD” 的 token 表示。）

### 1.5 模块 / 命名空间 / 别名相关

- **`模块`** → `CN_TOKEN_KEYWORD_MODULE`
- **`导入`** → `CN_TOKEN_KEYWORD_IMPORT`
- **`为`**（模块别名）→ `CN_TOKEN_KEYWORD_AS`
- **`命名空间`** → `CN_TOKEN_KEYWORD_NAMESPACE`

### 1.6 面向对象 / 访问控制 / 泛型（预留）

这些在语言规范 2.3.1 中被列为**预留关键字**，在解析时会报“预留特性，当前版本暂不支持”，逻辑在 [`is_reserved_keyword`/`check_reserved_keyword`](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/src/frontend/parser/parser.c#L191-L261)：

- **`类`** → `CN_TOKEN_KEYWORD_CLASS`
- **`接口`** → `CN_TOKEN_KEYWORD_INTERFACE`
- **`模板`** → `CN_TOKEN_KEYWORD_TEMPLATE`
- **`命名空间`**（上面也列过）→ `CN_TOKEN_KEYWORD_NAMESPACE`
- **`静态`** → `CN_TOKEN_KEYWORD_STATIC`
- **`公开`** → `CN_TOKEN_KEYWORD_PUBLIC`
- **`私有`** → `CN_TOKEN_KEYWORD_PRIVATE`
- **`保护`** → `CN_TOKEN_KEYWORD_PROTECTED`
- **`虚拟`** → `CN_TOKEN_KEYWORD_VIRTUAL`
- **`重写`** → `CN_TOKEN_KEYWORD_OVERRIDE`
- **`抽象`** → `CN_TOKEN_KEYWORD_ABSTRACT`

### 1.7 逻辑运算关键字（尚未真正用上的）

- **`与`** → `CN_TOKEN_KEYWORD_AND`（注释说明为“与”）
- **`或`** → `CN_TOKEN_KEYWORD_OR`

不过在 [`keyword_kind`](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/src/frontend/lexer/lexer.c#L183-L400) 里目前**没有**对“与”“或”的中文匹配，逻辑运算是通过 `&&` / `||` 这两个操作符 token 处理的。

### 1.8 系统 / 内存 / 中断相关关键字

这部分是明显“系统编程特化”的关键字，在 [`keyword_kind`](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/src/frontend/lexer/lexer.c#L366-L400) 中有完整匹配，并在解析器里生成相应 AST 节点（内存读写、映射等）：

- **`内联汇编`** → `CN_TOKEN_KEYWORD_INLINE_ASM`
- **`内存地址`** → `CN_TOKEN_KEYWORD_MEMORY_ADDRESS`
- **`映射内存`** → `CN_TOKEN_KEYWORD_MAP_MEMORY`
- **`解除映射`** → `CN_TOKEN_KEYWORD_UNMAP_MEMORY`
- **`读取内存`** → `CN_TOKEN_KEYWORD_READ_MEMORY`
- **`写入内存`** → `CN_TOKEN_KEYWORD_WRITE_MEMORY`
- **`内存复制`** → `CN_TOKEN_KEYWORD_MEMORY_COPY`
- **`内存设置`** → `CN_TOKEN_KEYWORD_MEMORY_SET`
- **`中断处理`** → `CN_TOKEN_KEYWORD_INTERRUPT_HANDLER`（用于声明中断处理函数）

---

## 2. 按规范分层：哪些是“核心”、哪些只是“预留 / 扩展”

结合语言规范文档 [`CN_Language 语言规范草案（核心子集）.md`](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/docs/specifications/CN_Language%20语言规范草案（核心子集）.md)：

### 2.1 核心子集明确列出的关键字（现在基本肯定要保留）

规范 2.3 和 0.2/0.3 明确要求的关键字有：

- **函数/返回**：`函数`、`返回`
- **入口与变量**：`主程序`、`变量`、`整数`
- **基础类型**：`小数`、`布尔`、`字符串`、`数组`、`结构体`、`枚举`、`常量`
- **模块系统**：`模块`、`导入`
- **控制流**：`如果`、`否则`、`当`、`循环`、`选择`、`情况`、`默认`、`中断`、`继续`
- **布尔字面量**：`真`、`假`

这些是语言“长相”的核心部分，删掉会严重影响语言定位，不建议当作“不必要”。

### 2.2 规范中标明为“预留关键字”（短期用不到，但有设计价值）

规范 2.3.1 的“预留关键字”：

- **面向对象**：`类`、`接口`、`虚拟`、`重写`、`抽象`
- **访问控制**：`公开`、`私有`、`保护`
- **泛型 / 命名空间**：`模板`、`命名空间`
- **其他**：`静态`

实现中已经按规范在 parser 里做了统一处理：遇到这些关键字就报“预留特性，当前版本暂不支持”的错误。

> 对“关键字太多”的感觉来说，这一组可以视为 “**为了未来保留的名字**”：  
> 不参与当前语法，短期也不会在示例里出现，但会占用单词；是否保留，要看你要不要提前锁定这些词。

### 2.3 实现中有、但规范里没怎么展开的关键字

这类关键字在核心规范中要么**完全没提**，要么只在别的设计文档（OS / Freestanding 等）里提到：

- **`与`、`或`**：`CN_TOKEN_KEYWORD_AND` / `CN_TOKEN_KEYWORD_OR`  
  - 规范 4.3 中逻辑运算是 `&&` / `||` / `!`，完全没提中文“与”“或”关键字。  
  - 词法实现里也没有对“与”“或”的匹配逻辑，目前其实根本不会被识别出来。
- **`从`**：在 lexer 里把 `从` 当作 `for` 的别名（映射到 `CN_TOKEN_KEYWORD_FOR`），规范里没有这一关键字。
- **`为空`相关：`空` / `无`**（`CN_TOKEN_KEYWORD_VOID` / `CN_TOKEN_KEYWORD_NULL`）  
  - 规范只在类型系统和指针部分用文字说明“指针”“空指针”等概念，暂时没有正式列为关键字清单，但系统语言通常都需要一个 void 和 null 概念。

- **系统 / 内存 / 中断关键字**：  
  - `内联汇编`、`内存地址`、`映射内存`、`解除映射`、`读取内存`、`写入内存`、`内存复制`、`内存设置`、`中断处理`  
  - 这些属于“非常具体的系统调用/内存操作”，更像是**运行时 API 或 intrinsic**，而不是通用语言关键字。  
  - 在 parser 里已经有对应的 AST 构造函数，但在核心规范里完全没有提。（更偏向阶段 5 OS / Freestanding 的设计。）

---

## 3. 哪些关键字可以认为“现在不必要 / 优先裁剪”

基于上面分析，我按“**对当前核心子集 & 普通用户心智的必要性**”给一个分级建议：

### 3.1 强烈建议从关键字层面移除或降级为库函数的（系统特化组）

这组最容易让语言显得“关键字爆炸”，而且语义非常具体：

- **`内联汇编`**
- **`内存地址`**
- **`映射内存`**
- **`解除映射`**
- **`读取内存`**
- **`写入内存`**
- **`内存复制`**
- **`内存设置`**
- **`中断处理`**

**理由：**

- 这些操作更适合做成**标准库函数 / intrinsic**，而不是一等关键字。  
- 保留关键字会：
  - 占用大量中文词汇；
  - 拉高初学者的心智负担；
  - 让核心规范变得像“OS 专用语言”，而不是通用系统语言。
- 就算你未来要支持这些能力，用函数形式（比如 `内存_映射(...)`）+ 编译器内置，也比关键字更灵活。

**结论：**  
如果你要精简关键字集合，这一组是**最优先可以删掉/降级**的候选。

---

### 3.2 当前并未真正用上的语法糖 / 备用方案（可以删、也可以先不公开）

- **`与` (`CN_TOKEN_KEYWORD_AND`) / `或` (`CN_TOKEN_KEYWORD_OR`)**

  - 现在语义上的逻辑与/或都通过 `&&` 和 `||` 运算符处理，不依赖这两个关键字。
  - 词法函数中没有对“与”“或”进行 UTF-8 比对，实际上不会被识别出来。
  - **如果不打算支持“中文逻辑运算符”语法，这两个完全可以删掉。**

- **`从` → `CN_TOKEN_KEYWORD_FOR`（for 的中文别名）**

  - 规范中循环关键字是 `当`（while 类）和 `循环`（for 类），没有“从”。  
  - `从` 更像是“`从 … 到 …`” 的语法糖构想，当前语法并不依赖它。  
  - **为了保持关键字集合小而干净，建议要么完整设计 `从…到…` 语法，要么就先把 `从` 当普通标识符，不当关键字。**

- **`为` (`CN_TOKEN_KEYWORD_AS`)**

  - 只用于模块别名：类似 `导入 模块 为 别名`。  
  - 在规范 2.3/2.3.1 的关键字列表里没有“为”，只在“模块别名”描述里可能会出现这个语法设计。  
  - 如果你不急于稳定模块语法，可以把 `为` 暂时当普通标识符，将来再决定是关键字还是内置函数/语法。

**结论：**  
这三个（`与`、`或`、`从`、`为`）都是**非核心、当前语法不依赖**的关键字，  
如果你希望“第一版语言关键字尽量少”，完全可以从关键字表里先拿掉。

---

### 3.3 长期特性预留关键字（保留价值高，但对“现在的你”来说确实不必要）

规范 2.3.1 中的预留关键字：

- **类、接口、模板、命名空间、静态、公开、私有、保护、虚拟、重写、抽象**

**从项目规范角度：**

- 这些词是**刻意预留**出来的，目的是以后做 OOP、访问控制、泛型、命名空间。  
- 现在 parser 遇到它们就报“预留特性，当前版本暂不支持”，并不会影响现有代码。

**从“关键字太多”的感觉来看：**

- 如果你只看“当前可用语言能力”，这组关键字当然是“不必要的多余噪音”；  
- 但从 “长期演进 + 版本兼容” 角度，提前占坑是有价值的——你以后可以直接实现，而不用担心与用户已有标识符冲突。

**折中建议：**

- 文档层面继续把它们标为“预留关键字”；  
- 工具（IDE/高亮/补全）可以**默认不把它们展示为“推荐关键字”**，只在“高级模式/未来特性”里露面。  
- 如果你真想缩表，也可以考虑把它们暂时降级（恢复成普通标识符），但这会牵涉到规范改动。

---

### 3.4 基础但尚未完全规范化的关键字（不算“多余”，只是文档有点落后）

- **`空` (`CN_TOKEN_KEYWORD_VOID`)、`无` (`CN_TOKEN_KEYWORD_NULL`)**

这两个属于非常常见的系统语言概念（void / null），  
对以后做指针、无返回值函数、空指针等都很重要。

**建议：**

- 不要当作“可以删的多余关键字”；  
- 更合理的做法是：在语言规范里补上它们的正式定义（void 类型、null 字面量），让设计更完整。

---

## 4. 小结（给你一个“可以先砍掉哪几类”的清单）

- **现在真正“必需、已经写进规范核心子集”的关键字**：  
  `函数、返回、主程序、变量、整数、小数、布尔、字符串、数组、结构体、枚举、常量、模块、导入、如果、否则、当、循环、选择、情况、默认、中断、继续、真、假`（以及为指针/空值预留的 `空、无`）。
- **如果你觉得关键字太多，当前阶段最适合“精简/移除”的是：**
  - **系统/内存/中断关键字**：`内联汇编、内存地址、映射内存、解除映射、读取内存、写入内存、内存复制、内存设置、中断处理`（建议改成库函数或 intrinsic，而不是关键字）。  
  - **未真正投入使用的语法糖/备用方案**：`与、或、从、为`。  
- **预留关键字（类、接口、模板、命名空间、静态、公开、私有、保护、虚拟、重写、抽象）**：  
  - 短期确实“不必要”，但出于长期兼容考虑，有保留的价值；  
  - 可以通过“文档标成预留 + 工具不高亮/不补全”来降低存在感，而不是立刻删除。

如果你愿意，我可以下一步帮你：  
1）给出“精简关键字版本”的正式列表；  
2）列出需要修改的几个核心文件（token.h / lexer.c / parser.c / 规范文档中的对应章节），按阶段一步步缩减实现。