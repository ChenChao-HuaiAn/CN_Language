### 阶段 2：语义分析与基础类型系统 TODO 列表

#### 一、符号表与作用域

- **TODO：设计符号表与作用域数据结构（头文件设计）**
  - 在 `include/cnlang/frontend/` 新增或扩展一个头文件（例如 `semantics.h`，名字你可以再定），声明：
    - 符号（变量、函数等）的结构体类型（如 `CnSymbol`）。
    - 符号表节点（作用域）的结构体类型（如 `CnScope`）。
    - 作用域类型枚举（全局 / 函数 / 块作用域）。
    - 对外 API：创建/销毁作用域、插入符号、查找符号（支持向上查找父作用域）。
  - 注意接口使用统一前缀（如 `cn_sem_`），遵守 `code_style_guide.md`。

- **TODO：在 `src/frontend/` 下创建 semantics 模块实现**
  - 新建目录：`src/frontend/semantics/`（如果还没有）。
  - 在其中添加实现文件（例如 `semantics.c`）：
    - 实现符号表和作用域的增删查 API。
    - 控制嵌套作用域（进入/离开块、函数、全局）。
  - 控制单个 `.c` 文件大小和函数长度（< 500 行和 < 50 行）——必要时拆成多个 `.c`。

- **TODO：在 AST 遍历中集成作用域构建**
  - 在现有 `parser` 生成的 AST 基础上：
    - 设计一套遍历 AST 的“语义分析入口函数”，例如 `cn_sem_analyze_program(ASTNode *root, CnDiagnostics *diag)`。
    - 遍历时：
      - 进入函数定义节点时创建新的函数作用域。
      - 进入块语句（如 `{ ... }`）时创建新的块作用域。
      - 离开时销毁作用域。
      - 对变量、函数声明节点，向当前作用域插入符号（检查是否重复定义，留给后面的“语义检查” TODO）。

---

#### 二、类型系统

- [x] **TODO：定义基础类型集合（类型描述结构）**
  - 在语义相关头文件中定义：
    - 基础类型枚举（如 `int`、`bool`、`pointer` 等）。
    - 类型结构，如 `CnType`：包含种类、指针指向的元素类型等。
  - 约定 AST 中哪些节点需要挂类型信息（如表达式节点）。

- [x] **TODO：为 AST 节点扩展“类型信息”字段**
  - 在 [ast.h] 中：
    - 给表达式类节点增加类型字段（例如 `CnType *type;`，具体命名按你的风格）。
  - 在语义分析遍历里：
    - 对字面量、变量引用、二元运算等节点推断并填充类型字段。
    - 实现基本类型等价/兼容检查函数（如 `cn_type_equals` / `cn_type_compatible`）。

- [x] **TODO：实现简单类型推断规则**
  - 对二元运算（算术、比较、逻辑）：
    - 左右两侧类型必须兼容。
    - 决定结果类型（如比较运算 -> `bool`）。
  - 对指针相关操作：
    - 实现指针类型构造（如 `int*`）。
    - 基本合法性检查（简单规则即可，后续可以扩展）。

---

#### 三、语义检查

- **TODO：实现名称解析与重复/未定义检查**
  - 在语义遍历过程中：
    - 处理声明：插入符号前先在当前作用域查重，如果存在则报“重复定义”错误。
    - 处理标识符使用（变量、函数调用）：
      - 从当前作用域向外查找符号；找不到则报“未定义标识符”错误。
  - 与 diagnostics 模块集成（见下文“错误报告” TODO）。

- **TODO：函数调用形参与实参检查**
  - 在语义阶段：
    - 函数声明符号中保存参数列表类型信息。
    - 函数调用节点：
      - 检查参数个数是否匹配。
      - 逐个检查参数类型与形参类型兼容。

- **TODO：控制流基本检查（必需返回等）**
  - 对有返回类型（非 `void`）的函数：
    - 分析函数体，检查所有可能路径是否都有返回语句（可以先做简单版本：遍历函数体里是否存在返回表达式；后续再做更严谨的控制流分析）。
  - 对 `break`、`continue` 的使用：
    - 出现在非循环语句中时，报语义错误（如还未做，可放在稍后阶段同步实现）。

---

#### 四、错误报告与 diagnostics 集成

- **TODO：在 diagnostics 模块中定义语义错误专用接口/枚举**
  - 在 `include/cnlang/support/diagnostics.h` 中扩展：
    - 增加语义错误种类枚举值（如“重复定义”“未定义标识符”“类型不匹配”“缺少返回”等）。
    - 声明一组面向语义分析的报错函数（如 `cn_diag_semantic_error_*`），不在实现里直接 `printf`。
  - 在 `src/support/diagnostics/diagnostics.c` 中实现这些接口。

- **TODO：在语义分析中通过 diagnostics 上报错误**
  - 所有语义错误：
    - 都通过 diagnostics 接口输出。
    - 尽量在遇到错误后继续分析后续节点（而不是直接终止），以收集更多错误。

---

#### 五、测试与验收（对应里程碑）

- **TODO：搭建 `tests/unit/semantics/` 基础结构**
  - 新建目录：`tests/unit/semantics/`。
  - 在 `tests/unit/CMakeLists.txt` 中添加相应的单元测试目标。
  - 建立若干基础单元测试文件（例如 `semantics_symbol_table_test.c`、`semantics_type_system_test.c`、`semantics_name_resolution_test.c` 等）。

- **TODO：为符号表、类型系统编写单元测试**
  - 符号表与作用域：
    - 测试嵌套作用域插入与查找。
    - 测试重复定义检测。
  - 类型系统：
    - 测试基本类型等价/兼容函数。
    - 测试简单表达式类型推断（如整型加法、比较、逻辑运算）。

- **TODO：新增语义错误集成测试**
  - 在 `tests/integration/` 下增加与语义错误相关的 `.cn` 示例（可以复用 `examples` 里的或新增）。
  - 为典型语义错误编写集成测试：
    - 未定义变量 / 函数。
    - 函数参数个数或类型不匹配。
    - 必须返回但未返回。
  - 确认运行 `ctest` 时能看到清晰的错误信息输出。

- **TODO：验证“从源代码到带类型信息的 AST”**
  - 选取一个简单程序（如 `hello_world` + 几个变量声明和简单表达式）：
    - 在集成测试中运行完整前端（词法 + 语法 + 语义）。
    - 检查 AST 节点上是否已经挂好类型信息（可以用调试输出或专门的检查函数）。
