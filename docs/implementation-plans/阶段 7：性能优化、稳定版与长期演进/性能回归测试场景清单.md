# CN_Language 性能回归测试场景清单

> 本文档定义纳入长期回归测试集的性能测试场景，确保后续变更不会导致性能劣化。
> 创建日期：2026-01-24
> 最后更新：2026-01-24

## 1. 已实施的性能回归场景

### 1.1 Arena 分配器性能（P0）

**测试文件**: `tests/unit/arena_stress_test.c`

**场景描述**: 验证 Arena 内存分配器的性能优势与稳定性

**关键指标**:
- Arena 分配速度：< 1 μs/次
- Arena vs malloc 加速比：> 2x（典型场景）
- Arena reset 耗时：< 10 μs/次
- 连续分配 10,000 次小对象不崩溃

**测试覆盖**:
- [x] 小对象分配性能（16 字节）
- [x] 中等对象分配性能（256 字节）
- [x] 大对象分配性能（1 MB）
- [x] 与标准 malloc 对比基准
- [x] Arena reset 操作性能

**执行命令**:
```bash
cd build
ctest -R arena_stress_test -V
```

**维护规则**:
- 任何修改 Arena 分配器的 PR 必须运行此测试
- 性能劣化 > 5% 需在 PR 中说明原因
- 基准值更新需修改测试文件中的阈值常量

---

### 1.2 词法分析器性能（P0）

**测试文件**: `tests/unit/lexer_performance_test.c`

**场景描述**: 验证词法分析器在典型与大规模源文件上的吞吐量

**关键指标**:
- 吞吐量：≥ 500 tokens/ms
- 单次 `next_token` 调用：< 5 μs
- 大文件解析：10,000 tokens < 20 ms

**测试覆盖**:
- [x] 基础 token 序列解析性能
- [x] 混合 token 类型（关键字、标识符、字面量、运算符）
- [x] UTF-8 中文标识符性能
- [x] 大文件场景（模拟 10,000 tokens）

**执行命令**:
```bash
cd build
ctest -R lexer_performance_test -V
```

**维护规则**:
- 修改词法分析器实现时必须运行此测试
- 吞吐量下降 > 10% 需在 PR 中说明原因
- 优化后应更新基准值并记录在测试输出中

---

### 1.3 内存泄漏检测性能（P0）

**测试文件**: `tests/unit/memory_leak_test.c`

**场景描述**: 验证内存分析工具的准确性与性能开销

**关键指标**:
- 泄漏检测准确率：100%（无假阳性/假阴性）
- 分类统计正确性：100%
- 峰值内存追踪误差：< 1%

**测试覆盖**:
- [x] 基本泄漏检测（分配未释放）
- [x] 内存分类统计（AST、符号表等）
- [x] 峰值内存追踪
- [x] 过度释放保护

**执行命令**:
```bash
cd build
ctest -R memory_leak_test -V
```

**维护规则**:
- 修改内存管理模块时必须运行此测试
- 准确率必须保持 100%，任何降低均不允许合并

---

### 1.4 关键路径功能回归（P0）

**测试文件**: `tests/unit/regression_test.c`

**场景描述**: 验证性能优化后，核心功能不退化

**关键指标**:
- 所有测试用例通过率：100%

**测试覆盖**:
- [x] 词法分析器基本功能
- [x] Arena 分配器功能
- [x] 诊断系统功能
- [x] 内存统计功能
- [x] UTF-8 处理功能
- [x] 多 token 序列处理

**执行命令**:
```bash
cd build
ctest -R regression_test -V
```

**维护规则**:
- 每次性能优化后必须运行此测试
- 任何功能回归（测试失败）必须先修复再合并

---

## 2. 待补充的性能回归场景

### 2.1 语法分析器性能（P1）

**优先级**: P1（高）
**计划时间**: 阶段 7.7（后续迭代）

**场景描述**: 验证语法分析器在大型源文件上的性能

**目标指标**（待验证）:
- 解析 1,000 行代码：< 50 ms
- 解析 10,000 行代码：< 500 ms
- 内存占用峰值：< 10 MB（1,000 行代码）

**测试覆盖计划**:
- [ ] 基础语法结构解析（函数、控制流、变量声明）
- [ ] 深度嵌套结构（20 层）
- [ ] 大量函数定义（100+ 函数）
- [ ] 大量变量声明（1,000+ 变量）

**实施步骤**:
1. 创建 `tests/unit/parser_performance_test.c`
2. 生成大规模测试源文件（1,000/10,000 行）
3. 定义基准阈值
4. 添加到 CMakeLists.txt，标记为 `stage7;performance;unit`

---

### 2.2 语义分析性能（P1）

**优先级**: P1（高）
**计划时间**: 阶段 7.7（后续迭代）

**场景描述**: 验证类型检查与符号解析的性能

**目标指标**（待验证）:
- 符号表查找：< 1 μs/次（100 符号以内）
- 类型检查：< 10 μs/节点
- 大型符号表（1,000 符号）查找性能不劣化

**测试覆盖计划**:
- [ ] 符号表查找性能（不同大小）
- [ ] 类型推导复杂场景（嵌套表达式）
- [ ] 作用域嵌套性能（10 层嵌套）

**实施步骤**:
1. 创建 `tests/unit/semantic_performance_test.c`
2. 生成不同规模符号表测试场景
3. 定义基准阈值
4. 添加到 CMakeLists.txt

---

### 2.3 IR 生成与优化性能（P1）

**优先级**: P1（高）
**计划时间**: 阶段 7.7（后续迭代）

**场景描述**: 验证 IR 生成与优化 Pass 的性能

**目标指标**（待验证）:
- IR 生成：< 100 μs/AST 节点（平均）
- 常量折叠 Pass：< 50 ms（1,000 节点）
- 死代码消除 Pass：< 100 ms（1,000 节点）

**测试覆盖计划**:
- [ ] 基础 IR 生成性能
- [ ] 常量折叠 Pass 性能（大量常量表达式）
- [ ] 死代码消除 Pass 性能（大量冗余代码）
- [ ] 多 Pass 串联执行时间

**实施步骤**:
1. 创建 `tests/unit/ir_performance_test.c`
2. 生成大规模 IR 测试场景
3. 定义基准阈值
4. 添加到 CMakeLists.txt

---

### 2.4 端到端编译性能（P0）

**优先级**: P0（关键）
**计划时间**: 阶段 7.7（后续迭代）

**场景描述**: 验证完整编译流程在大型项目上的性能

**目标指标**（待验证）:
- 编译 500 行代码项目：< 100 ms
- 编译 1,000 行代码项目：< 300 ms
- 编译 10,000 行代码项目：< 3,000 ms
- 多文件项目（10 文件）：< 500 ms

**测试覆盖计划**:
- [ ] 单文件大型项目编译（500/1,000/10,000 行）
- [ ] 多文件项目编译（10/50/100 文件）
- [ ] 典型应用场景（含运行时库链接）
- [ ] Freestanding 模式编译（内核场景）

**实施步骤**:
1. 创建 `tests/integration/compiler/integration_large_project_test.c`
2. 准备不同规模的测试项目（自动生成或实际示例）
3. 定义基准阈值
4. 添加到 CMakeLists.txt，标记为 `stage7;performance;integration`

---

### 2.5 代码生成性能（P2）

**优先级**: P2（中）
**计划时间**: 阶段 7.8（后续迭代）

**场景描述**: 验证 C 代码生成器的性能

**目标指标**（待验证）:
- C 代码生成：< 50 μs/IR 节点
- 大型 IR（10,000 节点）生成时间：< 500 ms

**测试覆盖计划**:
- [ ] 基础 C 代码生成性能
- [ ] 复杂表达式生成性能
- [ ] 大量函数生成性能

**实施步骤**:
1. 创建 `tests/unit/cgen_performance_test.c`
2. 准备测试 IR
3. 定义基准阈值

---

## 3. 性能回归测试执行策略

### 3.1 本地开发

开发者在修改性能相关代码后，应手动运行对应测试：

```bash
cd build

# 运行所有性能测试
ctest -L performance -V

# 运行特定模块性能测试
ctest -R lexer_performance_test -V
ctest -R arena_stress_test -V
```

### 3.2 持续集成（CI）

**PR 构建阶段**:
- 自动运行所有标记为 `stage7;performance` 的测试
- 性能劣化 > 10% 时，CI 任务失败并提示
- PR 描述中必须说明性能变化原因

**夜间构建**:
- 运行完整性能测试套件（包括大规模场景）
- 生成性能趋势报告（对比历史数据）
- 发现异常时通过邮件/通知告警

### 3.3 版本发布前

在正式版本发布前，必须：
1. 运行所有性能回归测试（包括待补充场景）
2. 对比上一版本的性能基准
3. 在发布说明中披露性能变化（改进或劣化）

---

## 4. 性能基准更新流程

### 4.1 何时更新基准

以下情况需要更新性能基准值：
1. 实施了明确的性能优化，预期提升 > 10%
2. 架构调整导致性能特征变化（经过评审确认合理）
3. 测试环境/工具链升级导致基准漂移

### 4.2 更新步骤

1. **运行基准测试**（至少 10 次，取中位数）
2. **提交 PR**，包含：
   - 测试文件中的基准常量更新
   - Commit message 说明：
     - 旧基准值 → 新基准值
     - 性能变化百分比
     - 原因（优化/架构调整/环境变化）
3. **更新文档**：
   - 本文档中的"关键指标"
   - `长期回归测试集规范.md` 中的性能基准表格

### 4.3 示例 Commit Message

```
perf: 更新 Arena 分配器性能基准

旧基准：< 2 μs/次
新基准：< 1 μs/次
提升：50%

原因：优化了 Arena 块分配策略，减少内存对齐开销
影响测试：arena_stress_test.c
```

---

## 5. 性能劣化应对流程

### 5.1 检测到劣化时

当 CI 或本地测试检测到性能劣化时：

1. **定位原因**：
   - 使用 `cnperf` 工具分析（若已实施）
   - 使用 profiler（gprof/perf）定位热点变化
   - 对比变更前后的关键路径

2. **评估影响**：
   - 劣化幅度：< 5%（可接受）/ 5%-10%（需评审）/ > 10%（需修复）
   - 影响范围：全局 / 特定场景

3. **决策**：
   - **可接受**：在 PR 描述中说明原因（如为正确性牺牲性能）
   - **需修复**：修复性能问题后再合并
   - **需权衡**：在设计评审中讨论并记录决策依据

### 5.2 历史劣化追踪

若发现性能逐步劣化（跨多个 PR），应：
1. 在项目 Issue 中创建性能专项任务
2. 使用 git bisect 定位首次劣化的 commit
3. 制定优化计划并排入后续迭代

---

## 6. 附录：性能测试环境规范

### 6.1 标准测试环境

为确保性能基准可复现，定义标准测试环境：

**硬件**:
- CPU：4 核心（或更高）
- 内存：8 GB（或更高）
- 磁盘：SSD

**软件**:
- 操作系统：Windows 10/11 或 Linux（Ubuntu 20.04+）
- 编译器：MSVC 2019+/GCC 10+/Clang 12+
- 构建类型：Release（带优化）

**环境变量**:
```bash
# CMake 构建时使用 Release 配置
cmake -DCMAKE_BUILD_TYPE=Release ..
```

### 6.2 性能测试注意事项

1. **关闭后台任务**：运行性能测试前，关闭不必要的后台程序
2. **多次运行取中位数**：性能测试至少运行 5 次，取中位数作为结果
3. **避免虚拟机**：若使用虚拟机，结果仅作参考，基准应在物理机上确定
4. **温度控制**：避免 CPU 过热降频影响结果

---

**本清单持续更新**，新增性能回归场景、基准调整、测试结果异常等信息均应记录于此。
