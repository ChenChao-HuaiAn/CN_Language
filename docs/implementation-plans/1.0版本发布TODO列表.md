## CN_Language 1.0 发布 TODO 列表

> 本文档汇总 CN_Language 编译器与工具链达到 **1.0.0 首个稳定版本** 所需的主要任务与验收标准。
> 参考：`CN_Language 开发计划.md`、`CN_Language 版本号规范.md`，以及各阶段 TODO 列表。

---

### 一、整体里程碑与版本策略
- [ ] **阶段范围**：完成开发计划中 **阶段 1–7 的“核心目标”**，阶段 8 至少完成“核心语法扩展”的最小子集（指针、结构体、枚举、预处理器等）。
- [ ] **版本区间**：从当前 `0.y.z` 版本迭代到 `0.9.z`，稳定后发布 `1.0.0`（参见版本号规范第 5 章）。
- [ ] **稳定性要求**：1.0 之后对语言与公共 API 提供源兼容性承诺（参见版本号规范第 6 章）。
- [ ] **预发布流程**：至少经历 `1.0.0-beta.N` 与 `1.0.0-rc.N` 阶段，分别用于公开测试与发布候选验证。
- [ ] **直接二进制后端目标**：在至少一个主力平台上，CN 编译器可在 **无需外部 C 编译器** 的情况下，直接生成可执行程序或可链接的目标文件。

---

### 二、语言前端（词法 / 语法）
- [ ] **核心语法子集稳定**：
  - [ ] 关键字、运算符、表达式与语句形式在规范文档中冻结。
  - [ ] 语法错误信息统一、可定位，具备基本错误恢复能力。
- [ ] **核心语法扩展（阶段 8 最小集）**：
  - [ ] 指针类型与指针运算（解引用、取地址、指针算术）。
  - [ ] 结构体与枚举类型（含初始化与访问）。
  - [ ] 函数指针与回调调用。
  - [ ] 预处理器：宏定义、条件编译、包含机制的最小可用子集。
- [ ] **前端测试完备**：
  - [ ] `tests/unit/frontend/` 覆盖 Token、表达式、语句、声明等主要语法规则。
  - [ ] `tests/integration/compiler/` 中有“解析成功/失败”场景，覆盖常见与边界用例。

---

### 三、语义分析与类型系统
- [ ] **符号表与作用域模型稳定**：
  - [ ] 支持全局/函数/块级作用域，模块系统（已在阶段 7 完成）与符号表良好集成。
  - [ ] 能检测未定义标识符、重复定义、可见性冲突等问题。
- [ ] **基础类型系统完备**：
  - [ ] 支持整型、布尔、指针、结构体、枚举等核心类型。
  - [ ] 函数类型与函数指针类型检查规则稳定。
  - [ ] 类型转换（隐式 / 显式）规则清晰，文档化且有测试覆盖。
- [ ] **语义错误诊断统一**：
  - [ ] 所有语义错误通过 diagnostics 模块输出，包含源位置与简明描述。
  - [ ] 常见语义错误（如参数不匹配、缺少返回、非法类型操作）都有专门测试用例。

---

### 四、中间表示（IR）与后端（C 后端 + 直接二进制后端）
- [ ] **IR 设计冻结**：
  - [ ] IR 指令集、基本块结构在文档中描述清晰，并与实现一致。
  - [ ] AST → IR 的映射规则稳定，兼顾 C 后端与直接二进制后端的需求，可支持后续优化与新特性扩展。
- [ ] **AST → IR 转换完备**：
  - [ ] 覆盖表达式、控制流（if/while/for/switch 等）、函数、模块等核心构造。
  - [ ] 支持指针、结构体、枚举相关操作的 IR 生成。
- [ ] **IR → C 后端成熟可用**：
  - [ ] 能稳定生成合法、可读性较好的 C 代码。
  - [ ] 约定的 C 层 ABI（函数命名、类型映射）固定，并在文档中说明。
- [ ] **IR → 直接二进制后端（机器码 / 目标文件生成）**：
  - [ ] 至少支持一个主力目标平台（如 `x86_64-pc-windows-gnu` 或 `x86_64-unknown-linux-gnu`）的代码生成。
  - [ ] 实现基础指令选择与寄存器分配（可为简化实现，但行为正确且稳定）。
  - [ ] 支持函数前序 / 后序（prologue/epilogue）、调用约定和栈帧布局。
  - [ ] 能生成可由系统链接器（如 `link.exe` / `ld` / `lld`）消费的目标文件（`.obj` / `.o`），或直接输出可执行文件。
- [ ] **端到端编译链路（双路径）**：
  - [ ] 路径一：`.cn` → C 后端 → 宿主 C 编译器 → 可执行文件，作为兼容与对照路径保留。
  - [ ] 路径二：`.cn` → 直接二进制后端 → 目标文件 / 可执行文件 → （可选）链接器 → 可执行文件或 OS 镜像。
  - [ ] `tests/integration/compiler/` 中为两种后端分别提供端到端测试，并至少在一个平台上验证二者语义一致性（输出结果相同）。

---

### 五、运行时与基础标准库
- [ ] **最小运行时稳定**：
  - [ ] 进程入口、全局初始化、程序退出流程清晰且可复用。
  - [ ] 运行时初始化失败路径有明确错误处理与诊断。
- [ ] **基础标准库完备**：
  - [ ] 字符串、基础 I/O、数学函数等常用能力可用，并有文档与示例。
  - [ ] 标准库接口在 `cnrt.h` 等头文件中稳定暴露，遵循版本兼容政策。
- [ ] **运行时测试**：
  - [ ] `tests/unit/runtime/` 中覆盖核心运行时函数的正常路径与错误路径。
  - [ ] 集成测试中包含依赖运行时/标准库的典型示例程序，并在两种后端下均通过。

---

### 六、OS / freestanding 支持（建议包含直接二进制路径的最小集）
- [ ] **目标三元组与平台建模**：
  - [ ] 至少有一个 freestanding 目标（如 `x86_64-elf`）配置完整。
  - [ ] 编译选项与链接脚本模板整理完毕，并有文档说明。
- [ ] **freestanding 运行时子集**：
  - [ ] 提供不依赖宿主 OS 的最小运行时实现（栈、基本内存分配或替代机制）。
  - [ ] 明确在 freestanding 模式下禁止/限制的语言特性与标准库接口。
- [ ] **OS 示例与测试**：
  - [ ] 至少有一个“用 CN_Language 编写的极简内核”示例，能在 QEMU 等模拟器中启动并输出信息。
  - [ ] `tests/integration/os/` 中有自动化脚本验证镜像能启动且输出符合预期（如特定字符串）。
  - [ ] 对于直接二进制后端，验证在无需外部 C 编译器的前提下也能生成并启动该内核镜像。

---

### 七、工具链与开发体验
- [ ] **cnc 编译器**：
  - [ ] 支持核心命令行选项（输入、输出、目标、优化级别、freestanding 开关等）。
  - [ ] 支持选择后端（如 `--backend=c` / `--backend=native`），并在 1.0 中推荐或默认使用直接二进制后端。
  - [ ] 帮助信息、错误码、退出码语义稳定并文档化，明确两种后端在行为和限制上的差异。
- [ ] **cnrepl / 交互式工具（如果纳入 1.0 范围）**：
  - [ ] 支持输入表达式、查看结果、简单历史记录。
  - [ ] 能复用编译管线的前端与运行时逻辑，而非单独实现。
- [ ] **cnfmt / cncheck 等工具**：
  - [ ] `cnfmt` 能对示例与测试代码进行稳定格式化（一致且幂等）。
  - [ ] `cncheck` 能检出基本风格问题与简单潜在缺陷（未使用变量等）。
- [ ] **编辑器 / LSP 支持（最小实现）**：
  - [ ] LSP 语言服务至少提供语法高亮、基础诊断转发能力。
  - [ ] VSCode 插件或简单集成脚本可用，支持在主力平台上开发。

---

### 八、测试体系与质量保障
- [ ] **测试覆盖与分类**：
  - [ ] `tests/unit/`、`tests/integration/`、`tests/system/` 结构完整，命名规范统一（参见测试规范）。
  - [ ] 对核心路径（解析、语义、IR、后端、运行时）达到约定的代码覆盖率目标。
- [ ] **回归测试与基准集**：
  - [ ] 针对历史 Bug 建立回归测试集合，所有已修复问题均有对应用例。
  - [ ] 构建一套代表性“样例项目”作为长期回归与性能基准，在两种后端下都需通过。
- [ ] **多平台验证**：
  - [ ] 至少在 Windows 与一类类 Unix 平台（如 Linux）上完成构建与测试。
  - [ ] 针对平台差异（如路径、编码、行结束符）有专门测试覆盖或文档说明。
  - [ ] 验证直接二进制后端在至少一个主力平台上可稳定生成并运行可执行文件。

---

### 九、文档与示例
- [ ] **规范文档完备且同步**：
  - [ ] `docs/specifications/` 下的语言规范、运行时绑定规范、C 代码风格规范、测试规范、版本号规范等与当前实现完全一致。
  - [ ] 每次影响外部行为的变更在发布前都已反映到规范文档中，特别是关于直接二进制后端、调用约定和目标平台支持范围的说明。
- [ ] **开发计划与架构文档更新**：
  - [ ] `CN_Language 开发计划.md` 中的阶段状态与实际实现一致，并标注 1.0 相关里程碑已完成。
  - [ ] 编译器架构、运行时架构、工具链架构文档更新到 1.0 状态，包含“C 后端 + 直接二进制后端”的整体架构。
- [ ] **示例程序**:
  - [ ] `examples/` 中包含从“Hello, world”到中等规模模块化程序、并发示例、OS 场景等多层次示例。
  - [ ] 每个示例可在 README 或注释中说明用途、依赖特性与预期输出，并指明是否在两种后端下均通过验证。

---

### 十、发布流程与版本管理
- [ ] **版本号与构建信息统一维护**：
  - [ ] 在顶层 `CMakeLists.txt` 与 `include/cnlang/support/version.h` 中维护统一版本号，包含 `1.0.0` 正式标记。
  - [ ] 在 Git 中创建 `v1.0.0` 署名标签，附带简要说明。
- [ ] **CHANGELOG 与发布说明**：
  - [ ] 维护 `CHANGELOG.md`，按语义化版本规范记录 1.0 的“Added / Changed / Fixed / Removed”。
  - [ ] 为 1.0 撰写简明发布说明，突出稳定性、特性范围（包括直接二进制后端）、已知限制和推荐使用场景。
- [ ] **发布工件与分发方式**：
  - [ ] 定义并实现构建发布包的流程（如压缩包、容器镜像、包管理器配方等）。
  - [ ] 在至少一个公开渠道（如 GitHub Releases）发布可下载的 1.0 二进制或源码包，并说明直接二进制后端支持的具体平台与依赖条件。

---

### 十一、已知限制与后续规划
- [ ] **1.0 已知限制列表**：
  - [ ] 明确列出在 1.0 中刻意不解决或尚未完成的特性（如高级泛型、宏系统高级用法、更高级的优化与多目标后端等）。
  - [ ] 对每个限制给出预计解决阶段或版本范围（如“1.x 增量优化”或“2.x 规划”）。
- [ ] **长期演进路线**：
  - [ ] 在开发计划中补充 1.x / 2.x 的演进方向（性能、生态、语法扩展、多后端支持等）。
  - [ ] 将阶段 8 及以后的高级特性划入 1.x+ 或 2.x 的规划，而非强行纳入 1.0，同时预留直接二进制后端在更多平台上的扩展空间。
