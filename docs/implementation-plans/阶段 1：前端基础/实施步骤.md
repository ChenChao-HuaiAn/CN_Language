
### 总体结论

**按照“实现最小可用的词法分析器和语法分析器.md”里的 A–F 小节，对照当前代码/文档/测试，核心前端已经大体成形，但至少有这几块明显缺口：**

- **诊断模块及与 Lexer/Parser 的对接（B4、D 全部、C2/C3 的诊断部分）完全没上。**
- **Parser 对“整数 声明”和“字符串字面量表达式”的支持不完整，导致规范里的 v0 子集和 `examples/hello_world.cn` 实际上还解析不了。**
- **单元测试侧：目前有不少 Parser 测试，但缺少按规范要求的“非法字符 / 错误语法”的测试，也没有针对 `hello_world` 的最小子集“回归测试”。**
- **集成测试 F（`tests/integration`）目前完全是占位，没有任何实现。**

下面我按文档的小节（A–F）逐项列状态，然后给出一个**可执行的 TODO 顺序**，你可以直接按这个顺序推进；如果你愿意，我也可以按这个顺序开始改代码。

---

### A. 最小语言子集定义（文档侧）

- **A1 定义最小语言子集功能点**  
  - **状态**：已实现。  
  - **依据**：`docs/specifications/language_spec_draft.md` 里的 **0. 最小可编译子集（v0）** 明确列出了变量声明、整型表达式、函数、入口函数 `主程序`、内建 `打印` 等，对应 A1 的要求。
  - **差异点**：无明显缺口。

- **A2 在语言规范文档中写出子集**  
  - **状态**：已实现。  
  - **依据**：  
    - EBNF 形式的语法定义已经在 [language_spec_draft.md](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/docs/specifications/language_spec_draft.md) 的 0.4 里给出。  
    - 0.2 给出 v0 关键字列表。  
    - 0.5 给出 `函数 主程序() { 打印("你好，世界！"); 返回 0; }` 的完整示例，对应 `examples/hello_world.cn`。
  - **差异点**：文档已 OK，后端实现部分没完全跟上（在 C 小节会提）。

---

### B. 词法分析器（Lexer）

- **B1 设计 Token 集合**  
  - **状态**：已实现。  
  - **依据**：
    - Token 枚举在 [token.h](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/include/cnlang/frontend/token.h) 中完整列出：标识符、整数、字符串字面量、所有运算符、括号、分号、逗号、EOF 等。
    - 中文关键字映射在 [lexer.c](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/src/frontend/lexer/lexer.c) 的 `keyword_kind` 中实现，包含：`函数`、`返回`、`变量`、`整数`、`小数`、`布尔`、`字符串`、`数组`、`结构体`、`模块`、`导入`、`主程序`、`真/假` 等。
    - 标识符规则允许中文（`c >= 0x80` 视为可用于标识符），符合规范 2.2。
  - **差异点**：B1 要求的“标明哪些是中文关键字、哪些是普通标识符”已经通过 `keyword_kind`+`CN_TOKEN_IDENT` 的区分实现。

- **B2 设计词法模块结构**  
  - **状态**：基本实现，**可选项未实现**。  
  - **依据**：
    - `token.h` / `token.c`：Token 类型定义和打印函数，已存在。  
    - `lexer.h` / `lexer.c`：提供 `CnLexer` 结构和 `cn_frontend_lexer_next_token`，已存在。  
    - `lexer_error.h` / `lexer_error.c`：**未存在**（但文档里标注为“可选”）。  
  - **结论**：B2 必要部分已实现，可选“专门的 lexer 错误封装模块”未做。

- **B3 实现基础扫描逻辑**  
  - **状态**：**大部分实现，诊断相关只留 TODO**。  
  - **对应功能点检查：**
    - **跳过空白**：`skip_whitespace` 已实现。  
    - **行注释**：`//` 行注释支持已在 `cn_frontend_lexer_next_token` 中实现。  
    - **整数常量**：`isdigit` 分支将连续数字归为 `CN_TOKEN_INTEGER`，已实现。  
    - **标识符 + 中文关键字区分**：利用 `is_identifier_start/continue` + `keyword_kind`，已实现。  
    - **运算符和分隔符**：`+ - * / % = == ! != < <= > >= && || & ( ) { } [ ] ; , .` 等均已实现。  
    - **非法字符处理**：  
      - 当前行为：在 `default` 分支中，给出 `CN_TOKEN_INVALID`，并 `advance` 跳过。  
      - 但**只留有 TODO 注释**：  
        - 未终止字符串：`/* TODO: 接入诊断模块，报告未终止的字符串字面量 */`  
        - 非法字符：`/* TODO: 接入诊断模块，报告非法字符（使用中文错误信息） */`  
      - **没有真正调用任何诊断接口。**
  - **差异点（未完成部分）**：
    - 没有实现块注释 `/* ... */`（规范 2.5 提到）。  
    - 遇到非法字符和未终止字符串只返回 `CN_TOKEN_INVALID`，**没有生成 Diagnostic 记录**。

- **B4 与诊断接口对接（占位）**  
  - **状态**：**未实现**。  
  - **依据**：
    - 工程中完全没有 `Diagnostic` / `diagnostics` / `report_error` 等实现或声明（对 `src/**/*.c` 搜索为空）。  
    - [lexer.c](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/src/frontend/lexer/lexer.c) 中相关位置只是 TODO 注释，没有实际调用。  
  - **总结**：B4 整体未完成，属于和 D 小节一起要补的内容。

---

### C. 语法分析器与 AST（Parser + AST）

- **C1 设计 AST 结构**  
  - **状态**：已实现。  
  - **依据**：  
    - AST 节点在 [ast.h](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/include/cnlang/frontend/ast.h) 中定义：  
      - `CnAstProgram`、`CnAstFunctionDecl`、`CnAstVarDecl`、`CnAstBlockStmt`、`CnAstExprStmt`、`CnAstReturnStmt`、`CnAstIfStmt`、`CnAstWhileStmt`、`CnAstForStmt` 等。  
      - 表达式包括：`BinaryExpr`、`CallExpr`、`IdentifierExpr`、`IntegerLiteralExpr`、`AssignExpr`、`LogicalExpr`、`UnaryExpr`。  
    - 内存管理：`cn_frontend_ast_*_free` 系列在 [ast.c](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/src/frontend/ast/ast.c) 中实现。  
  - **差异点**：文档中提到的 CallExpr 等结构都已经覆盖；目前不包含显式类型节点（Type），但 v0 阶段语义尚未开始，这点在当前阶段可接受。

- **C2 选择解析接口形式**  
  - **状态**：**部分实现（缺诊断参数）**。  
  - **依据**：
    - 对外接口在 [parser.h](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/include/cnlang/frontend/parser.h)：  
      - `CnParser *cn_frontend_parser_new(CnLexer *lexer);`  
      - `bool cn_frontend_parse_program(CnParser *parser, CnAstProgram **out_program);`  
    - 内部上下文 `CnParser` 在 [parser.c](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/src/frontend/parser/parser.c) 中定义，包含：
      - `CnLexer *lexer;`  
      - `CnToken current;`  
      - `int error_count;` 等。  
  - **缺口**：
    - 文档规划的接口形态是 `parse_program(..., Diagnostics *diag)`，而当前实现完全**没有 Diagnostic 参数**，也没有把错误信息写入统一的诊断结构。
    - 目前只通过 `error_count` 计数，`cn_frontend_parse_program` 返回 `parser->error_count == 0`。

- **C3 实现递归下降解析函数**  
  - **状态**：**主体实现完成，但与 v0 语法存在两处明显不一致 / 缺失**。  
  - **已实现的部分**：
    - `parse_program_internal` 循环解析函数定义，构造 `CnAstProgram`。  
    - `parse_function_decl` 解析：`函数 名称(参数列表) { ... }`，支持参数列表（无类型），与文档“可以视为简化形式”大体一致。  
    - `parse_statement` 支持：
      - `返回` 语句（可带返回值）。  
      - `如果/否则` 块。  
      - `当`（while）循环。  
      - `循环`（for）循环。  
      - `中断` / `继续`。  
      - `变量` 声明：`变量 名 = Expr;` → `CN_AST_STMT_VAR_DECL`。  
      - 其他情况作为表达式语句 `Expr;`。  
    - 表达式层级（对应文档 4 章的一部分）：  
      - 赋值：`a = b`（右结合）。  
      - 逻辑 or/and：`||` / `&&`。  
      - 比较：`== != < <= > >=`。  
      - 加减：`+ -`。  
      - 乘除：`* /`。  
      - 一元：`!`（逻辑非）。  
      - 函数调用：`标识符(实参列表)`。  
      - 基元：整数、标识符、括号包裹的表达式。  
    - 对应的 AST 构造函数 `make_*` 系列在 [parser.c](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/src/frontend/parser/parser.c) 里实现。  
    - 相关单元测试（例如 [parser_minimal_test.c](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/tests/unit/parser_minimal_test.c)、[parser_func_test.c](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/tests/unit/parser_func_test.c)）证明函数定义、if、return、函数调用、变量声明等路径是可用的。

  - **与文档 v0 语法的差异/缺失**：
    1. **缺少对 `整数` 关键字的变量声明解析**  
       - 文档 BNF（0.4）中 `VarDecl = ("整数" | "变量") Identifier "=" Expr;`。  
       - 当前 `parse_statement` **只处理 `CN_TOKEN_KEYWORD_VAR` 分支**，完全忽略 `CN_TOKEN_KEYWORD_INT`：  
         - 结果：`整数 a = 1;` 不会被当作 VarDecl，而会走普通表达式语句的路径，行为与规范不符。
    2. **缺少字符串字面量表达式**  
       - v0 语法中 `Primary` 包含 `StringLiteral`，且 `hello_world.cn` 的 `打印("你好，世界！");` 需要把字符串作为函数调用实参。  
       - 当前 `parse_factor` 只处理：  
         - `CN_TOKEN_INTEGER` → 整数字面量；  
         - `CN_TOKEN_IDENT` → 标识符；  
         - `(` Expr `)`。  
       - 对 `CN_TOKEN_STRING_LITERAL` 的情况，代码走到 `else` 分支，**增加 `error_count` 并跳过 token**，导致：  
         - `函数 主程序() { 打印("你好，世界！"); 返回 0; }` **在当前实现下实际上解析失败**，无法达成文档 0.5 的目标。
    3. **未对 Program 入口 “主程序” 做任何检查**  
       - 文档 EBNF 中 `Program = { Function } "函数" "主程序" "(" ")" Block ;`，逻辑上希望强制存在一个 `主程序`。  
       - 当前 `parse_program_internal` 不检查是否有 `主程序` 函数，这一点可能留给后续语义分析阶段处理；**在 Stage 1 可以接受是“未严格实现”**，但值得在后续 TODO 中标记。

---

### D. 诊断与错误恢复模块

整个 D 小节（D1、D2、D3）在当前仓库中基本都处于“规划但未实现”的状态：

- **D1 设计诊断数据结构**  
  - **状态**：未实现。  
  - 工程中没有 `Diagnostic` 相关结构或头文件。

- **D2 诊断接口实现**  
  - **状态**：未实现。  
  - 没有 `report_error(...)` / `report_warning(...)` 之类的对外接口；`src/support/diagnostics` 模块也不存在。

- **D3 前端接入诊断模块**  
  - **状态**：未实现。  
  - Lexer 中仅用 TODO 表示未来要接入。  
  - Parser 中只有 `error_count++`，未调用诊断接口，也无错误定位信息（文件名、行列号）传到统一模块。

---

### E. 单元测试（Unit Tests）

- **E1 词法单元测试**  
  - **状态**：**有基础测试，但不符合“断言型单测 + 错误场景”要求**。  
  - 当前有 [lexer_function_examples_test.c](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/tests/unit/lexer_function_examples_test.c)：  
    - 行为：读入 `examples/function_examples.cn`，调用 Lexer 逐个打印 Token。  
    - **问题**：
      - 只是输出 Token，不对 Token 序列进行断言，不属于严格意义“单元测试”。  
      - 没有覆盖文档中明确要求的场景：  
        - 简单表达式如 `1 + 2 * 3` 的 Token 序列是否正确。  
        - 含中文关键字的语句（`整数/变量/函数` 等）。  
        - 非法字符处理（是否生成诊断或返回 `CN_TOKEN_INVALID` 并计入错误）。  

- **E2 语法单元测试**  
  - **状态**：**已有不少正向路径测试，错误路径和 v0 示例相关测试缺失**。  
  - 已存在的测试包括：  
    - [parser_minimal_test.c](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/tests/unit/parser_minimal_test.c)：测试 `如果 + 返回`。  
    - [parser_func_test.c](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/tests/unit/parser_func_test.c)：测试函数参数、函数调用、变量声明和返回。  
    - 以及 CMake 中列出的其他测试：`parser_assign_test`、`parser_break_test`、`parser_logical_test`、`parser_loop_test`、`parser_var_test` 等（虽未逐一展开，但可以确认 Parser 多数语法规则已有覆盖）。  
  - **缺失点**：
    - 没有测试 `hello_world.cn` 这样的 v0 入口示例是否能正确构造 AST（特别是 `主程序` 函数 + `打印("你好")` + `返回 0`）。  
    - 没有针对“语法错误（缺分号、括号不匹配）”的专门单元测试，只是依赖 `error_count` 简单判断，且没有诊断信息断言。

---

### F. 集成测试（Integration Tests）

- **F1 正常解析样例**  
  - **状态**：未实现。  
  - `tests/integration` 目录只有一个 [CMakeLists.txt](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/tests/integration/CMakeLists.txt)，里面写明“当前暂无集成测试，后续阶段补充”。  
  - 没有任何 C 源文件或 `add_executable`/`add_test`。

- **F2 解析失败样例**  
  - **状态**：未实现。  
  - 不存在专门的“解析失败 + 诊断”集成测试样例。

---

### 建议的实施步骤（TODO 列表）

结合上面的对照，我建议按下面顺序补齐，实现“最小可用前端 + 基本测试”：

1. **先补齐 Parser 与 v0 语法的关键缺口**（最小改动、立刻提升可用性）  
   - **TODO 1.1**：在 [parser.c](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/src/frontend/parser/parser.c) 的 `parse_statement` 中，新增 `CN_TOKEN_KEYWORD_INT` 分支，支持：  
     - `整数 标识符 = Expr;` → 构造 `CN_AST_STMT_VAR_DECL`。  
   - **TODO 1.2**：在 `parse_factor` 中增加对 `CN_TOKEN_STRING_LITERAL` 的处理，构造一个新的 `CnAstExpr` 变种（例如后续添加 `CN_AST_EXPR_STRING_LITERAL`，或暂时复用 IntegerLiteral 的模式另加字段），以便：  
     - 能解析 `打印("你好，世界！");` 这种调用，解决 `hello_world.cn` 当前无法解析的问题。  
   - **TODO 1.3**：可选：在 `parse_program_internal` 返回前，增加一个简单检查：  
     - 是否存在名称为 `主程序` 的函数，如果没有，可以增加 `error_count`，为后续语义阶段提前发现问题（也可以暂时先不加，留给语义分析阶段）。

2. **设计并落地最小版 Diagnostics 模块 + Lexer/Parser 接入**  
   - **TODO 2.1**：在 `include/cnlang/support/` 和 `src/support/diagnostics/` 下定义：  
     - `DiagnosticSeverity`、`DiagnosticCode`、`Diagnostic` 结构；  
     - `Diagnostics` 容器（例如一个动态数组），以及 `report_error(...)` / `report_warning(...)` 原型。  
   - **TODO 2.2**：在 Lexer 中接入 Diagnostics：  
     - 未终止字符串和非法字符位置，调用 `report_error_lex(...)` 之类包装函数，同时保持返回 `CN_TOKEN_INVALID`。  
   - **TODO 2.3**：在 Parser 中接入 Diagnostics：  
     - `parser_expect`、`parse_factor` 中遇到错误时，除了 `error_count++`，同时记录具体错误（当前 token 种类、行列号、预期 token 等）。  
     - 将 `cn_frontend_parse_program` 接口扩展为接受 `Diagnostics *` 指针（这一步改动面会稍大，需要同步调整所有使用处和测试）。

3. **补齐 Lexer/Parser 单元测试，覆盖 v0 示例与错误场景**  
   - **TODO 3.1**：在 `tests/unit` 下新增更“断言化”的 Lexer 测试文件（可以用现有 CMake 风格）：  
     - 场景：`1 + 2 * 3` 的 Token 序列；  
     - `函数 主程序() { ... }` 中几个关键 Token；  
     - 人造一个非法字符样例，验证 Diagnostics 中是否记录。  
   - **TODO 3.2**：新增 Parser 单测：  
     - 场景：`examples/hello_world.cn`（可直接读文件），断言：  
       - 存在一个函数 `主程序`；  
       - 函数体第一条是表达式语句（打印调用），实参为字符串字面量；  
       - 第二条为 `返回` 语句，返回值为整数 0。  
   - **TODO 3.3**：新增少量“错误语法”测试：  
     - 少一个分号、括号不匹配等，检查 `cn_frontend_parse_program` 返回 false，且 Diagnostics 中存在至少一条错误。

4. **补齐至少一个正向、一个负向的集成测试（F1/F2）**  
   - **TODO 4.1**：在 `tests/integration` 目录下：  
     - 新增一个简单的 C 程序：  
       - 读取 `examples/hello_world.cn`，  
       - 用 Lexer + Parser 构造 AST，  
       - 断言解析成功且 Diagnostics 中没有 error。  
   - **TODO 4.2**：新增一个“解析失败样例”：  
     - 自制一个 `.cn` 文件（可以放在 `examples/` 或 `tests/integration` 本地字符串），缺少花括号/分号；  
     - 集成测试中断言 `cn_frontend_parse_program` 报错，Diagnostics 中存在至少一条语法错误记录。  
   - **TODO 4.3**：在 `tests/integration/CMakeLists.txt` 中添加相应 `add_executable`/`add_test`。

---

如果你希望**马上开始改代码**，我建议从 **TODO 1.1 + 1.2** 入手（让 `hello_world.cn` 真正能被当前前端完整解析），我可以下一步直接在 `parser.c` 和 `ast.h/ast.c` 里帮你把这两个点实现掉，然后再逐步推进诊断模块和测试补齐。你更希望我优先做哪一块？