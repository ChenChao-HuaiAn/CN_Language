### 针对 `阶段 1：前端基础（词法/语法）与最小可编译样例.md` 24–48 行的 TODO 拆解

基于你选中的 B 段内容（词法分析器部分），我帮你整理成更“可执行”的 TODO 列表，方便按步骤实现词法器。

---

### B. 词法分析器（Lexer）实现 TODO

- **B1 设计 Token 集合**
  - [ ] 列出所有 Token 类型枚举（例如在 `token.h` 中）：
    - [ ] 标识符（Identifier）
    - [ ] 整数常量（IntegerLiteral）
    - [ ] 关键字（if/否则/函数/返回 等中英文关键字）
    - [ ] 运算符（`+ - * / =` 等）
    - [ ] 分隔符和括号（`( ) { } ; ,` 等）
    - [ ] 文件结束符（EOF）
    - [ ] 其他将来扩展用的保留类型（如字符串、比较运算符等，可先预留）
  - [ ] 设计一个结构体 `Token`：
    - [ ] 字段：`type`（枚举）、`lexeme`（原始文本指针或拷贝）、`line`、`column`
    - [ ] 视需求增加：整数值缓存（例如 `int value;`）

- **B2 设计词法模块结构**
  - [ ] 创建/规划文件：
    - [ ] `token.h`：`TokenType` 枚举、`Token` 结构体声明、调试打印函数声明
    - [ ] `token.c`：`token_to_string`、`print_token` 等实现
    - [ ] `lexer.h`：`Lexer` 状态结构体、`lexer_init(...)`、`next_token(...)` 等接口声明
    - [ ] `lexer.c`：`Lexer` 的具体实现（状态机、扫描逻辑）
    - [ ] （可选）`lexer_error.h / lexer_error.c`：封装词法错误上报函数，如 `report_lex_error(...)`
  - [ ] 约束单个 `.c` 文件和单个函数的行数：
    - [ ] 将扫描子逻辑拆分成多个小函数（如 `scan_number`, `scan_identifier`, `scan_operator`）

- **B3 实现基础扫描逻辑**
  - [ ] 在 `lexer.c` 中实现 `next_token(Lexer* lexer)`：
    - [ ] 跳过空白字符：空格、换行、制表符等
    - [ ] 当遇到数字：按“连续数字”扫描，生成整数常量 Token
    - [ ] 当遇到标识符首字符（中文/英文/下划线）：继续扫描“标识符字符”
      - [ ] 扫描完后，与关键字表比对：如果在关键字表中则设为“关键字类型”，否则为“普通标识符”
      - [ ] 关键字表中要包含中文关键字（例如：`如果`、`否则`、`返回` 等）
    - [ ] 当遇到运算符或分隔符字符（`+ - * / = ( ) { } ; ,`）：直接生成相应 Token
  - [ ] EOF 处理：
    - [ ] 输入结束时返回 EOF Token（例如 `TOKEN_EOF`）

- **B4 与诊断接口对接（占位）**
  - [ ] 设计一个统一的（暂时可以是 stub）错误接口，例如：
    - [ ] `void report_error_lex(int line, int column, const char* message);`
  - [ ] 在以下场景调用该接口：
    - [ ] 遇到无法识别的字符（非法字符）
    - [ ] 其他暂时不支持但扫描到的模式（可以简单报“暂不支持的字符/Token”）
  - [ ] 错误发生后：
    - [ ] 尝试跳过当前非法字符或部分文本，继续扫描后续 Token，而不是直接终止

---
