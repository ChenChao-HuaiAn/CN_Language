# CN_Language 1.0 新特性指南

**版本**: 1.0.0  
**发布日期**: 2026年1月  
**适用用户**: 所有CN Language开发者

---

## 概述

CN_Language 1.0是一个重要的里程碑版本，标志着语言从实验阶段进入稳定阶段。本版本完成了从阶段1到阶段8的全部核心目标，提供了完整的系统编程能力和操作系统内核开发支持。

### 核心亮点

- ✅ 完整的编译器前端（词法/语法/语义分析）
- ✅ 成熟的C后端代码生成
- ✅ 丰富的核心语法特性（指针、结构体、枚举、函数指针、预处理器）
- ✅ freestanding模式支持，可用于OS内核开发
- ✅ 完善的工具链（cnc/cnrepl/cnfmt/cncheck/cnlsp）
- ✅ 建立了稳定的版本管理和回归测试体系

---

## 一、指针类型与运算 (阶段8.1)

### 基本指针操作

CN_Language 1.0提供了完整的C风格指针支持，包括指针声明、解引用和地址操作。

```cnlang
// 指针声明和基本操作
函数 指针示例() {
    整数 x = 42;
    整数* ptr = &x;  // 取地址
    
    打印("x的值: %d\n", x);
    打印("ptr指向的值: %d\n", *ptr);  // 解引用
    
    *ptr = 100;  // 通过指针修改值
    打印("修改后x的值: %d\n", x);
}
```

### 指针运算

支持指针算术运算，用于数组遍历和内存操作：

```cnlang
函数 指针运算示例() {
    整数 数组[] = {10, 20, 30, 40, 50};
    整数* ptr = 数组;
    
    // 指针递增遍历数组
    循环(变量 i = 0; i < 5; i++) {
        打印("元素[%d] = %d\n", i, *ptr);
        ptr++;  // 指针递增
    }
    
    // 指针算术
    ptr = 数组 + 2;  // 指向第3个元素
    打印("数组[2] = %d\n", *ptr);
}
```

### 多级指针

支持多级指针（指向指针的指针）：

```cnlang
函数 多级指针示例() {
    整数 x = 100;
    整数* ptr = &x;
    整数** pptr = &ptr;  // 二级指针
    
    打印("通过二级指针访问: %d\n", **pptr);
}
```

**参考示例**: `examples/syntax/pointers/pointer_example.cn`

---

## 二、结构体与联合体 (阶段8.2)

### 结构体定义

结构体是组织复杂数据的基础：

```cnlang
// 结构体定义
结构体 点 {
    整数 x;
    整数 y;
};

结构体 矩形 {
    点 左上;
    点 右下;
};

函数 结构体示例() {
    点 p1 = {10, 20};
    打印("点坐标: (%d, %d)\n", p1.x, p1.y);
    
    矩形 rect = {{0, 0}, {100, 200}};
    打印("矩形大小: %d x %d\n", 
          rect.右下.x - rect.左上.x,
          rect.右下.y - rect.左上.y);
}
```

### 结构体指针

结构体可以通过指针访问，支持 `->` 操作符：

```cnlang
函数 处理点(点* p) {
    p->x += 10;
    p->y += 20;
}

函数 结构体指针示例() {
    点 p = {5, 10};
    处理点(&p);
    打印("新坐标: (%d, %d)\n", p.x, p.y);
}
```

### 内存布局控制

结构体遵循C ABI规范，支持对齐和填充：

```cnlang
结构体 对齐示例 {
    字符 c;      // 1字节
    整数 i;      // 4字节，对齐到4字节边界
    短整数 s;    // 2字节
};

// sizeof(对齐示例) 考虑填充后为12字节
```

**参考示例**: `examples/syntax/structs/struct_complete_example.cn`

---

## 三、枚举类型 (阶段8.3)

### 基本枚举

枚举提供了命名常量的类型安全方式：

```cnlang
枚举 颜色 {
    红色 = 0,
    绿色 = 1,
    蓝色 = 2
};

枚举 状态 {
    成功,    // 自动赋值为0
    失败,    // 自动赋值为1
    等待中   // 自动赋值为2
};

函数 枚举示例() {
    变量 颜色 c = 红色;
    
    如果 (c == 红色) {
        打印("颜色是红色\n");
    }
    
    变量 状态 s = 成功;
    打印("状态值: %d\n", s);
}
```

### 枚举在switch中使用

枚举常用于switch语句：

```cnlang
函数 处理状态(状态 s) {
    选择 (s) {
        情况 成功:
            打印("操作成功\n");
            跳出;
        情况 失败:
            打印("操作失败\n");
            跳出;
        情况 等待中:
            打印("正在等待\n");
            跳出;
    }
}
```

**参考示例**: `examples/syntax/enums/enum_basic.cn`

---

## 四、函数指针与回调 (阶段8.4)

### 函数指针声明

函数指针允许将函数作为参数传递：

```cnlang
// 函数指针类型定义
类型别名 整数运算 = 函数(整数, 整数) -> 整数;

函数 加法(整数 a, 整数 b) -> 整数 {
    返回 a + b;
}

函数 减法(整数 a, 整数 b) -> 整数 {
    返回 a - b;
}

函数 执行运算(整数运算 操作, 整数 x, 整数 y) -> 整数 {
    返回 操作(x, y);
}

函数 函数指针示例() {
    打印("10 + 5 = %d\n", 执行运算(加法, 10, 5));
    打印("10 - 5 = %d\n", 执行运算(减法, 10, 5));
}
```

### 回调函数模式

函数指针常用于实现回调机制：

```cnlang
类型别名 回调函数 = 函数(整数) -> 空;

函数 遍历数组(整数* 数组, 整数 长度, 回调函数 处理) {
    循环(变量 整数 i = 0; i < 长度; i++) {
        处理(数组[i]);
    }
}

函数 打印元素(整数 值) {
    打印("元素: %d\n", 值);
}

函数 回调示例() {
    变量 整数 数据[] = {1, 2, 3, 4, 5};
    遍历数组(数据, 5, 打印元素);
}
```

**参考示例**: `examples/syntax/functions/function_pointer_example.cn`

---

## 五、预处理器宏系统 (阶段8.5)

### 宏定义

CN_Language支持C风格的预处理器宏：

```cnlang
#定义 最大值 100
#定义 PI 3.14159
#定义 平方(x) ((x) * (x))

函数 宏示例() {
    打印("最大值: %d\n", 最大值);
    打印("PI: %.5f\n", PI);
    打印("5的平方: %d\n", 平方(5));
}
```

### 条件编译

支持条件编译指令：

```cnlang
#定义 调试模式

#如果定义 调试模式
    #定义 日志(msg) 打印("[DEBUG] %s\n", msg)
#否则
    #定义 日志(msg)  // 空操作
#结束如果

函数 条件编译示例() {
    日志("这是调试信息");
}
```

### 平台适配

预处理器用于平台特定代码：

```cnlang
#如果定义 __WINDOWS__
    #定义 路径分隔符 '\\'
#否则如果定义 __LINUX__
    #定义 路径分隔符 '/'
#否则
    #错误 "不支持的平台"
#结束如果
```

**参考示例**: `examples/syntax/preprocessor/preprocessor_example.cn`

---

## 六、直接内存访问 (阶段8.6)

### 内存地址操作

支持直接访问指定内存地址，用于硬件编程：

```cnlang
函数 内存访问示例() {
    // 读取特定地址的值（例如MMIO）
    变量 整数* 设备寄存器 = 作为<整数*>(0x40000000);
    变量 整数 状态 = *设备寄存器;
    
    // 写入特定地址
    *设备寄存器 = 0x01;
}
```

### 内存映射IO

在操作系统内核开发中使用：

```cnlang
#定义 VGA_缓冲区 作为<字符*>(0xB8000)

函数 写入屏幕(字符* 文本) {
    变量 字符* 视频 = VGA_缓冲区;
    循环(变量 整数 i = 0; 文本[i] != '\0'; i++) {
        视频[i * 2] = 文本[i];
        视频[i * 2 + 1] = 0x07;  // 白色文字
    }
}
```

**参考示例**: `examples/system/memory/memory_access_example.cn`

---

## 七、内联汇编 (阶段8.7)

### 基本内联汇编

支持在CN代码中嵌入汇编代码：

```cnlang
函数 读取时间戳() -> 长整数 {
    变量 长整数 结果;
    内联汇编 {
        "rdtsc"
        "shl $32, %%rdx"
        "or %%rdx, %%rax"
        : "=a"(结果)
    };
    返回 结果;
}
```

### 系统调用示例

使用内联汇编进行系统调用：

```cnlang
函数 系统退出(整数 代码) {
    内联汇编 {
        "mov $60, %%rax"   // exit系统调用号
        "mov %0, %%rdi"    // 退出代码
        "syscall"
        :
        : "r"(代码)
        : "rax", "rdi"
    };
}
```

**参考示例**: `examples/system/inline-asm/inline_asm_basic_test.cn`

---

## 八、位操作符 (阶段8.8)

### 基本位操作

CN_Language提供完整的位操作符：

```cnlang
函数 位操作示例() {
    变量 整数 a = 0b1100;  // 二进制字面量
    变量 整数 b = 0b1010;
    
    打印("a & b = 0x%x\n", a & b);   // 按位与
    打印("a | b = 0x%x\n", a | b);   // 按位或
    打印("a ^ b = 0x%x\n", a ^ b);   // 按位异或
    打印("~a = 0x%x\n", ~a);         // 按位取反
    
    打印("a << 2 = 0x%x\n", a << 2); // 左移
    打印("a >> 1 = 0x%x\n", a >> 1); // 右移
}
```

### 位掩码操作

位操作常用于标志位和寄存器操作：

```cnlang
#定义 标志_读  (1 << 0)
#定义 标志_写  (1 << 1)
#定义 标志_执行 (1 << 2)

函数 检查权限(整数 标志) -> 布尔 {
    返回 (标志 & 标志_写) != 0;
}

函数 设置标志(整数* 标志, 整数 位) {
    *标志 |= 位;
}

函数 清除标志(整数* 标志, 整数 位) {
    *标志 &= ~位;
}
```

**参考示例**: `examples/system/bitwise/bitwise_basic_test.cn`

---

## 九、中断处理机制 (阶段8.9)

### 中断处理函数

CN_Language支持定义中断处理函数：

```cnlang
// 中断处理函数属性
#定义 中断处理器 __attribute__((interrupt))

中断处理器
函数 定时器中断处理(中断帧* 帧) {
    // 处理定时器中断
    打印("定时器中断!\n");
}
```

### 中断向量表

在内核开发中设置中断向量表：

```cnlang
结构体 中断描述符 {
    短整数 偏移_低;
    短整数 选择符;
    字符 零;
    字符 类型属性;
    短整数 偏移_中;
    整数 偏移_高;
    整数 保留;
};

函数 设置中断门(整数 向量, 空* 处理函数) {
    // 设置IDT表项
}
```

**参考示例**: `examples/system/interrupts/interrupt_example.cn`

---

## 十、原子操作与锁 (阶段8.10)

### 原子操作

支持无锁的原子操作：

```cnlang
函数 原子操作示例() {
    变量 原子_整数 计数器 = 0;
    
    // 原子加法
    原子_增加(&计数器, 1);
    
    // 原子比较交换
    变量 整数 期望 = 0;
    原子_比较交换(&计数器, &期望, 1);
    
    打印("计数器: %d\n", 原子_读取(&计数器));
}
```

### 互斥锁

提供互斥锁实现线程同步：

```cnlang
结构体 互斥锁 {
    原子_整数 已锁定;
};

函数 互斥锁_初始化(互斥锁* 锁) {
    原子_存储(&锁->已锁定, 0);
}

函数 互斥锁_加锁(互斥锁* 锁) {
    循环(原子_交换(&锁->已锁定, 1) == 1) {
        // 自旋等待
    }
}

函数 互斥锁_解锁(互斥锁* 锁) {
    原子_存储(&锁->已锁定, 0);
}
```

### 自旋锁

自旋锁用于内核同步：

```cnlang
结构体 自旋锁 {
    原子_整数 锁;
};

函数 自旋锁_获取(自旋锁* s) {
    循环(原子_测试并设置(&s->锁, 1) == 1) {
        // CPU暂停
        内联汇编 { "pause" };
    }
}
```

**参考示例**: `examples/system/concurrency/atomic_basic_test.cn`

---

## 十一、标准C库中文接口 (阶段8.11)

### 中文API封装

CN_Language提供了标准C库的中文接口：

```cnlang
// 字符串操作
函数 字符串长度(字符* 字符串) -> 整数;
函数 字符串复制(字符* 目标, 字符* 源);
函数 字符串比较(字符* 字符串1, 字符* 字符串2) -> 整数;

// 内存操作
函数 内存复制(空* 目标, 空* 源, 整数 大小);
函数 内存设置(空* 指针, 整数 值, 整数 大小);
函数 内存比较(空* 指针1, 空* 指针2, 整数 大小) -> 整数;

// 示例
函数 中文接口示例() {
    变量 字符 缓冲区[100];
    字符串复制(缓冲区, "你好，世界");
    变量 整数 长度 = 字符串长度(缓冲区);
    打印("字符串长度: %d\n", 长度);
}
```

---

## 十二、内存分配器 (阶段8.12)

### 堆内存管理

提供动态内存分配接口：

```cnlang
函数 内存分配器示例() {
    // 分配内存
    变量 整数* 数组 = 作为<整数*>(分配内存(10 * 求大小(整数)));
    
    如果 (数组 == 空) {
        打印("内存分配失败\n");
        返回;
    }
    
    // 使用内存
    循环(变量 整数 i = 0; i < 10; i++) {
        数组[i] = i * 10;
    }
    
    // 释放内存
    释放内存(数组);
}
```

### 自定义分配器

支持实现自定义内存分配器：

```cnlang
结构体 块头 {
    整数 大小;
    布尔 已使用;
    块头* 下一个;
};

函数 简单分配器_初始化(空* 堆起始, 整数 堆大小);
函数 简单分配器_分配(整数 大小) -> 空*;
函数 简单分配器_释放(空* 指针);
```

**参考示例**: `examples/system/memory/memory_manager_demo.cn`

---

## 十三、标准IO系统 (阶段8.13)

### 文件操作

提供标准的文件IO操作：

```cnlang
函数 文件操作示例() {
    // 打开文件
    变量 文件* f = 打开文件("test.txt", "w");
    如果 (f == 空) {
        打印("无法打开文件\n");
        返回;
    }
    
    // 写入文件
    文件打印(f, "Hello, CN Language!\n");
    
    // 关闭文件
    关闭文件(f);
}
```

### 格式化输出

支持格式化输出：

```cnlang
函数 格式化输出示例() {
    打印("整数: %d\n", 42);
    打印("浮点数: %.2f\n", 3.14159);
    打印("字符串: %s\n", "CN Language");
    打印("十六进制: 0x%x\n", 255);
}
```

---

## 十四、Freestanding模式 (阶段8.14)

### 内核开发支持

CN_Language支持freestanding模式，可用于操作系统内核开发：

```cnlang
// 编译命令: cnc --freestanding kernel.cn -o kernel.elf

// 内核入口点
函数 内核主函数() {
    // 不依赖标准库的代码
    变量 字符* 视频内存 = 作为<字符*>(0xB8000);
    视频内存[0] = 'H';
    视频内存[1] = 0x0F;
    
    循环(真) {
        // 内核主循环
    }
}
```

### 无标准库约束

在freestanding模式下，编译器会检查：
- 禁止使用标准库函数（如 malloc、printf等）
- 禁止使用依赖操作系统的特性
- 需要提供自己的运行时支持

**参考示例**: `examples/os-kernel/os_kernel_demo.cn`

---

## 十五、操作系统内核实例 (阶段8.15)

### 简单内核示例

CN_Language 1.0已成功构建真实的ELF内核：

```cnlang
// 简化的内核示例
#定义 VGA_缓冲区 作为<字符*>(0xB8000)

函数 清屏() {
    变量 字符* 视频 = VGA_缓冲区;
    循环(变量 整数 i = 0; i < 80 * 25 * 2; i++) {
        视频[i] = 0;
    }
}

函数 打印字符串(字符* 文本, 整数 颜色) {
    变量 字符* 视频 = VGA_缓冲区;
    变量 整数 i = 0;
    
    循环(文本[i] != '\0') {
        视频[i * 2] = 文本[i];
        视频[i * 2 + 1] = 颜色;
        i++;
    }
}

函数 内核主函数() {
    清屏();
    打印字符串("CN Language OS Kernel", 0x0F);
    
    循环(真) {}  // 停机循环
}
```

### 构建内核

使用提供的构建脚本：

```bash
# Windows + WSL2环境
cd examples/os-kernel
pwsh build_os_kernel.ps1
```

详细内核开发教程请参考：
- `examples/os-kernel/README.md`
- `examples/docs/OS_KERNEL_README.md`
- `examples/docs/QEMU_TESTING_GUIDE.md`

---

## 十六、性能与兼容性

### 编译性能

CN_Language 1.0经过充分优化：
- Hello World编译时间 < 3ms
- 代码生成阶段优化后耗时降低32%
- 支持大型项目（>10,000行代码）

### 多平台支持

支持的目标平台：
- **Windows**: x86_64 (MSVC/GCC/Clang)
- **Linux**: x86_64 (GCC/Clang)
- **Freestanding**: x86_64（操作系统内核）

### ABI兼容性

生成的代码遵循标准C ABI：
- 可以与C代码互操作
- 支持调用C库函数
- 支持被C代码调用

---

## 十七、工具链

### cnc - 编译器

```bash
# 基本编译
cnc program.cn -o program

# 生成C代码
cnc program.cn --emit-c -o program.c

# Freestanding模式
cnc kernel.cn --freestanding -o kernel.elf

# 性能分析
cnc program.cn --perf-json=perf.json
```

### cnrepl - 交互式解释器

```bash
cnrepl

> 变量 x = 42
> 打印("%d\n", x)
42
```

### cnfmt - 代码格式化

```bash
# 格式化文件
cnfmt program.cn

# 检查格式
cnfmt --check program.cn
```

### cncheck - 静态检查

```bash
# 代码检查
cncheck program.cn

# 严格模式
cncheck --strict program.cn
```

### cnlsp - 语言服务器

提供IDE支持：
- 语法高亮
- 代码补全
- 错误诊断
- 跳转定义

---

## 十八、学习资源

### 示例代码

- `examples/basic/` - 入门示例
- `examples/syntax/` - 语法特性示例（50+文件）
- `examples/system/` - 系统编程示例
- `examples/os-kernel/` - 内核开发示例

### 文档

- [CN_Language 语法标准](../design/CN_Language%20语法标准.md)
- [编译器架构设计](../design/CN_Language%20编译器%20工具链架构设计.md)
- [测试规范](../specifications/CN_Language%20测试规范.md)
- [C代码风格规范](../specifications/CN_Language%20C%20代码风格规范.md)

### 迁移指南

如果您是从0.x版本升级，请参考：
- [1.0迁移指南](CN_Language_1.0_迁移指南.md)

---

## 十九、已知限制

### 1.0版本的已知限制：

1. **二进制后端**: 1.0仍使用C后端，直接二进制后端将在后续版本提供
2. **泛型系统**: 泛型/模板系统计划在2.0版本引入
3. **面向对象**: 类和继承等OOP特性属于长期规划
4. **异常处理**: 结构化异常处理将在后续版本提供

这些限制不影响1.0版本的生产使用，所有系统编程需求均可满足。

---

## 二十、下一步

### 推荐学习路径

1. **基础语法** → `examples/basic/hello_world.cn`
2. **指针和数组** → `examples/syntax/pointers/`
3. **结构体** → `examples/syntax/structs/`
4. **系统编程** → `examples/system/memory/`
5. **内核开发** → `examples/os-kernel/`

### 社区资源

- GitHub仓库: [CN_Language](https://github.com/your-org/CN_Language)
- 问题反馈: GitHub Issues
- 讨论区: GitHub Discussions

---

**文档版本**: 1.0  
**最后更新**: 2026-01-26  
**维护者**: CN_Language开发团队
