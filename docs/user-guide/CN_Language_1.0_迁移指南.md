# CN_Language 1.0 迁移指南

**目标读者**: 0.x版本用户  
**文档版本**: 1.0  
**发布日期**: 2026-01-26

---

## 概述

本指南帮助0.x版本用户平滑迁移到CN_Language 1.0。虽然1.0是一个重要的里程碑版本，但我们尽可能保持了向后兼容性。大部分0.x代码无需修改即可在1.0上运行。

### 迁移概要

- ✅ **源代码兼容性**: 95%+的0.x代码无需修改
- ✅ **渐进式迁移**: 可以逐步采用新特性
- ⚠️ **需要重新编译**: 1.0生成的二进制不兼容0.x
- ⚠️ **少数语法调整**: 部分边缘情况需要小幅修改

---

## 一、版本兼容性策略

### 1.1 语义化版本承诺

从1.0.0开始，CN_Language遵循严格的[语义化版本控制](https://semver.org/)：

| 版本类型 | 兼容性承诺 | 示例 |
|---------|-----------|------|
| **PATCH更新** (1.0.x) | 完全兼容，Bug修复 | 1.0.0 → 1.0.1 |
| **MINOR更新** (1.x.0) | 源代码兼容，新增特性 | 1.0.0 → 1.1.0 |
| **MAJOR更新** (x.0.0) | 可能不兼容，重大变更 | 1.0.0 → 2.0.0 |

### 1.2 0.x版本的特殊性

在0.x阶段（实验性开发）：
- 次版本号变更可能包含不兼容改动
- 不保证向后兼容性
- API可能频繁变化

**1.0是首个稳定版本**，标志着进入成熟阶段。

---

## 二、重大变更清单

### 2.1 无破坏性变更

**好消息**: 从最新的0.9.x版本迁移到1.0.0，**没有破坏性变更**！

- ✅ 所有0.9.x语法在1.0中保持不变
- ✅ 所有0.9.x API在1.0中继续可用
- ✅ 编译器行为保持一致

### 2.2 早期版本迁移注意事项

如果您使用的是0.7.x或更早版本，需要注意以下变更：

#### 2.2.1 模块系统增强 (0.8.0引入)

**变更**: 模块导入语法支持选择性导入

```cnlang
// 0.7.x及之前：只能全量导入
导入 数学;

// 0.8.0+：支持选择性导入
导入 { 平方根, 幂运算 } 来自 数学;
```

**迁移策略**: 旧语法仍然有效，新代码推荐使用选择性导入。

#### 2.2.2 Freestanding模式 (0.8.0引入)

**变更**: 新增`--freestanding`编译选项

```bash
# 0.7.x: 没有此选项
cnc kernel.cn -o kernel

# 0.8.0+: 内核开发使用freestanding模式
cnc kernel.cn --freestanding -o kernel.elf
```

**迁移策略**: 
- 普通应用程序不受影响
- OS内核代码需添加`--freestanding`标志

#### 2.2.3 预处理器增强 (0.9.0引入)

**变更**: 预处理器宏支持中文关键字

```cnlang
// 0.8.x及之前：只能使用英文
#define MAX_SIZE 100
#ifdef DEBUG
#endif

// 0.9.0+：支持中文关键字
#定义 最大尺寸 100
#如果定义 调试
#结束如果
```

**迁移策略**: 英文语法继续有效，可选择性使用中文。

---

## 三、新特性采用指南

### 3.1 渐进式采用策略

您无需一次性采用所有1.0新特性。建议按以下顺序渐进采用：

#### 阶段1: 基础迁移（必需）
1. ✅ 更新编译器到1.0版本
2. ✅ 重新编译所有代码
3. ✅ 运行现有测试验证

#### 阶段2: 核心特性（推荐）
1. 使用指针替代复杂的数组操作
2. 使用结构体组织数据
3. 使用枚举提高代码可读性

#### 阶段3: 高级特性（可选）
1. 使用函数指针实现回调
2. 使用预处理器简化平台适配
3. 使用内联汇编优化关键路径

#### 阶段4: 系统编程（特定场景）
1. 如需内核开发，启用freestanding模式
2. 如需硬件编程，使用直接内存访问
3. 如需并发，使用原子操作和锁

### 3.2 示例：从0.9迁移到1.0

#### 示例1: 使用指针优化数组操作

**0.9.x代码**:
```cnlang
函数 求和(整数 数组[], 整数 长度) -> 整数 {
    变量 整数 总和 = 0;
    循环(变量 整数 i = 0; i < 长度; i++) {
        总和 += 数组[i];
    }
    返回 总和;
}
```

**1.0优化版本**:
```cnlang
函数 求和(整数* 数组, 整数 长度) -> 整数 {
    变量 整数 总和 = 0;
    变量 整数* 结束 = 数组 + 长度;
    
    循环(数组 < 结束) {
        总和 += *数组;
        数组++;
    }
    返回 总和;
}
```

**说明**: 使用指针遍历通常比索引更高效，但两种写法都有效。

#### 示例2: 使用结构体重构代码

**0.9.x代码**:
```cnlang
函数 创建用户(整数 id, 字符* 名称, 整数 年龄) {
    // 使用多个参数
}

函数 打印用户(整数 id, 字符* 名称, 整数 年龄) {
    打印("用户[%d]: %s, %d岁\n", id, 名称, 年龄);
}
```

**1.0优化版本**:
```cnlang
结构体 用户 {
    整数 id;
    字符* 名称;
    整数 年龄;
};

函数 创建用户(整数 id, 字符* 名称, 整数 年龄) -> 用户 {
    变量 用户 u = {id, 名称, 年龄};
    返回 u;
}

函数 打印用户(用户* u) {
    打印("用户[%d]: %s, %d岁\n", u->id, u->名称, u->年龄);
}
```

**说明**: 结构体使代码更易维护，但旧代码仍然有效。

#### 示例3: 使用枚举替代魔数

**0.9.x代码**:
```cnlang
函数 处理状态(整数 状态码) {
    如果 (状态码 == 0) {
        打印("成功\n");
    } 否则如果 (状态码 == 1) {
        打印("失败\n");
    } 否则如果 (状态码 == 2) {
        打印("等待中\n");
    }
}
```

**1.0优化版本**:
```cnlang
枚举 状态 {
    成功 = 0,
    失败 = 1,
    等待中 = 2
};

函数 处理状态(状态 s) {
    选择 (s) {
        情况 成功:
            打印("成功\n");
            跳出;
        情况 失败:
            打印("失败\n");
            跳出;
        情况 等待中:
            打印("等待中\n");
            跳出;
    }
}
```

**说明**: 枚举提供类型安全和更好的可读性，但魔数仍可工作。

---

## 四、工具链变更

### 4.1 编译器 (cnc)

#### 新增选项

```bash
# Freestanding模式（内核开发）
cnc --freestanding kernel.cn -o kernel.elf

# 性能分析输出
cnc --perf-json=perf.json program.cn -o program

# 更详细的错误信息
cnc --verbose program.cn -o program
```

#### 行为变更

- ✅ 默认优化级别从O0提升到O1
- ✅ 更快的编译速度（平均提升30%）
- ✅ 更准确的错误提示

### 4.2 格式化工具 (cnfmt)

#### 新增功能

```bash
# 只检查不修改
cnfmt --check program.cn

# 递归格式化目录
cnfmt --recursive src/

# 自定义配置文件
cnfmt --config=.cnfmt.toml program.cn
```

### 4.3 REPL (cnrepl)

#### 增强功能

- ✅ 支持多行输入
- ✅ 历史命令回溯
- ✅ 自动补全
- ✅ 性能改进

### 4.4 LSP (cnlsp)

#### 新增能力

- ✅ 跳转到定义
- ✅ 查找引用
- ✅ 符号重命名
- ✅ 代码补全改进

---

## 五、性能优化建议

### 5.1 编译性能

**优化措施**:
1. 使用增量编译（仅编译修改的文件）
2. 启用并行编译（多核CPU）
3. 使用缓存避免重复编译

```bash
# 并行编译
cnc --jobs=4 *.cn -o program
```

### 5.2 运行时性能

**优化建议**:
1. 使用指针遍历替代索引访问
2. 使用inline函数减少调用开销
3. 使用位操作替代除法/取模
4. 合理使用原子操作（避免过度同步）

---

## 六、常见问题 (FAQ)

### Q1: 我的0.9.x代码需要修改吗？

**A**: 几乎不需要。0.9.x到1.0.0没有破坏性变更，代码可以直接在1.0上编译运行。

### Q2: 重新编译后性能会提升吗？

**A**: 是的。1.0的编译器包含多项性能优化，重新编译通常能获得10-30%的性能提升。

### Q3: 1.0支持直接生成二进制吗？

**A**: 1.0仍使用C后端（通过GCC/Clang生成二进制）。直接二进制后端计划在1.x或2.0版本引入。当前方案已经非常成熟稳定，可满足生产使用。

### Q4: 如何利用新的指针特性？

**A**: 指针主要用于：
- 高效的数组遍历
- 数据结构实现（链表、树等）
- 与C库互操作
- 底层内存操作

参考: `examples/syntax/pointers/`

### Q5: 枚举和常量有什么区别？

**A**: 
- **枚举**: 提供类型安全，编译器可检查类型匹配
- **常量**: 只是数值，无类型检查

推荐使用枚举提高代码安全性。

### Q6: Freestanding模式什么时候用？

**A**: 仅在以下场景使用：
- 操作系统内核开发
- 裸机嵌入式开发
- Bootloader开发

普通应用程序不需要此模式。

### Q7: 如何测试迁移后的代码？

**A**: 建议按以下步骤：
1. 重新编译所有代码
2. 运行现有单元测试
3. 运行集成测试
4. 进行性能基准测试
5. 在测试环境充分验证

### Q8: 遇到兼容性问题怎么办？

**A**: 
1. 查看编译器错误信息
2. 参考本迁移指南
3. 查看[新特性指南](CN_Language_1.0_新特性指南.md)
4. 在GitHub Issues报告问题

---

## 七、迁移检查清单

使用以下清单确保迁移完整：

### 7.1 编译环境

- [ ] 安装CN_Language 1.0编译器
- [ ] 更新PATH环境变量
- [ ] 验证编译器版本: `cnc --version`
- [ ] 更新构建脚本（如需要）

### 7.2 代码迁移

- [ ] 备份0.x代码
- [ ] 使用1.0编译器重新编译
- [ ] 修复编译错误（如有）
- [ ] 运行所有测试用例
- [ ] 检查运行时行为

### 7.3 工具链更新

- [ ] 更新cnfmt配置（如有）
- [ ] 更新IDE/编辑器插件
- [ ] 更新cnlsp配置
- [ ] 测试REPL功能

### 7.4 性能验证

- [ ] 运行性能基准测试
- [ ] 对比0.x与1.0性能
- [ ] 验证优化效果
- [ ] 记录性能指标

### 7.5 文档更新

- [ ] 更新README中的版本要求
- [ ] 更新构建文档
- [ ] 更新API文档
- [ ] 更新示例代码

---

## 八、获取帮助

### 8.1 官方资源

- **新特性指南**: [CN_Language 1.0 新特性指南](CN_Language_1.0_新特性指南.md)
- **语法标准**: [CN_Language 语法标准](../design/CN_Language%20语法标准.md)
- **示例代码**: `examples/` 目录

### 8.2 社区支持

- **GitHub Issues**: 报告Bug和功能请求
- **GitHub Discussions**: 技术讨论和问答
- **示例库**: 参考`examples/`中的140+示例

### 8.3 企业支持

如需专业的迁移支持服务，请联系CN_Language开发团队。

---

## 九、版本路线图

### 1.0.x系列（稳定版）
- 1.0.0: 首个稳定版本（当前）
- 1.0.x: Bug修复和小幅改进

### 1.x系列（功能增强）
- 1.1.0: 泛型系统初步支持
- 1.2.0: 更多标准库功能
- 1.3.0: 直接二进制后端实验特性

### 2.0系列（重大演进）
- 2.0.0: 直接二进制后端生产可用
- 面向对象特性
- 高级类型系统

---

## 十、结语

CN_Language 1.0标志着项目进入成熟阶段。我们承诺：

1. ✅ **稳定性**: 严格遵循语义化版本控制
2. ✅ **兼容性**: 保护您的代码投资
3. ✅ **性能**: 持续优化编译和运行性能
4. ✅ **支持**: 提供长期维护和更新

感谢您选择CN_Language！我们期待与您一起构建更好的中文编程生态。

---

**文档版本**: 1.0  
**最后更新**: 2026-01-26  
**维护者**: CN_Language开发团队  
**反馈**: GitHub Issues
