# CN_Language 语言规范草案（核心子集）

> 本文为 CN_Language 的 **语言规范草案（首版）**，重点定义一个可在阶段 1/2 实现的核心语言子集。
> 后续版本可以在不破坏兼容性的前提下扩展。

## 0. 最小可编译子集（v0）

本节定义 **阶段 1** 需要实现的最小可编译子集，仅涵盖：整数变量、算术表达式、简单函数定义/调用以及入口函数 `主程序`，并给出与 `examples/hello_world.cn` 对应的完整样例。

### 0.1 支持的语法元素

- 变量声明：
  - 支持显式整型声明：`整数 a = 1;`
  - 支持使用 `变量` 进行类型推断：`变量 b = 2;`（根据初始值推断为整数）。
- 表达式：
  - 支持整型算术运算：`+ - * /`，以及括号分组：`( )`。
  - 支持使用整数字面量与已有变量进行运算：`a + b * 3`。
- 函数：
  - 支持无显式返回类型的函数定义（实现阶段可将其视为返回整数或 `void` 的简化形式）。
  - 支持有/无参数的函数调用。
- 程序入口：
  - 必须存在名为 `主程序` 的入口函数：`函数 主程序() { ... }`。
- 内建输出：
  - 允许调用内建函数 `打印(字符串)` 输出文本；`打印` 视为内建函数名，而非关键字。

### 0.2 v0 关键字列表

最小可编译子集中，前端必须识别至少以下关键字（中文形式）：

- `函数`：声明函数。
- `返回`：从函数返回值。
- `主程序`：入口函数约定名称（在实现中映射为 C 语言的 `main`）。
- `变量`：启用类型推断的局部变量声明。
- `整数`：整型类型说明符。

> 说明：
> - 字面量 `"你好，世界！"` 等字符串常量依然受 2.4 字面量规则约束，但字符串类型在本阶段仅用于传入 `打印` 等内建函数，不强制要求完整字符串类型系统实现。

### 0.3 暂不支持的特性（超出 v0 范围）

以下能力在本语言规范草案中已有描述，但 **不属于 v0 最小可编译子集**，实现阶段可以暂不支持，以控制范围：

- 复合类型：`数组`、`结构体`，以及指针 `T*`、引用 `T&`；
- 模块系统：`模块`、`导入` 及 `模块名.成员` 访问；
- 控制流语句：`如果 / 否则`、`当`、`循环` 等；
- 其他扩展特性：第 8 章“未来扩展”中列出的能力。

### 0.4 语法概览（EBNF 近似形式）

```ebnf
Program      = { Function } "函数" "主程序" "(" ")" Block ;

Function     = "函数" [Type] Identifier "(" [ParamList] ")" Block ;
Type         = "整数" | "变量" ;               (* v0 仅要求支持整数相关 * )
ParamList    = Param { "," Param } ;
Param        = Type Identifier ;

Block        = "{" { Statement } "}" ;
Statement    = VarDecl ";"
             | Expr ";"
             | ReturnStmt ";" ;

VarDecl      = ("整数" | "变量") Identifier "=" Expr ;
ReturnStmt   = "返回" Expr ;

Expr         = AddExpr ;
AddExpr      = MulExpr { ("+" | "-") MulExpr } ;
MulExpr      = Primary { ("*" | "/") Primary } ;
Primary      = IntegerLiteral
             | StringLiteral
             | Identifier
             | CallExpr
             | "(" Expr ")" ;

CallExpr     = Identifier "(" [ ArgList ] ")" ;
ArgList      = Expr { "," Expr } ;
```

> 实现时可以在解析层面适当放宽/精简上述语法，只要能正确处理 v0 范围内的示例程序即可。

### 0.5 “你好，世界”示例（对应 `examples/hello_world.cn`）

```cn
函数 主程序() {
    打印("你好，世界！");
    返回 0;
}
```

## 1. 总体设计目标

1. 使用 **中文关键字和标识符**，语义贴近 C 语言和常见系统语言，但保持简洁。
2. 适合编写 **系统级程序**：操作系统、运行时、工具等，支持 freestanding 场景。
3. 初期通过编译为 C 代码来复用现有 C 编译器生态。

## 2. 基本词法要素

### 2.1 源文件与编码

1. 源文件扩展名为：`.cn`。
2. 源文件推荐使用 UTF-8 编码（无 BOM），以支持中文标识符和字符串。

### 2.2 标识符

1. 标识符可由以下字符组成：
   - Unicode 字母（含中文）
   - 数字 0-9（首字符不能为数字）
   - 下划线 `_`
2. 标识符区分大小写。
3. 与关键字同拼写的序列不能作为标识符使用。

### 2.3 关键字（核心子集）

当前规范草案中，定义以下关键字（后续可扩展）：

- 函数：声明函数。
- 返回：从函数返回值。
- 变量：类型推断的局部变量声明。
- 整数：整型类型。
- 小数：浮点型类型（暂可视为双精度）。
- 布尔：布尔类型。
- 字符串：字符串类型。
- 数组：数组类型修饰符。
- 结构体：定义结构体类型。
- 常量：常量修饰符，用于声明一旦初始化后不可再赋值的变量。
- 模块：定义模块。
- 导入：导入模块。
- 如果 / 否则：条件分支。
- 当：循环结构（类似 `while`）。
- 循环：循环结构（类似 `for`）。
- 主程序：程序入口函数名。

（注：其他内建函数如 `打印`、`类型名` 等视为标准库/内建函数，而非关键字。）

### 2.3.1 预留关键字

以下关键字已在词法层识别，但**仅为预留**，目前版本不在语法、语义和后端实现范围内：

- **类型系统扩展**：
  - 静态：静态修饰符（类似 C 的 `static`）

- **面向对象特性**：
  - 类：类定义（类似 C++ 的 `class`）
  - 接口：接口定义（类似 Java 的 `interface`）
  - 虚拟：虚函数声明（类似 C++ 的 `virtual`）
  - 重写：方法重写标识（类似 C++ 的 `override`）
  - 抽象：抽象类/方法声明（类似 Java 的 `abstract`）

- **访问控制**：
  - 公开：公有访问（类似 C++ 的 `public`）
  - 私有：私有访问（类似 C++ 的 `private`）
  - 保护：保护访问（类似 C++ 的 `protected`）

- **泛型与命名空间**：
  - 模板：泛型/模板定义（类似 C++ 的 `template`）
  - 命名空间：命名空间定义（类似 C++ 的 `namespace`）

**使用约束**：
- 这些关键字在当前版本中不能用于任何语法结构。
- 编译器在遇到这些关键字时会报告错误：「此特性为预留特性，当前版本暂不支持」。
- 标识符不能使用这些预留关键字命名。

**未来计划**：
- 这些特性将在后续版本（阶段 8 及以后）中逐步实现。
- 每类特性都将有完整的 AST、语义分析和后端支持。
- 详细设计参见开发计划相关章节。

### 2.4 字面量

1. 整数字面量：
   - 十进制：`0`、`123`、`4567`；
   - 未来可扩展十六进制、二进制（本草案不强制定义）。

2. 小数字面量：
   - 使用十进制小数点：`1.0`、`3.14`、`0.5`；
   - **当前实现状态**：
     - ✅ 支持标准十进制浮点格式（如 `3.14`、`0.5`）
     - ✅ 对应 C 语言的 `double` 类型（64位双精度浮点）
     - ✅ 支持在表达式中与整数混合运算（自动类型提升）
     - ❌ 暂不支持科学计数法（如 `1.5e10`、`2.3E-5`）
     - ❌ 暂不支持十六进制浮点表示（如 `0x1.2p3`）
     - ❌ 暂不支持后缀标记（如 `3.14f`、`2.0L`）
   - **未来扩展**：可能添加科学计数法、单精度标记等支持。

3. 字符串字面量：
   - 使用双引号包围：`"你好"`；
   - 字符串内部可以包含中文和转义字符（如 `"\n"`）。

4. 布尔字面量：
   - 草案建议使用：`真`、`假`（后续可在实现时调整）。

### 2.5 注释

1. 行注释使用：`// 注释内容`。
2. 块注释使用：`/* 注释内容 */`。

## 3. 类型系统（核心子集）

### 3.1 基本类型

1. 整数：表示有符号整数（具体位宽由实现决定，建议对应 C 的 `long long` 以保证 64 位）。
2. 小数：表示浮点数（建议对应 C 的 `double`）。
3. 布尔：表示逻辑真/假（对应 C 的 `_Bool`）。
4. 字符串：表示不可变或逻辑上不可变的字符串（对应 C 的 `char*`，后续可扩展为带长度的结构体）。

### 3.2 指针与复合类型

1. 指针：
   - 使用 `T*` 表示指向 `T` 的指针：`整数* 指针`；
   - 支持多级指针：`整数** 二级指针`、`整数*** 三级指针`；
   - 支持解引用：`*指针`；
   - 对应 C 的 `T*` 类型。

2. 数组：
   - 使用 `数组 T` 表示元素类型为 `T` 的数组：`数组 整数 列表`；
   - 支持数组字面量：`[1, 2, 3]`；
   - 支持索引访问：`列表[0]`；
   - 支持内建函数获取数组长度，两种调用方式：
     - 函数风格：`长度(数组)` 
     - 方法风格：`数组.长度()` 
     - 两种方式等价，都返回 `整数` 类型
     - 同样适用于字符串：`长度(字符串)` 或 `字符串.长度()`
   - **语法形式**：
     - 显式类型声明：`数组 整数 名称 = [1, 2, 3];`
     - 显式类型声明（元素类型可选）：`数组 名称 = [1, 2, 3];` （从字面量推断）
     - 类型推断：`变量 名称 = [1, 2, 3];`
   - **运行时表示**：
     - 对应运行时结构体 `CnArray`，包含：
       - `data`: 数据指针（`void*`）
       - `length`: 数组长度（`size_t`）
       - `capacity`: 容量（`size_t`）
       - `element_size`: 元素大小（`size_t`）
     - 提供运行时函数：`cn_rt_array_new`、`cn_rt_array_get`、`cn_rt_array_set`、`cn_rt_array_length`
   - **当前实现限制**：
     - ✅ 支持一维数组
     - ✅ 支持基础类型数组（整数、小数、布尔、字符串）
     - ❌ 多维数组需通过嵌套数组实现（如 `数组 数组 整数`）
     - ❌ 暂不支持固定长度数组类型声明（如 `整数[10]`）

3. 结构体：
   - 使用 `结构体 名称 { 字段列表 }` 定义结构体类型；
   - 字段声明格式：`类型 字段名;`；
   - 支持结构体字面量：`结构体名 { 字段1: 值1, 字段2: 值2 }`；
   - 支持成员访问：`.` 运算符（值访问）和 `->` 运算符（指针访问）。

4. 枚举：
   - 使用 `枚举 名称 { 成员列表 }` 定义枚举类型；
   - 枚举成员默认从 0 开始自动递增，也可显式赋值；
   - 枚举成员在作用域内可直接使用。

### 3.3 类型组合与参数/字段支持

**当前实现已支持的类型组合：**

1. **函数参数类型**：
   - 基础类型：`整数`、`小数`、`布尔`、`字符串`
   - 数组类型：`数组 整数`、`数组 小数`、`数组 字符串`、`数组 布尔`
   - 指针类型：`整数*`、`小数*`、`布尔*`、`字符串*`
   - 多级指针：`整数**`、`小数***` 等任意层级
   - 自定义类型：结构体类型名（作为类型标识符）

2. **结构体字段类型**：
   - 基础类型：`整数`、`小数`、`布尔`、`字符串`
   - 数组类型：`数组 整数`、`数组 小数`、`数组 字符串`、`数组 布尔`
   - 指针类型：`整数*`、`小数*`、`布尔*`、`字符串*`
   - 多级指针：`整数**`、`小数***` 等任意层级
   - 自定义类型：其他结构体类型名

3. **变量声明类型**：
   - 同函数参数类型支持范围
   - 额外支持 `变量` 关键字进行类型推断

**类型解析统一实现：**

解析器通过统一的 `parse_type` 函数处理所有类型解析，确保在函数参数、结构体字段、变量声明等场景下的类型支持一致性。

### 3.4 变量声明与类型推断

1. 显式类型声明：

   ```
   整数 年龄 = 30;
   字符串 姓名 = "张三";
   数组 数字列表 = [1, 2, 3];
   ```

2. 使用 `变量` 进行类型推断：

   ```
   变量 和 = 0;          // 根据初始值推断为整数
   变量 文本 = "你好";   // 推断为字符串
   ```

## 4. 表达式与语句

### 4.1 表达式

1. 支持基本算术运算：`+`、`-`、`*`、`/`、`%`；
2. 支持比较运算：`==`、`!=`、`<`、`<=`、`>`、`>=`；
3. 支持逻辑运算：`&&`、`||`、`!`；
4. 支持字符串拼接：使用 `+` 连接字符串和其他可转换为字符串的值（具体转换规则由运行时决定）。

### 4.2 赋值语句

1. 使用 `=` 进行赋值：

   ```
   变量 i = 0;
   i = i + 1;
   ```

### 4.3 条件语句

1. `如果/否则` 语句：

   ```
   如果 (条件) {
       // 分支1
   } 否则 {
       // 分支2
   }
   ```

2. 可以只有 `如果` 部分，也可以带 `否则` 部分；
3. 条件必须为布尔类型。

### 4.4 循环语句

1. 使用 `当` 实现类似 `while` 的循环：

   ```
   当 (i < 长度) {
       // 循环体
       i = i + 1;
   }
   ```

2. 条件必须为布尔类型。

## 5. 函数与程序结构

### 5.1 函数声明与定义

1. 基本形式：

   ```
   函数 返回类型 函数名(参数列表) {
       // 函数体
   }
   ```

2. 示例：

   ```
   函数 整数 加(整数 a, 整数 b) {
       返回 a + b;
   }

   函数 变量 乘(变量 a, 变量 b) {
       返回 a * b;
   }
   ```

3. 函数可以无返回值，此时返回类型可省略或使用特定关键字（草案阶段可允许“省略返回类型表示无返回”方案，后续可细化）。

### 5.2 参数与返回

1. 参数列表使用逗号分隔：`(类型1 名1, 类型2 名2)`；
2. 支持值传递、指针参数、引用参数；
3. 使用 `返回` 语句返回值：`返回 表达式;`。

### 5.3 主程序入口

1. 入口函数约定名为：`主程序`：

   ```
   函数 主程序() {
       // 程序入口逻辑
       返回 0;
   }
   ```

2. 编译器在生成 C 代码时，将 `主程序` 映射为 C 的 `main` 函数。

## 6. 模块系统

### 6.1 模块定义

1. 使用 `模块 名字 { ... }` 定义模块：

   ```
   模块 数学工具 {
       函数 整数 加(整数 a, 整数 b) {
           返回 a + b;
       }

       整数 圆周率近似值 = 3;
   }
   ```

2. 模块内部可以定义函数、常量等。

3. **模块变量初始化规则**：
   - 模块变量支持字面量初始化：
     ```
     模块 配置 {
         整数 版本 = 1;  // 字面量初始化
         字符串 名称 = "CN_Language";
     }
     ```
   - 模块变量也支持表达式初始化：
     ```
     模块 数学 {
         整数 基数 = 10;
         整数 结果 = 1 + 2;  // 表达式初始化
         整数 复杂值 = (10 + 5) * 2;
     }
     ```
   - 初始化顺序：
     - 字面量初始化在编译时完成
     - 表达式初始化在程序启动时执行（在 `main` 函数开始时）
     - 模块初始化函数会按模块定义顺序自动调用
   - 当前限制：
     - 暂不支持引用其他模块变量的初始化
     - 暂不检测循环依赖

4. **模块成员支持**：
   - 模块内可以定义变量和函数
   - 函数可以访问模块内的变量
   - 支持函数参数和返回值

### 6.2 模块可见性控制

1. **访问修饰符**：
   - `公开:` — 公开成员，可以从模块外部访问
   - `私有:` — 私有成员，仅模块内部可访问

2. **语法示例**：
   ```
   模块 配置 {
       公开: 整数 版本 = 1;        // 可以外部访问
       私有: 整数 内部标志 = 0;  // 仅内部使用
       公开: 函数 整数 获取版本() {
           返回 版本;
       }
   }
   ```

3. **默认可见性**：
   - 模块成员默认为 `私有`
   - 必须显式使用 `公开:` 声明公开成员

4. **访问控制检查**：
   - 编译器会检查访问权限
   - 尝试访问私有成员会报错

### 6.3 模块导入与使用

1. **全量导入（自动导入）**：
   
   使用 `导入 模块名;` 导入模块的所有公开成员：
   
   ```
   导入 数学工具;
   
   函数 主程序() {
       变量 结果 = 加(1, 2);  // 直接使用，无需模块名前缀
       返回 0;
   }
   ```
   
   - 导入后，模块的所有公开成员都可以直接使用
   - 如果名称冲突，编译器会报错

2. **选择性导入（按需导入）**：
   
   使用 `导入 模块名 { 成员名1, 成员名2 };` 导入指定成员：
   
   ```
   模块 工具 {
       公开: 整数 值A = 10;
       公开: 整数 值B = 20;
       公开: 函数 整数 函数A() { 返回 1; }
   }
   
   导入 工具 { 值A, 函数A };
   
   函数 主程序() {
       变量 a = 值A;           // 可以直接使用
       变量 b = 函数A();       // 可以直接调用
       变量 c = 工具.值B;      // 未导入的需要前缀
       返回 0;
   }
   ```
   
   - 只有指定的成员可以直接使用
   - 其他成员仍然可以通过 `模块名.成员名` 访问
   - 只能导入公开成员

3. **模块别名**：
   
   使用 `导入 模块名 为 别名;` 为模块赋予别名：
   
   ```
   模块 非常长的模块名称 {
       公开: 整数 数据 = 100;
   }
   
   导入 非常长的模块名称 为 短名;
   
   函数 主程序() {
       变量 x = 短名.数据;  // 使用别名访问
       返回 0;
   }
   ```
   
   - 别名只是模块的另一个名字
   - 使用别名时不会自动导入成员
   - 仍然需要使用 `别名.成员名` 访问

4. **直接访问（无导入）**：
   
   在同一文件内，可以直接使用 `模块名.成员名` 访问：
   
   ```
   模块 数学工具 {
       公开: 函数 整数 加(整数 a, 整数 b) {
           返回 a + b;
       }
   }
   
   函数 主程序() {
       变量 结果 = 数学工具.加(1, 2);  // 直接访问
       返回 0;
   }
   ```

### 6.4 模块系统实现状态

当前 CN_Language 模块系统已实现以下功能：

- ✅ 模块定义和作用域管理
- ✅ 模块成员访问（`模块名.成员名`）
- ✅ 模块内函数定义和调用
- ✅ 模块可见性控制（`公开`/`私有`）
- ✅ 模块变量的复杂初始化（表达式）
- ✅ 全量导入（自动导入）
- ✅ 选择性导入（按需导入）
- ✅ 模块别名
- ✅ 名称冲突检测

未来扩展方向：
- 跨文件模块导入
- 模块依赖管理
- 模块版本控制

## 7. 运行时约束（核心子集）

1. 语言依赖一个最小运行时提供：
   - 字符串管理与拼接；
   - 基本 I/O（如 `打印` 函数）；
   - 数组的基本操作与长度获取（如 `长度()`）。

2. 在 freestanding 模式下：
   - 不依赖系统标准库文件 I/O；
   - `打印` 等接口需要由运行时适配到具体平台输出（串口、屏幕缓冲区等）。

3. 错误处理：
   - 如除数为零等运行时错误，规范建议使用 **打印错误信息 + 返回约定值** 的方式；
   - 后续可扩展异常/错误类型系统。

## 8. 未来扩展（非本阶段必需）

### 8.1 已预留但未实现的高级特性

以下特性的大部分关键字已在词法层预留（见 2.3.1），语法、语义和后端尚未实现或仅有部分实现：

1. **面向对象编程**：
   - 类（`类`）：支持数据封装、继承、多态
   - 接口（`接口`）：定义类型契约
   - 虚函数（`虚拟`）：支持运行时多态
   - 方法重写（`重写`）：显式标注覆盖基类方法
   - 抽象类（`抽象`）：定义抽象基类和抽象方法

2. **访问控制**：
   - 公开（`公开`）、私有（`私有`）、保护（`保护`）：控制成员可见性

3. **高级类型特性**：
   - 泛型/模板（`模板`）：支持参数化类型
   - 常量（`常量`）：不可变性约束；当前版本已支持用于变量声明（常量变量），后续可能扩展到字段、参数等
   - 静态（`静态`）：类级别成员

4. **命名空间**：
   - 命名空间（`命名空间`）：组织代码，避免命名冲突

### 8.2 其他潜在扩展

1. 高阶函数与闭包语法糖；
2. 更丰富的集合类型（映射、集合等）；
3. 并发原语（协程、通道等）；
4. 增强的模块/包管理（跨文件、跨工程依赖）。

### 8.3 原子操作与锁机制（阶段8已实现）

为支持系统编程和并发控制，CN_Language 提供了原子操作和锁机制的运行时支持。这些功能通过运行时库提供，无需特殊语法支持。

#### 8.3.1 原子操作

**设计目标**：
- 提供无锁的原子操作，支持多线程安全访问共享变量
- 支持多种内存顺序模型，平衡性能与一致性
- 跨平台实现，在Windows、Linux、macOS等平台上提供一致接口

**支持的原子类型**：
1. **CnAtomic32**：32位原子整数
2. **CnAtomic64**：64位原子整数
3. **CnAtomicPtr**：原子指针

**原子操作接口**：
- `cn_rt_atomic32_load()`：原子读取
- `cn_rt_atomic32_store()`：原子写入
- `cn_rt_atomic32_exchange()`：原子交换
- `cn_rt_atomic32_compare_exchange()`：原子比较并交换（CAS）
- `cn_rt_atomic32_fetch_add()`：原子加法（返回旧值）
- `cn_rt_atomic32_fetch_sub()`：原子减法（返回旧值）
- `cn_rt_atomic32_fetch_or()`：原子按位或
- `cn_rt_atomic32_fetch_and()`：原子按位与
- `cn_rt_atomic32_fetch_xor()`：原子按位异或

**内存顺序**：
- `CN_MEMORY_ORDER_RELAXED`：松弛顺序，最弱保证，性能最高
- `CN_MEMORY_ORDER_ACQUIRE`：获取顺序，用于读操作
- `CN_MEMORY_ORDER_RELEASE`：释放顺序，用于写操作
- `CN_MEMORY_ORDER_SEQ_CST`：顺序一致性，最强保证，性能较低

**使用示例**（C代码层面）：
```c
// 声明原子变量
CnAtomic32 counter;
cn_rt_atomic32_init(&counter, 0);

// 原子加法
int32_t old_val = cn_rt_atomic32_fetch_add(&counter, 1, CN_MEMORY_ORDER_SEQ_CST);

// 原子CAS
int32_t expected = 10;
int32_t desired = 20;
if (cn_rt_atomic32_compare_exchange(&counter, &expected, desired, CN_MEMORY_ORDER_SEQ_CST)) {
    // CAS成功
}
```

#### 8.3.2 锁机制

**互斥锁（Mutex）**：
- 用于保护临界区，确保同一时刻只有一个线程访问共享资源
- 支持可重入性，同一线程可多次加锁
- 提供阻塞式加锁和非阻塞式尝试加锁

**接口**：
- `cn_rt_mutex_init()`：初始化互斥锁
- `cn_rt_mutex_lock()`：加锁（阻塞）
- `cn_rt_mutex_trylock()`：尝试加锁（非阻塞）
- `cn_rt_mutex_unlock()`：解锁
- `cn_rt_mutex_destroy()`：销毁互斥锁

**自旋锁（Spinlock）**：
- 用于保护短时间临界区，通过自旋等待避免线程切换开销
- 适合临界区执行时间很短的场景
- 不支持可重入

**接口**：
- `cn_rt_spinlock_init()`：初始化自旋锁
- `cn_rt_spinlock_lock()`：加锁（自旋等待）
- `cn_rt_spinlock_trylock()`：尝试加锁（非阻塞）
- `cn_rt_spinlock_unlock()`：解锁
- `cn_rt_spinlock_destroy()`：销毁自旋锁

**读写锁（RWLock）**：
- 支持多读者-单写者模式
- 多个线程可同时持有读锁
- 写锁是独占的，与读锁和其他写锁互斥

**接口**：
- `cn_rt_rwlock_init()`：初始化读写锁
- `cn_rt_rwlock_read_lock()`：读锁定
- `cn_rt_rwlock_try_read_lock()`：尝试读锁定
- `cn_rt_rwlock_read_unlock()`：读解锁
- `cn_rt_rwlock_write_lock()`：写锁定
- `cn_rt_rwlock_try_write_lock()`：尝试写锁定
- `cn_rt_rwlock_write_unlock()`：写解锁
- `cn_rt_rwlock_destroy()`：销毁读写锁

**使用示例**（C代码层面）：
```c
// 互斥锁保护临界区
CnMutex mutex;
cn_rt_mutex_init(&mutex);

cn_rt_mutex_lock(&mutex);
// 临界区代码
shared_counter++;
cn_rt_mutex_unlock(&mutex);

// 读写锁
CnRwLock rwlock;
cn_rt_rwlock_init(&rwlock);

// 读者
cn_rt_rwlock_read_lock(&rwlock);
int value = shared_data;
cn_rt_rwlock_read_unlock(&rwlock);

// 写者
cn_rt_rwlock_write_lock(&rwlock);
shared_data = new_value;
cn_rt_rwlock_write_unlock(&rwlock);
```

#### 8.3.3 实现特性

**跨平台支持**：
- Windows：使用 `InterlockedXxx` 系列API和内存屏障
- Linux/macOS：使用 GCC/Clang 的 `__atomic_xxx` 内建函数
- 支持 x86_64 和 ARM64 架构

**性能优化**：
- 使用 CPU pause 指令优化自旋锁性能
- 支持不同内存顺序，允许根据场景选择合适的内存模型
- 避免不必要的内存屏障，减少性能开销

**线程安全**：
- 所有原子操作保证线程安全
- 锁机制正确处理竞态条件
- 支持可重入互斥锁，避免死锁

**Freestanding 模式支持**：
- 所有同步原语在 freestanding 模式下可用
- 适用于操作系统内核开发和嵌入式系统
- 不依赖标准库的线程API

---

本语言规范草案主要面向 **阶段 1（前端基础）和阶段 2（语义分析）** 的实现需要。
后续如有语法或语义变更，应同步更新本文档，并在测试规范中增加相应测试要求。
