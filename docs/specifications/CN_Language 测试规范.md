# CN_Language 测试规范（首版）

> 本规范定义 CN_Language 项目的测试分层、目录组织、命名约定和覆盖要求，
> 适用于编译器、运行时、工具链以及示例程序的测试工作。

## 1. 测试分层与目录组织

### 1.1 测试分层

1. **单元测试（Unit Tests）**：
   - 覆盖各模块内部的函数/结构，关注小范围、可控输入输出；
   - 示例：词法分析器的 Token 解析、类型检查函数等。

2. **集成测试（Integration Tests）**：
   - 覆盖编译流水线的多个阶段组合：前端 + 语义 + IR + 后端 + 运行时；
   - 示例：对 `examples/hello_world.cn`、`examples/function_examples.cn` 等程序执行编译，并验证输出或返回值。

3. **系统测试（System Tests）**：
   - 覆盖 OS 开发场景、完整工具链行为；
   - 示例：使用 CN_Language 编写简单内核，在模拟器中启动并验证输出。

### 1.2 目录结构

1. 顶层测试目录：`tests/`
2. 子目录划分：
   - 单元测试：`tests/unit/<module>/`
   - 集成测试：`tests/integration/<scenario>/`
   - 系统测试：`tests/system/<scenario>/`

3. 示例：
   - `tests/unit/frontend/`：前端（lexer/parser/ast）的单元测试；
   - `tests/unit/semantics/`：符号表、类型系统、语义检查单元测试；
   - `tests/unit/runtime/`：运行时和标准库的单元测试；
   - `tests/integration/compiler/`：编译器完整编译流程的集成测试；
   - `tests/integration/os/`：与 OS 相关的编译/启动集成测试；
   - `tests/system/`：整体工具链、命令行工具行为。

## 2. 测试框架与执行方式

1. 构建系统中必须提供统一的 `test` 目标：
   - 使用 CMake 时，通过 `enable_testing()` + `add_test()` 注册所有测试；
   - 使用 `ctest` 作为默认测试执行入口：

     ```sh
     cmake --build .
     ctest
     ```

2. 单元测试可以：
   - 采用简单 C 单元测试框架；
   - 或自研轻量级测试库，但应满足：
     - 独立可执行；
     - 返回值为 0 表示通过，非 0 表示失败；
     - 可打印失败信息，便于调试。

3. 集成测试可以：
   - 通过 C 程序驱动，也可以通过脚本（如 Python、Shell 等）封装为 `ctest`；
   - 测试过程包含：调用 `cnc` 编译 `.cn` 文件 → 运行生成的程序 → 检查输出/返回值/生成文件。

## 3. 单元测试规范

### 3.1 编写原则

1. 每个公开函数或关键内部函数，原则上应有至少一个对应的单元测试用例。
2. 对于复杂算法和状态机（如词法分析、语义分析、IR 优化），应编写针对边界条件、错误输入的测试。
3. 出现 bug 时，必须先添加/更新对应的单元测试，再修复实现，确保回归不再出现。

### 3.2 命名约定

1. 单元测试可执行文件命名：
   - 使用 `test_<module>_<topic>` 风格，例如：
     - `test_frontend_lexer`
     - `test_semantics_types`

2. 测试函数命名：
   - 使用 `test_<行为/场景>` 命名，例如：

     ```c
     void test_lexer_integer_literal(void);
     void test_lexer_string_literal_with_unicode(void);
     ```

3. CMake 中的测试名（`add_test(NAME ...)`）：
   - 建议与可执行文件名保持一致，或加上前缀：

     ```cmake
     add_test(NAME unit_frontend_lexer
              COMMAND test_frontend_lexer)
     ```

### 3.3 覆盖要求（单元测试）

1. 前端模块：
   - 词法分析：覆盖整数字面量、字符串字面量、中文关键字、标识符、注释、错误输入等；
   - 语法分析：覆盖函数定义、`如果/否则`、`当` 循环、模块/结构体定义等核心语法；
   - **字面量测试要求**：
     - 整数字面量：十进制、十六进制、二进制、八进制的解析测试
     - 整数后缀：`L`、`LL`、`U`、`UL`、`ULL` 等后缀的识别测试
     - 浮点数字面量：标准十进制、科学计数法的解析测试
     - 浮点数后缀：`f`、`F` 后缀的识别测试
     - 边界情况：最大/最小值、特殊值（如0、负数）的测试
     - 错误格式：无效的进制表示、错误的后缀组合等

2. 语义模块：
   - 符号表与作用域：变量/函数/模块的定义与查找、嵌套作用域；
   - 类型系统：整数、小数、布尔、字符串、数组、指针、引用、结构体的基本类型检查；
   - **字面量类型测试要求**：
     - 整数类型：验证不同后缀生成正确的类型（`CN_TYPE_INT32`、`CN_TYPE_INT64` 等）
     - 浮点类型：验证 `f` 后缀生成 `CN_TYPE_FLOAT32`，无后缀生成 `CN_TYPE_FLOAT`
     - 类型兼容性：测试整数类型互相兼容、浮点类型互相兼容、整数到浮点的转换

3. 运行时模块：
   - 字符串操作、数组长度/访问等运行时接口；
   - 错误情况（如除数为零）必须有测试覆盖。

4. Freestanding 模式检查：
   - 禁止函数检查：覆盖文件 I/O、控制台输入、字符串高级操作、进程管理、网络操作等禁止函数；
   - 允许函数检查：覆盖打印函数、基础字符串操作、内存管理、数学函数等允许函数；
   - 模式开关测试：验证未启用 freestanding 模式时不进行检查；
   - 诊断信息测试：验证错误信息的准确性和可读性。

## 4. 集成测试规范

### 4.1 编写原则

1. 集成测试应尽量使用 **实际示例程序**（例如 `examples/hello_world.cn`、`examples/function_examples.cn`、`examples/test_module.cn`）。
2. 每当添加新的语言特性或模块时，应增加至少一个集成测试，覆盖：
   - 解析 → 语义分析 → IR → 后端 → 运行时 的完整链路（在当前阶段可适当简化）。

### 4.2 典型集成测试场景

1. “能编译并运行”的正向场景：
   - 编译示例程序，运行生成的可执行文件；
   - 验证程序的标准输出或返回值符合预期。

2. “错误处理”的负向场景：
   - 语法错误：缺少括号、缺少 `返回` 等；
   - 语义错误：未定义变量、类型不匹配、函数参数不匹配等；
   - 运行时错误：除数为零等（若约定在编译期不检查）。

3. OS/freestanding 场景（后期阶段）：
   - 编译内核样例，生成可在模拟器（如 QEMU）中启动的镜像；
   - 通过脚本启动模拟器并检查串口输出或屏幕输出。

4. Freestanding 模式编译场景：
   - 正向场景：使用 `--freestanding` 选项编译仅包含允许函数的程序，验证编译成功且不链接宿主运行时库；
   - 负向场景：使用 `--freestanding` 选项编译包含禁止函数的程序，验证编译失败并输出清晰的错误诊断；
   - 编译命令验证：检查生成的编译命令包含 `-ffreestanding -nostdlib` 等标志（GCC/Clang）；
   - 链接验证：确认 freestanding 模式下不链接 `libcn_runtime.a`。

### 4.3 结果判定

1. 每个集成测试应有明确的 **预期行为**：
   - 退出码；
   - 标准输出/错误输出；
   - 生成文件存在性和内容。

2. 集成测试失败时，应能打印有助于诊断的问题信息：
   - 如编译命令、源文件、编译日志片段等。

## 5. 系统测试规范

### 5.1 目标

1. 验证 **整体工具链** 的行为：`cnc` 命令及相关工具；
2. 验证在目标平台上的构建、安装、运行流程（包括 OS 场景）。

### 5.2 示例

1. `cnc build` 能够对指定项目进行完整构建；
2. `cnc compile --emit-c` 生成的 C 代码可以通过指定 C 编译器编译通过并运行；
3. freestanding 内核示例可以在指定模拟器中启动并输出约定内容。

## 6. 测试流程与策略

### 6.1 开发流程中的测试要求

1. 新增功能：
   - 必须同时添加或更新相关的单元测试和（必要时）集成测试；
   - 不允许无测试的功能代码合并到主分支。

2. 修复 Bug：
   - 必须先编写/补充能 **复现该 Bug** 的测试用例；
   - 修复完成后，该测试应稳定通过，并防止回归。

3. 重构：
   - 在不改变外部行为的前提下重构代码时，应确保现有测试全部通过；
   - 若行为有意改变，需同步更新规范与测试。

### 6.2 覆盖率与质量指标

1. 关键模块（前端、语义、IR、后端、运行时核心部分）应保持 **较高测试覆盖率**（具体数值可后续通过工具统计再制定正式指标）；
2. 对于风险较高或复杂度较高的模块（如类型系统、优化 Pass），应优先增加测试覆盖。

## 7. 持续集成与自动化

1. 建议在 CI（如 GitHub Actions）中集成：
   - 配置编译环境；
   - 执行 `cmake` 配置、构建和 `ctest`；
   - 在 PR 或主分支 push 时自动运行全部测试。

2. 对于长时间运行或需要模拟器的测试（如 OS 场景），可单独配置慢速测试集，在夜间或手动触发。

## 8. Freestanding 模式测试约束

### 8.1 测试目标

Freestanding 模式用于 OS 内核开发和嵌入式场景，测试需要确保：
1. 编译器正确检测并拒绝依赖宿主环境的函数调用；
2. 生成的代码不链接标准宿主运行时库；
3. 允许使用的核心函数在 freestanding 环境下正常工作。

### 8.2 禁止函数列表（必须测试覆盖）

以下函数在 freestanding 模式下应被编译器检测并报错：

1. **文件 I/O 函数**：
   - `文件打开`、`文件关闭`、`文件读取`、`文件写入`、`文件是否结束`
   - 理由：依赖文件系统，内核环境不可用

2. **控制台输入函数**：
   - `读取行`、`读取整数`
   - 理由：依赖标准输入，需使用内核提供的输入机制

3. **字符串高级操作**：
   - `截取`、`去空格`、`格式化`
   - 理由：依赖动态内存分配，需显式使用静态分配器

4. **进程管理函数**（预留）：
   - `进程创建`、`进程等待`
   - 理由：依赖操作系统进程管理

5. **网络操作函数**（预留）：
   - `套接字打开`、`套接字连接`
   - 理由：依赖网络协议栈

### 8.3 允许函数列表

以下函数在 freestanding 模式下应能正常使用：

1. **基础打印函数**（需注册内核 I/O 回调）：
   - `打印`、`打印整数`、`打印布尔`、`打印换行`

2. **基础字符串操作**：
   - `连接`、`长度`、`比较`、`查找索引`

3. **内存管理**（使用静态分配器）：
   - `数组分配`、`数组长度`、`数组释放`

4. **数学函数**：
   - `绝对值`、`平方根`、`幂运算`

### 8.4 测试用例要求

#### 8.4.1 单元测试

1. **函数名匹配测试**：
   - 测试 `cn_fs_check_forbidden_function()` 能正确识别所有禁止函数的中文名称；
   - 测试 `cn_fs_check_allowed_function()` 能正确识别所有允许函数的中文名称。

2. **AST 遍历测试**：
   - 测试在函数调用表达式中检测禁止函数；
   - 测试在嵌套表达式中检测禁止函数（如函数参数）。

3. **诊断信息测试**：
   - 验证每个禁止函数都有清晰的中文错误描述；
   - 验证错误信息包含函数不可用的原因和替代建议。

4. **模式开关测试**：
   - 验证 `enable_check` 参数为 `false` 时不进行检查；
   - 验证 `enable_check` 参数为 `true` 时正确检查。

#### 8.4.2 集成测试

1. **正向编译测试**：
   - 编译仅使用允许函数的程序，加 `--freestanding` 选项；
   - 验证编译成功，返回码为 0；
   - 验证编译命令不包含 `libcn_runtime.a`；
   - 验证编译命令包含 `-ffreestanding -nostdlib`（非 MSVC）。

2. **负向编译测试**：
   - 编译包含禁止函数的程序，加 `--freestanding` 选项；
   - 验证编译失败，返回码非 0；
   - 验证输出包含 "Freestanding 模式检查失败"；
   - 验证输出包含具体的错误诊断信息。

3. **混合模式测试**：
   - 同一程序在不加 `--freestanding` 时编译成功；
   - 加 `--freestanding` 时编译失败；
   - 验证错误诊断准确指出违规函数。

#### 8.4.3 系统测试（待实施）

1. **内核启动测试**：
   - 使用 freestanding 模式编译最小内核示例；
   - 配合启动代码和链接脚本生成内核镜像；
   - 在 QEMU/Bochs 中启动并验证串口输出。

2. **内核 I/O 回调测试**：
   - 注册内核 I/O 回调函数；
   - 验证 `打印` 等函数通过回调输出到串口/屏幕。

### 8.5 测试数据与示例

#### 8.5.1 测试示例文件位置

- 单元测试：`tests/unit/freestanding_check_test.c`
- 集成测试：`tests/integration/compiler/` 中的 freestanding 相关测试
- 示例程序：
  - `examples/test_freestanding_allowed.cn`（允许函数示例）
  - `examples/test_freestanding_violation.cn`（禁止函数示例）

#### 8.5.2 最小测试覆盖清单

每个禁止函数类别至少需要 1 个测试用例：
- [ ] 文件 I/O 检测测试
- [ ] 控制台输入检测测试
- [ ] 字符串高级操作检测测试
- [ ] 允许函数通过测试（打印、基础字符串、内存、数学各 1 个）
- [ ] 模式开关测试
- [ ] 编译命令生成测试
- [ ] 链接库排除测试

### 8.6 错误诊断格式

Freestanding 模式错误应遵循统一格式：

```
Freestanding 模式检查失败
错误(代码): 文件名:行:列: <函数名>操作在 freestanding 模式下不可用（<原因>）
```

示例：
```
Freestanding 模式检查失败
错误(0): test.cn:2:10: 文件打开操作在 freestanding 模式下不可用（无文件系统）
```

### 8.7 持续维护要求

1. **新增禁止函数时**：
   - 必须在 `freestanding_check.h` 中添加枚举值；
   - 必须在 `freestanding_check.c` 中添加函数名匹配和描述；
   - 必须添加对应的单元测试用例。

2. **新增允许函数时**：
   - 必须验证该函数在 freestanding 环境下确实可用；
   - 必须添加对应的测试用例；
   - 必须在运行时库中提供 freestanding 版本实现。

3. **回归测试**：
   - 每次修改 freestanding 检查逻辑后，必须运行完整测试套件；
   - 确保所有现有测试仍然通过。

---

本测试规范为首版，主要服务于 **阶段 0–2** 的编译器实现与验证工作。
后续可根据实际经验，对覆盖要求和流程进行细化和量化，并在此基础上扩展静态检查、模糊测试等高级测试手段。
