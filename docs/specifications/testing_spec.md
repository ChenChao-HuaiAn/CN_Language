# CN_Language 测试规范（首版）

> 本规范定义 CN_Language 项目的测试分层、目录组织、命名约定和覆盖要求，
> 适用于编译器、运行时、工具链以及示例程序的测试工作。

## 1. 测试分层与目录组织

### 1.1 测试分层

1. **单元测试（Unit Tests）**：
   - 覆盖各模块内部的函数/结构，关注小范围、可控输入输出；
   - 示例：词法分析器的 Token 解析、类型检查函数等。

2. **集成测试（Integration Tests）**：
   - 覆盖编译流水线的多个阶段组合：前端 + 语义 + IR + 后端 + 运行时；
   - 示例：对 `examples/hello_world.cn`、`examples/function_examples.cn` 等程序执行编译，并验证输出或返回值。

3. **系统测试（System Tests）**：
   - 覆盖 OS 开发场景、完整工具链行为；
   - 示例：使用 CN_Language 编写简单内核，在模拟器中启动并验证输出。

### 1.2 目录结构

1. 顶层测试目录：`tests/`
2. 子目录划分：
   - 单元测试：`tests/unit/<module>/`
   - 集成测试：`tests/integration/<scenario>/`
   - 系统测试：`tests/system/<scenario>/`

3. 示例：
   - `tests/unit/frontend/`：前端（lexer/parser/ast）的单元测试；
   - `tests/unit/semantics/`：符号表、类型系统、语义检查单元测试；
   - `tests/unit/runtime/`：运行时和标准库的单元测试；
   - `tests/integration/compiler/`：编译器完整编译流程的集成测试；
   - `tests/integration/os/`：与 OS 相关的编译/启动集成测试；
   - `tests/system/`：整体工具链、命令行工具行为。

## 2. 测试框架与执行方式

1. 构建系统中必须提供统一的 `test` 目标：
   - 使用 CMake 时，通过 `enable_testing()` + `add_test()` 注册所有测试；
   - 使用 `ctest` 作为默认测试执行入口：

     ```sh
     cmake --build .
     ctest
     ```

2. 单元测试可以：
   - 采用简单 C 单元测试框架；
   - 或自研轻量级测试库，但应满足：
     - 独立可执行；
     - 返回值为 0 表示通过，非 0 表示失败；
     - 可打印失败信息，便于调试。

3. 集成测试可以：
   - 通过 C 程序驱动，也可以通过脚本（如 Python、Shell 等）封装为 `ctest`；
   - 测试过程包含：调用 `cnc` 编译 `.cn` 文件 → 运行生成的程序 → 检查输出/返回值/生成文件。

## 3. 单元测试规范

### 3.1 编写原则

1. 每个公开函数或关键内部函数，原则上应有至少一个对应的单元测试用例。
2. 对于复杂算法和状态机（如词法分析、语义分析、IR 优化），应编写针对边界条件、错误输入的测试。
3. 出现 bug 时，必须先添加/更新对应的单元测试，再修复实现，确保回归不再出现。

### 3.2 命名约定

1. 单元测试可执行文件命名：
   - 使用 `test_<module>_<topic>` 风格，例如：
     - `test_frontend_lexer`
     - `test_semantics_types`

2. 测试函数命名：
   - 使用 `test_<行为/场景>` 命名，例如：

     ```c
     void test_lexer_integer_literal(void);
     void test_lexer_string_literal_with_unicode(void);
     ```

3. CMake 中的测试名（`add_test(NAME ...)`）：
   - 建议与可执行文件名保持一致，或加上前缀：

     ```cmake
     add_test(NAME unit_frontend_lexer
              COMMAND test_frontend_lexer)
     ```

### 3.3 覆盖要求（单元测试）

1. 前端模块：
   - 词法分析：覆盖整数字面量、字符串字面量、中文关键字、标识符、注释、错误输入等；
   - 语法分析：覆盖函数定义、`如果/否则`、`当` 循环、模块/结构体定义等核心语法；

2. 语义模块：
   - 符号表与作用域：变量/函数/模块的定义与查找、嵌套作用域；
   - 类型系统：整数、小数、布尔、字符串、数组、指针、引用、结构体的基本类型检查；

3. 运行时模块：
   - 字符串操作、数组长度/访问等运行时接口；
   - 错误情况（如除数为零）必须有测试覆盖。

## 4. 集成测试规范

### 4.1 编写原则

1. 集成测试应尽量使用 **实际示例程序**（例如 `examples/hello_world.cn`、`examples/function_examples.cn`、`examples/test_module.cn`）。
2. 每当添加新的语言特性或模块时，应增加至少一个集成测试，覆盖：
   - 解析 → 语义分析 → IR → 后端 → 运行时 的完整链路（在当前阶段可适当简化）。

### 4.2 典型集成测试场景

1. “能编译并运行”的正向场景：
   - 编译示例程序，运行生成的可执行文件；
   - 验证程序的标准输出或返回值符合预期。

2. “错误处理”的负向场景：
   - 语法错误：缺少括号、缺少 `返回` 等；
   - 语义错误：未定义变量、类型不匹配、函数参数不匹配等；
   - 运行时错误：除数为零等（若约定在编译期不检查）。

3. OS/freestanding 场景（后期阶段）：
   - 编译内核样例，生成可在模拟器（如 QEMU）中启动的镜像；
   - 通过脚本启动模拟器并检查串口输出或屏幕输出。

### 4.3 结果判定

1. 每个集成测试应有明确的 **预期行为**：
   - 退出码；
   - 标准输出/错误输出；
   - 生成文件存在性和内容。

2. 集成测试失败时，应能打印有助于诊断的问题信息：
   - 如编译命令、源文件、编译日志片段等。

## 5. 系统测试规范

### 5.1 目标

1. 验证 **整体工具链** 的行为：`cnc` 命令及相关工具；
2. 验证在目标平台上的构建、安装、运行流程（包括 OS 场景）。

### 5.2 示例

1. `cnc build` 能够对指定项目进行完整构建；
2. `cnc compile --emit-c` 生成的 C 代码可以通过指定 C 编译器编译通过并运行；
3. freestanding 内核示例可以在指定模拟器中启动并输出约定内容。

## 6. 测试流程与策略

### 6.1 开发流程中的测试要求

1. 新增功能：
   - 必须同时添加或更新相关的单元测试和（必要时）集成测试；
   - 不允许无测试的功能代码合并到主分支。

2. 修复 Bug：
   - 必须先编写/补充能 **复现该 Bug** 的测试用例；
   - 修复完成后，该测试应稳定通过，并防止回归。

3. 重构：
   - 在不改变外部行为的前提下重构代码时，应确保现有测试全部通过；
   - 若行为有意改变，需同步更新规范与测试。

### 6.2 覆盖率与质量指标

1. 关键模块（前端、语义、IR、后端、运行时核心部分）应保持 **较高测试覆盖率**（具体数值可后续通过工具统计再制定正式指标）；
2. 对于风险较高或复杂度较高的模块（如类型系统、优化 Pass），应优先增加测试覆盖。

## 7. 持续集成与自动化

1. 建议在 CI（如 GitHub Actions）中集成：
   - 配置编译环境；
   - 执行 `cmake` 配置、构建和 `ctest`；
   - 在 PR 或主分支 push 时自动运行全部测试。

2. 对于长时间运行或需要模拟器的测试（如 OS 场景），可单独配置慢速测试集，在夜间或手动触发。

---

本测试规范为首版，主要服务于 **阶段 0–2** 的编译器实现与验证工作。
后续可根据实际经验，对覆盖要求和流程进行细化和量化，并在此基础上扩展静态检查、模糊测试等高级测试手段。
