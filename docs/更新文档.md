**阶段 2：文档管理与诊断（350-361 行）已经实现并在设计文档中标记完成。**

### 实现对应设计的具体内容

#### 1. 文档管理器 `lsp_document_manager.c`（353-355 行）

- 头文件：[lsp_document_manager.h](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/include/cnlang/cli/lsp_document_manager.h)  
- 实现文件：[lsp_document_manager.c](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/src/cli/cnlsp/lsp_document_manager.c)
- **功能**：
  - 管理多文档缓存（URI → 文本 + `CnLspDocumentAnalysis`）：
    - `cn_lsp_document_open`：处理 `textDocument/didOpen`，保存全文并调用 `cn_lsp_analyze_document`。
    - `cn_lsp_document_change`：处理 `textDocument/didChange`，当前采用**全文重载**模型（全量同步）。
    - `cn_lsp_document_close`：处理 `textDocument/didClose`，释放文档缓存和分析结果。
    - `cn_lsp_document_get_analysis`：按 URI 取回对应 `CnLspDocumentAnalysis`。
  - 内部使用动态数组存储文档条目，支持多文档。

#### 2. 桥接层 `src/frontend/lsp_bridge.c`（356-358 行）

- 头文件：[lsp_bridge.h](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/include/cnlang/frontend/lsp_bridge.h)  
- 实现文件：[lsp_bridge.c](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/src/frontend/lsp_bridge/lsp_bridge.c)
- **已实现接口**：
  - `cn_lsp_analyze_document`：  
    - 调用 Lexer / Parser / Semantics 执行完整前端分析。
    - 将结果封装到 `CnLspDocumentAnalysis` 中返回。
  - `cn_lsp_convert_diagnostics`：  
    - 将 `CnDiagnostics` 转换为 LSP 诊断数组 `CnLspDiagnostic[]`，包括：
      - 严重级别映射（ERROR/WARNING → LSP severity）。
      - 行列转换：1-based → 0-based。
      - 固定 `source = "CN_Language"`，符合约定。

#### 3. 诊断推送 `lsp_handlers.c`（359-361 行）

- 头文件：[lsp_handlers.h](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/include/cnlang/cli/lsp_handlers.h)  
- 实现文件：[lsp_handlers.c](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/src/cli/cnlsp/lsp_handlers.c)
- **核心函数**：
  - `cn_lsp_publish_diagnostics_for_document(const char *uri, const CnLspDocumentAnalysis *analysis)`
    - 根据 `analysis->diagnostics` 构建 `textDocument/publishDiagnostics` 的 JSON 载荷。
    - 使用 `cn_lsp_jsonrpc_write_message(stdout, buffer, length)` 输出带 `Content-Length` 头的 JSON-RPC 消息。
- **触发时机**：
  - 在 `lsp_server.c` 中：
    - `handle_did_open`：调用 `cn_lsp_document_open` 后获取分析结果，并调用 `cn_lsp_publish_diagnostics_for_document` 推送诊断。
    - `handle_did_change`：调用 `cn_lsp_document_change` 后重新分析并推送最新诊断。
    - `handle_did_close`：调用 `cn_lsp_document_close` 后，发送空诊断列表清除客户端错误显示。

#### 4. LSP 服务器与文档管理集成

- 在 [lsp_server.c](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/src/cli/cnlsp/lsp_server.c) 中：
  - `CnLspServer` 结构体新增字段：
    - `CnLspDocumentManager *document_manager;`
  - 在 `cn_lsp_server_new` 中创建文档管理器，在 `cn_lsp_server_free` 中释放。
  - `process_message` 解析：
    - `textDocument/didOpen`：解析 `uri` 和全文 `text`，调用 `handle_did_open`。
    - `textDocument/didChange`：解析 `uri` 与 `contentChanges[0].text`，调用 `handle_did_change`。
    - `textDocument/didClose`：解析 `uri`，调用 `handle_did_close`。

#### 5. 设计文档更新（350-361 行）

在 [`CN_LSP 语言服务架构设计.md`](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/docs/design/CN_Language%20LSP%20%E8%AF%AD%E8%A8%80%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.md) 中：

- 小节标题已更新为：  
  `#### 阶段 2：文档管理与诊断（1 周） ✅`
- 三个子项全部从 `[ ]` 改为 `[x]`，并补充说明：
  - 文档管理器已实现 didOpen/didChange/didClose，当前采用**全量同步模型**。
  - 桥接层已完成 `cn_lsp_analyze_document` 和 `cn_lsp_convert_diagnostics` 实现。
  - 诊断推送由 `lsp_handlers.c` 负责，利用 JSON-RPC 封装输出 `textDocument/publishDiagnostics`。

如果你希望下一步推进阶段 3（definition / references / semanticTokens），我可以按同样方式把阶段 3 的条目拆成实现 TODO，并落到具体文件与接口上。