## CN_Language 开发计划

### 1. 总体策略与目标

- **目标概述**：
  - 分阶段实现一门可用于操作系统开发的中文编程语言 CN_Language，包括编译器、运行时、工具链和测试体系。
  - 首期版本以 **“编译到 C”** 为主要实现路径，借助成熟 C 编译器获取可移植性与性能。
  - 中长期目标是支持 freestanding 环境、OS 内核与底层组件开发，以及后续独立后端。

- **实施策略**：
  - 采用 **迭代式开发 + 明确里程碑** 的方式，每个阶段有清晰的输入、输出与验收标准。
  - 严格控制模块划分和代码规模，契合单一职责原则和行数限制。
  - 构建体系、测试体系和文档体系与功能开发并行推进，而非事后补充。

- **规范依赖说明**：
  - 项目要求严格遵守 `docs/specifications` 中的各项规范。
  - 当前仓库尚未提供该目录和文件，本开发计划基于通用工程实践制定。
  - **里程碑 0** 中将包含“补齐 `docs/specifications` 规范”的任务，一经补齐需对本计划及架构设计进行复审。

---

### 2. 阶段划分与时间线（建议）

> 注：以下时间线以“人周”为单位，具体节奏可根据实际人力和熟练度调整。

- **阶段 0：项目初始化与规范完善（约 1–2 周）**
- **阶段 1：前端基础（词法/语法）与最小可编译样例（约 2–3 周）**
- **阶段 2：语义分析与基础类型系统（约 3–4 周）**
- **阶段 3：IR 设计与 C 后端初版（约 3–4 周）**
- **阶段 4：最小运行时与基础标准库（约 3–4 周）**
- **阶段 5：OS 开发支持与 freestanding 模式（约 4–6 周）**
- **阶段 6：工具链与生态（REPL / 格式化 / 检查器）（约 4–6 周）**
- **阶段 7：性能优化、稳定版与长期演进规划（持续迭代）**
- **阶段 8：核心语法扩展与系统编程能力（操作系统开发就绪）**

---

### 3. 阶段详细规划

#### 3.1 阶段 0：项目初始化与规范完善

- **目标**：
  - 完成基础目录结构、构建骨架、测试骨架和规范文档，使项目具备可持续扩展的基础设施。

- **主要任务**：
  - 目录与模块骨架：
    - 创建 `src/`、`include/`、`tests/`、`build/`、`docs/api/` 等目录。
    - 按架构设计文档创建前端、语义、IR、后端、运行时、支持库、CLI 等模块子目录。
  - 规范文档：
    - 在 `docs/specifications/` 目录下新增：
      - 代码风格规范（C 语言编码规范、命名规则、注释规范等）。
      - 语言规范草案（关键字、语法、类型系统、运行时约束等）。
      - 测试规范（单元测试/集成测试组织方式、命名规则、覆盖要求）。
    - 将“每个 `.c` 文件 ≤ 500 行、每个函数 ≤ 50 行”等约束正式写入规范。
  - 构建系统初始化：
    - 选定构建工具（推荐 CMake 或 Make + 跨平台脚本）。
    - 确保所有中间文件输出到 `build/` 子目录。
    - 将各模块编译为静态库，并编译空壳 `cnc` 可执行文件作为示例。
  - 测试骨架：
    - 在 `tests/` 目录下创建 `unit/`、`integration/`、`system/` 等子目录。
    - 引入简单的 C 单元测试框架或自研轻量测试库。

- **里程碑 / 验收标准**：
  - 项目可以在本机执行基础构建（即使功能尚未实现）。
  - 规范文档存在并在仓库中维护，后续开发以此为准。
  - 测试框架可编译并运行简单示例测试（例如“总是通过”的占位测试）。

#### 3.2 阶段 1：前端基础（词法/语法）与最小可编译样例

- **目标**：
  - 实现最小可用的词法分析器和语法分析器，支持简单 CN_Language 程序编译为 AST。

- **主要任务**：
  - 语言子集定义：
    - 选定一个核心子集（例如变量声明、整型表达式、简单函数定义和调用）。
    - 将该子集写入 `docs/specifications` 的语言规范文档。
  - 词法分析器实现：
    - 按模块拆分（状态机、Token 定义、错误处理等），保证 `.c` 文件和函数行数约束。
    - 支持中文关键字和标识符（明确编码、源文件编码策略）。
  - 语法分析器实现：
    - 选择解析技术（递归下降 / 手写 LL / 生成器等），当前建议手写递归下降以便控制结构和中文语法特性。
    - 构建 AST 结构，定义主要 AST 节点类型。
  - 诊断与错误恢复：
    - 在 `support/diagnostics` 中提供统一接口，前端调用。

- **里程碑 / 验收标准**：
  - 能够成功解析 `examples/` 中类似 `hello_world.cn` 的基本程序（可根据现有示例调整语法）。
  - 在 `tests/unit/frontend/` 下有覆盖核心 Token / 语法规则的单元测试。
  - 在 `tests/integration/compiler/` 中存在至少一个“解析通过/失败”的集成测试。

#### 3.3 阶段 2：语义分析与基础类型系统

- **目标**：
  - 建立符号表、作用域模型和基础类型系统，实现名称解析和基本类型检查。

- **主要任务**：
  - 符号表与作用域：
    - 实现符号表数据结构，支持嵌套作用域（全局、函数、块）。
    - 在语义分析阶段遍历 AST 并填充符号表。
  - 类型系统：
    - 定义基础类型集合（整型、布尔、指针等）。
    - 实现类型等价/兼容检查、简单的类型推断规则。
  - 语义检查：
    - 名称解析错误、重复定义、未定义标识符检测。
    - 函数调用参数与形参匹配检查。
    - 控制流基本检查（如必需的返回语句）。
  - 错误报告：
    - 语义错误通过 diagnostics 模块统一输出，并尽量保持后续分析继续进行。

- **里程碑 / 验收标准**：
  - 对简单程序可完成从源代码到“带类型信息的 AST”的分析。
  - 在 `tests/unit/semantics/` 中为符号表、类型系统编写单元测试。
  - 集成测试中能识别典型语义错误，并输出清晰错误信息。

#### 3.4 阶段 3：IR 设计与 C 后端初版

- **目标**：
  - 引入中间表示（IR），支持将 AST 转换为 IR，并实现将 IR 转换为 C 代码的后端。

- **主要任务**：
  - IR 设计：
    - 定义 IR 指令集和基本块结构。
    - 设计简明、可扩展的数据结构，保持与 AST、类型系统的良好映射。
  - AST → IR 转换：
    - 为表达式、语句、函数定义等建立 IR 生成规则。
  - IR Pass：
    - 实现若干简单优化（常量折叠、死代码删除等）。
  - C 后端：
    - 将 IR 转换为合法 C 代码，生成 `.c` 输出文件。
    - 约定 C 接口 ABI（函数命名规则、类型对应规则）。
  - 构建集成：
    - 编译生成的 C 代码，并链接运行时/标准库（如果需要）。

- **里程碑 / 验收标准**：
  - 能够对阶段 1/2 中的示例程序执行“源代码 → C 代码 → 可执行文件”的完整流程。
  - 在 `tests/integration/compiler/` 中新增“编译后执行结果正确”的测试。
  - IR 结构和 C 代码输出格式稳定，可供调试和后续工具使用。

#### 3.5 阶段 4：最小运行时与基础标准库

- **目标**：
  - 实现最小运行时，提供基础标准库，为语言提供基本运行环境。

- **主要任务**：
  - 运行时初始化：
    - 程序入口、全局初始化、退出流程。
  - 内存管理：
    - 提供基础内存分配接口（封装 `malloc`/`free` 或替代实现）。
    - 为 OS 开发场景预留自定义内存管理接口（例如页分配器包装）。
  - 基础标准库：
    - 字符串处理、简单 I/O、数学函数等（可先依赖宿主系统，后续 freestanding 优化）。
  - 与语言特性绑定：
    - 明确哪些语言特性依赖运行时（如字符串、集合）。

- **里程碑 / 验收标准**：
  - 示例程序可调用运行时/标准库函数并正常运行。
  - 在 `tests/unit/runtime/` 中覆盖关键运行时接口。
  - 在 `tests/integration/compiler/` 中加入依赖运行时的集成测试。

#### 3.6 阶段 5：OS 开发支持与 freestanding 模式

- **目标**：
  - 支持 OS 开发场景下的 freestanding 模式，能够生成适用于裸机环境的代码并与启动代码、链接脚本配合。

- **主要任务**：
  - 目标平台建模：
    - 在 `support/config` 中定义目标三元组（如 `x86_64-elf` 等）。
    - 为 OS 目标提供特定编译选项（禁用标准库、指定入口符号等）。
  - freestanding 运行时：
    - 提供不依赖宿主 OS 的运行时实现。
    - 处理常见 OS 内核环境限制（无堆、无文件系统等）。
  - 编译器限制：
    - 在 freestanding 模式下限制或禁止使用某些语言特性/库函数。
  - 集成测试：
    - 与简单启动代码和链接脚本配合，生成可在 QEMU/Bochs 等模拟器中启动的镜像。

- **里程碑 / 验收标准**：
  - 能够编译一个由 CN_Language 编写的简单内核（如打印字符串/切换到某个模式）。
  - 在 `tests/integration/os/` 中有自动化测试脚本（通过模拟器运行并检查输出）。

#### 3.7 阶段 6：工具链与生态（REPL / 格式化 / 检查器）

- **目标**：
  - 提升语言易用性，完善开发体验和生态支持。

- **主要任务**：
  - REPL：
    - 实现 `cnrepl`，支持交互式执行表达式和语句。
  - 格式化工具：
    - 实现代码格式化，确保统一风格。
  - 静态检查工具：
    - 对代码进行风格和潜在问题检查（未使用变量、简单复杂度限制等）。
  - 语言服务（后续）：
    - 设计 LSP 协议支持，为 IDE/编辑器提供补全、跳转、重构等能力。

- **里程碑 / 验收标准**：
  - REPL 可用于快速试验语法和小段程序。
  - 格式化工具可对样例项目进行统一格式化，结果稳定可复现。

#### 3.8 阶段 7：性能优化、稳定版与长期演进

- **目标**：
  - 在功能相对完整后，进行性能优化、内存占用优化和稳定性提升，准备发布可长期维护的版本。

- **主要任务**：
  - 性能分析与优化：
    - 对编译器自身性能进行分析（如构建大项目时的耗时）。
    - 针对 IR、后端和运行时进行热点优化。
  - 内存管理优化：
    - 优化编译器内部数据结构的内存使用。
  - 稳定性与回归测试：
    - 扩大测试覆盖范围，构建长期回归测试集。
  - 版本化与发布：
    - 制定版本号规范、发布流程和变更日志规范。

- **里程碑 / 验收标准**：
  - 在多个平台上成功构建并运行核心功能。
  - 测试覆盖率达到预设目标；回归测试稳定通过。

---

### 4. 角色与任务分配建议

> 即使当前只有一名开发者，也建议以“角色”的形式划分职责，便于管理和思考。

- **语言与架构负责人**：
  - 负责语言设计、总体架构设计、关键技术决策。
  - 牵头维护 `docs/design/` 和 `docs/specifications/`。

- **编译器前端工程师**：
  - 负责词法、语法和 AST 实现及相关测试。

- **编译器后端与 IR 工程师**：
  - 负责 IR 设计、优化和 C/汇编后端实现。

- **运行时与标准库工程师**：
  - 负责运行时和标准库设计与实现，特别是 freestanding 场景。

- **工具链与生态工程师**：
  - 负责 `cnc`、`cnrepl` 等工具，以及格式化、静态检查等。

- **测试与质量工程师**：
  - 负责测试框架、测试用例设计和自动化。

在实际执行中，这些角色可以由同一人扮演，但任务和责任可以按此划分。

---

### 5. 测试与质量保障计划

- **测试分层**：
  - 单元测试：针对各模块内部函数/结构；每个模块在 `tests/unit/<module>/` 下有对应测试。
  - 集成测试：覆盖编译流水线和运行时行为；放在 `tests/integration/` 下。
  - 系统测试：包括 OS 场景测试；放在 `tests/system/` 下。

- **测试策略**：
  - 新增功能必须伴随相应测试用例，禁止无测试合并。
  - 修复 bug 必须新增或更新回归测试。
  - 关键路径（解析、语义、后端核心逻辑）需要维持高测试覆盖率。

- **工具与流程**：
  - 在构建系统中添加 `test` 目标，统一运行所有测试。
  - 后期可接入 CI（如 GitHub Actions），自动化执行编译与测试。

---

### 6. 文档与 API 规范落地计划

- **模块 README**：
  - 每个模块/子模块目录建立后，创建相应 `README.md`，说明：
    - 模块职责与边界。
    - 对外暴露的接口（简要说明）。
    - 使用示例与注意事项。
  - README 写作应与模块实现同步进行或紧随其后。

- **API 文档（`docs/api/`）**：
  - 每个公共模块在 `docs/api/<module>/` 下维护 API 文档，内容包括：
    - 函数签名、参数说明、返回值说明。
    - 错误条件、前置/后置条件。
    - 使用示例（代码片段）。
  - 可基于头文件自动生成部分文档，再手动补充说明。

- **规范文档维护**：
  - 所有影响外部行为的变更必须在 `docs/specifications` 中更新。
  - 在发布版本前，对规范文档进行集中审查。

---

### 7. 风险与应对

- **语言规范变动频繁**：
  - 早期语言设计不稳定，可能导致较多重构。
  - 应对：在阶段 0/1 明确核心子集，优先稳定核心语法和语义，扩展特性尽量晚些实现。

- **OS 开发支持复杂度高**：
  - freestanding 环境、引导链路、平台差异等提升复杂度。
  - 应对：通过 C 后端复用现有 OS 开发经验，优先支持少数目标平台（如 `x86_64-elf`）。

- **性能与内存占用**：
  - 解析大型项目和编译复杂程序可能带来性能瓶颈。
  - 应对：阶段 7 专门进行性能分析和优化；在设计数据结构时注意避免不必要的拷贝和分配。

---

### 8. 下一步建议

根据项目目前的状况，CN_Language项目虽然完成了阶段0到阶段7的基础架构搭建，但核心语法功能仍需大幅扩展。为了实现像C语言那样能够编写操作系统的完整功能，需要在现有基础上继续扩展语言特性。以下是核心语法扩展的TODO列表：

## CN语言核心语法扩展 TODO 列表（为支持操作系统开发）

### 1. 核心语法扩展任务
- [ ] 实现指针类型和指针运算，支持内存地址操作
- [ ] 实现结构体和联合体，支持复杂数据结构定义
- [ ] 实现枚举类型，支持命名常量集合
- [ ] 实现函数指针，支持回调和动态调用
- [ ] 实现预处理器宏系统，支持条件编译和代码生成

### 2. 系统编程特性任务
- [ ] 实现直接内存访问和内存映射I/O
- [ ] 实现内联汇编支持，允许嵌入汇编代码
- [ ] 实现位操作符和位字段，支持硬件级编程
- [ ] 实现中断处理机制，支持异步事件响应
- [ ] 实现原子操作和锁机制，支持并发控制

### 3. 高级类型系统任务
- [ ] 实现数组越界检查和安全访问
- [ ] 实现字符串操作库，支持文本处理
- [ ] 实现动态内存管理，支持malloc/free等操作
- [ ] 实现类型转换机制，支持显式和隐式转换
- [ ] 实现常量和静态修饰符，支持存储类别

### 4. 控制流扩展任务
- [ ] 实现goto语句和标签，支持非结构化跳转
- [ ] 实现do-while循环，补充循环语句家族
- [ ] 实现switch-case语句，支持多重分支
- [ ] 实现异常处理机制，支持错误传播
- [ ] 实现断言机制，支持运行时检查

### 5. 编译器优化任务
- [ ] 实现死代码消除优化
- [ ] 实现循环优化，包括循环展开和强度削减
- [ ] 实现函数内联优化
- [ ] 实现实参传递优化
- [ ] 实现寄存器分配优化

### 6. 运行时与标准库任务
- [ ] 实现标准C库函数的中文接口
- [ ] 实现内存分配器，支持堆内存管理
- [ ] 实现标准I/O系统，支持输入输出操作
- [ ] 实现数学库，支持数值计算
- [ ] 实现时间日期处理函数

### 7. 操作系统开发专用任务
- [ ] 实现内存分页机制的抽象接口
- [ ] 实现进程/线程管理的抽象接口
- [ ] 实现设备驱动开发框架
- [ ] 实现中断向量表管理
- [ ] 实现系统调用接口

完成这些核心语法和系统编程特性的实现后，CN语言将具备编写操作系统所需的基本功能，可以进行真正的系统级编程。

#### 3.9 阶段 8：核心语法扩展与系统编程能力（操作系统开发就绪）

- **目标**：
  - 实现C语言级别的系统编程能力，包括指针、结构体、内存管理等核心特性，使CN_Language能够编写操作系统和其他系统软件。

- **主要任务**：
  - 核心语法扩展：
    - 实现指针类型和指针运算，支持内存地址操作。
    - 实现结构体和联合体，支持复杂数据结构定义。
    - 实现枚举类型，支持命名常量集合。
    - 实现函数指针，支持回调和动态调用。
    - 实现预处理器宏系统，支持条件编译和代码生成。
  - 系统编程特性：
    - 实现直接内存访问和内存映射I/O。
    - 实现内联汇编支持，允许嵌入汇编代码。
    - 实现位操作符和位字段，支持硬件级编程。
    - 实现中断处理机制，支持异步事件响应。
    - 实现原子操作和锁机制，支持并发控制。
  - 标准库扩展：
    - 实现标准C库函数的中文接口。
    - 实现内存分配器，支持堆内存管理。
    - 实现标准I/O系统，支持输入输出操作。

- **里程碑 / 验收标准**：
  - 能够编写简单的系统程序，如内存管理器、任务调度器等。
  - 能够编译和运行小型的操作系统内核示例。
  - 通过系统编程基准测试验证性能和功能。