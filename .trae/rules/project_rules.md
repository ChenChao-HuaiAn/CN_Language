# CN Language 项目规则

## 代码规范

### 文件命名规范
- **C源文件**: `CN_模块名_功能.c`（如 `CN_lexer_tokenize.c`）
- **头文件**: `CN_模块名_功能.h`（如 `CN_lexer_interface.h`）
- **CN语言源文件**: `.cn` 扩展名（如 `hello_world.cn`）
- **测试文件**: `test_模块名.c`（如 `test_lexer.c`）
- **文档文件**: 使用小写字母和下划线（如 `architecture.md`）

### 命名规范
- **结构体**: `Stru_` 前缀 + 大驼峰命名法 + `_t` 后缀（如 `Stru_Token_t`）
- **接口**: `Stru_` 前缀 + 模块名 + `Interface_t` 后缀（如 `Stru_LexerInterface_t`）
- **函数**: `F_` 前缀 + 描述性名称（如 `F_create_token`）
- **枚举**: `Eum_` 前缀 + 大驼峰命名法（如 `Eum_TokenType`）
- **常量**: 全大写，下划线分隔（如 `MAX_TOKEN_LENGTH`）
- **全局变量**: `g_` 前缀 + 小驼峰命名法（如 `g_current_line`）
- **静态变量**: `s_` 前缀 + 小驼峰命名法（如 `s_instance_count`）
- **函数参数**: `p_` 前缀 + 小驼峰命名法（如 `p_input_string`）
- **局部变量**: 小驼峰命名法（如 `token_count`）

### 编码标准
- **缩进**: 使用4个空格，禁止使用制表符
- **大括号风格**: Allman风格（大括号单独成行）
- **行长度**: 每行不超过120个字符
- **函数长度**: 每个函数不超过50行
- **文件长度**: 每个.c文件不超过500行
- **空行**: 函数之间空2行，逻辑块之间空1行
- **指针声明**: `*` 号靠近类型名（如 `int* p_ptr`）

### 注释规范
- **文件头注释**: 每个源文件开头应包含文件名、功能、作者、创建日期、修改历史、版权
- **函数注释**: 使用 `@brief`、`@param`、`@return`、`@note` 标签
- **接口注释**: 说明契约、前置条件、后置条件
- **行内注释**: 复杂逻辑处添加中文注释说明代码意图
- **TODO注释**: 使用 `// TODO:` 标记待完成事项
- **FIXME注释**: 使用 `// FIXME:` 标记需要修复的问题

## 内存管理规范

### 内存分配
- 使用 `F_malloc` 和 `F_free` 替代标准库的 `malloc` 和 `free`
- 每次分配后立即检查返回值是否为 `NULL`
- 分配的内存必须确保有对应的释放操作
- 使用 RAII 风格管理资源，确保异常安全

### 内存泄漏防护
- 使用内存检测工具（如 Valgrind）定期检查
- 在函数返回前释放所有局部分配的内存
- 避免循环引用导致内存泄漏
- 使用智能指针或资源管理器管理动态内存

### 缓冲区安全
- 使用安全的字符串操作函数（如 `strncpy` 替代 `strcpy`）
- 始终验证数组边界
- 使用 `assert` 检查指针有效性
- 避免缓冲区溢出攻击

## 错误处理规范

### 错误码定义
- 使用枚举定义错误码（如 `Eum_ErrorCode`）
- 错误码命名使用 `ERR_` 前缀（如 `ERR_INVALID_TOKEN`）
- 为每个错误码提供对应的错误描述字符串

### 错误处理策略
- 函数返回值使用错误码，通过指针参数返回数据
- 关键操作必须检查错误码
- 错误信息应包含足够的上下文信息
- 使用日志记录错误详情

### 异常处理
- C语言不使用异常机制，使用错误码处理
- 错误传播到最上层处理
- 资源释放放在错误处理路径中
- 避免静默失败

## 测试规范

### 单元测试
- 每个模块必须有对应的单元测试文件
- 测试覆盖率不低于80%
- 测试函数命名：`test_功能名_场景`（如 `test_tokenize_identifier`）
- 使用断言验证预期结果

### 集成测试
- 测试模块间的交互
- 测试关键业务流程
- 测试边界条件和异常情况
- 测试性能指标

### 测试执行
- 提交代码前必须通过所有测试
- 使用 CI/CD 自动运行测试
- 测试失败时立即修复
- 定期重构测试代码

## Git 工作流规范

### 分支管理
- **main/master**: 生产环境代码，只接受合并请求
- **develop**: 开发主分支，功能开发基于此分支
- **feature/功能名**: 功能开发分支
- **bugfix/问题描述**: Bug修复分支
- **hotfix/问题描述**: 紧急修复分支

### 提交规范
- 提交信息格式：`类型: 描述`（如 `feat: 添加词法分析器`）
- 提交类型：
  - `feat`: 新功能
  - `fix`: Bug修复
  - `docs`: 文档更新
  - `style`: 代码格式调整
  - `refactor`: 重构
  - `test`: 测试相关
  - `chore`: 构建/工具相关
- 一次提交只做一件事
- 提交前进行代码审查

### 合并规范
- 使用 Pull Request 或 Merge Request
- 必须通过代码审查才能合并
- 必须通过所有测试才能合并
- 合并时使用 squash merge 保持历史整洁

## 代码审查规范

### 审查要点
- 代码风格是否符合规范
- 是否有潜在的安全问题
- 是否有性能问题
- 错误处理是否完善
- 注释是否清晰准确
- 测试覆盖率是否足够

### 审查流程
- 提交 Pull Request 后自动触发审查
- 至少需要一人审查通过
- 审查意见必须在24小时内响应
- 重大修改需要重新审查

## 文档规范

### 代码文档
- 公共API必须有详细文档
- 复杂算法必须有实现说明
- 数据结构必须有使用说明
- 示例代码必须可运行

### 项目文档
- README.md 包含项目介绍、安装、使用说明
- docs/ 目录存放设计文档
- API 文档使用 Doxygen 生成
- 变更日志记录重要更新

## 性能优化规范

### 性能基准
- 建立性能基准测试
- 优化前后对比性能数据
- 避免过早优化
- 优先优化热点路径

### 优化原则
- 算法复杂度优先于微优化
- 减少不必要的内存分配
- 使用缓存减少重复计算
- 避免不必要的拷贝

## 安全规范

### 输入验证
- 所有外部输入必须验证
- 检查数组边界
- 验证指针有效性
- 防止整数溢出

### 数据保护
- 敏感数据加密存储
- 避免硬编码密钥和密码
- 使用安全的随机数生成器
- 及时清零敏感内存

## 构建和部署规范

### 构建系统
- 使用 Make 或 CMake 管理构建
- 支持多平台编译
- 提供清晰的构建文档
- 构建产物包含版本信息

### 版本管理
- 使用语义化版本号（如 1.2.3）
- 每次发布更新版本号
- 维护 CHANGELOG.md
- 标记重要版本

## 开发流程规范

### 开发步骤
1. 创建功能分支
2. 编写代码和测试
3. 运行测试确保通过
4. 提交代码
5. 创建 Pull Request
6. 代码审查
7. 合并到主分支

### 代码质量
- 使用静态代码分析工具
- 定期进行代码重构
- 保持代码简洁可读
- 遵循 SOLID 原则

## 工具使用规范

### 编辑器配置
- 使用4空格缩进
- 保存时自动格式化
- 启用语法检查
- 配置代码片段

### 开发工具
- 使用 Git 进行版本控制
- 使用 GDB 或 LLDB 进行调试
- 使用 Valgrind 检测内存问题
- 使用 Doxygen 生成文档
