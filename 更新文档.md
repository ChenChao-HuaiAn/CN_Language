### 新增实现文件

根据你“在 `src/semantics/（或你指定的目录）里新增实现文件，例如 symbol_table.c，实现上述接口。”的要求，当前已经完成：

- **实现文件位置**
  - 新增文件：**`src/semantics/symbols/symbol_table.c`**  
    - 对应头文件：**`include/cnlang/frontend/semantics.h`**  

- **核心实现内容（与头文件接口一一对应）**
  - 内部结构：
    - `CnSemSymbolNode`：作用域内符号的单向链表节点。
    - `struct CnSemScope`：
      - `CnSemScopeKind kind;`
      - `CnSemScope *parent;`
      - `CnSemSymbolNode *symbols;`  // 当前作用域的符号链表
  - 名字比较辅助函数：
    - `static int cn_sem_symbol_name_equals(const CnSemSymbol *symbol, const char *name, size_t name_length);`
    - 使用 `name_length` + `memcmp` 做比较（兼容非 `\0` 结尾片段），并特判指针相同的情况。
  - 对外 API 实现：
    - **创建作用域**
      ```c
      CnSemScope *cn_sem_scope_new(CnSemScopeKind kind, CnSemScope *parent);
      ```
      - `malloc` 分配 `CnSemScope`，初始化 `kind` / `parent` / `symbols`。
      - 失败返回 `NULL`。
    - **销毁作用域**
      ```c
      void cn_sem_scope_free(CnSemScope *scope);
      ```
      - 依次释放该作用域内的 `CnSemSymbolNode` 链表，再 `free(scope)`。  
      - 不递归释放父作用域，父子作用域由调用方管理。
    - **获取父作用域**
      ```c
      CnSemScope *cn_sem_scope_parent(CnSemScope *scope);
      ```
      - 空指针保护，返回 `scope->parent`。
    - **插入符号（当前作用域）**
      ```c
      CnSemSymbol *cn_sem_scope_insert_symbol(CnSemScope *scope,
                                              const char *name,
                                              size_t name_length,
                                              CnSemSymbolKind kind);
      ```
      - 参数校验：`scope` / `name` 非空且 `name_length > 0`。
      - 使用 `cn_sem_scope_lookup_shallow` 检查当前作用域是否重复定义，重复则返回 `NULL`。
      - 分配 `CnSemSymbolNode`，将 `name` 指针与 `name_length` 直接保存（不拷贝字符串），设置 `kind` 与 `decl_scope = scope`，头插入链表。
      - 成功返回 `&node->symbol`，失败返回 `NULL`。
    - **当前作用域浅查找**
      ```c
      CnSemSymbol *cn_sem_scope_lookup_shallow(CnSemScope *scope,
                                               const char *name,
                                               size_t name_length);
      ```
      - 仅遍历 `scope->symbols` 链表，使用 `cn_sem_symbol_name_equals` 比较名字，找到则返回符号指针，否则 `NULL`。
    - **向上链路查找（支持父作用域）**
      ```c
      CnSemSymbol *cn_sem_scope_lookup(CnSemScope *scope,
                                       const char *name,
                                       size_t name_length);
      ```
      - 先检查参数合法性（名字非空且长度 > 0）。
      - 从当前 `scope` 开始循环：
        - 调用 `cn_sem_scope_lookup_shallow` 查当前层；
        - 找到立即返回；
        - 找不到则 `scope = scope->parent` 继续向上。
      - 一直到 `scope == NULL`，则返回 `NULL`。

- **构建系统已挂载该实现文件**
  - 已在 `src/CMakeLists.txt` 的 `add_executable(cnc ...)` 中加入：
    ```cmake
    semantics/symbols/symbol_table.c
    ```
  - 编译 `cnc` 时会一同编译符号表实现（尽管目前还未被其他模块调用）。

### 你可以这样使用（简要示例逻辑）

你后续在语义分析或名字解析阶段，大致可以这样使用这些 API（伪代码示意）：

- **构建作用域链**
  - 全局：`global = cn_sem_scope_new(CN_SEM_SCOPE_GLOBAL, NULL);`
  - 函数体：`fn_scope = cn_sem_scope_new(CN_SEM_SCOPE_FUNCTION, global);`
  - 语句块：`block_scope = cn_sem_scope_new(CN_SEM_SCOPE_BLOCK, fn_scope);`

- **插入符号**
  - 变量 / 参数：  
    `cn_sem_scope_insert_symbol(current_scope, name_ptr, name_len, CN_SEM_SYMBOL_VARIABLE);`
  - 函数：  
    `cn_sem_scope_insert_symbol(global, name_ptr, name_len, CN_SEM_SYMBOL_FUNCTION);`

- **查找符号**
  - 使用 `cn_sem_scope_lookup(current_scope, name_ptr, name_len);`  
    若为 `NULL`，即可通过 diagnostics 报“未定义标识符”等错误。

---

### 后续可做的 TODO 建议

- **TODO 1**：在 `src/semantics/checker/` 或 `resolution/` 中新增名字解析/作用域构建逻辑，实际调用 `cn_sem_scope_*` API。
- **TODO 2**：在 `tests/unit/` 下为符号表与作用域实现添加单元测试（创建嵌套作用域、插入/查找、重复定义检查等）。
- **TODO 3**：视需要在语义分析阶段集成 diagnostics，对重复定义、未定义标识符等场景输出规范化错误信息。

如果你希望，我可以下一步直接帮你写一组简单的符号表单元测试，或者设计一个“名字解析”语义 pass 的骨架代码。