
我已经在头文件里加了作用域构建入口声明，并在 semantics/resolution 下实现了 AST 遍历+作用域构建逻辑，下一步把新文件挂到 CMake 里并快速检查一个小问题。
### 我理解的「TODO 1」

结合你给的阶段 2 TODO 文档，“一、符号表与作用域”已经做完，现在的 **TODO 1** 我按这样来理解和实现：

> 在 AST 遍历中集成作用域构建：基于现有 AST，构建全局/函数/块作用域链，并把函数 / 变量声明插入对应作用域。

下面是这次「TODO 1」对应的实现情况和可执行的 TODO 列表。

---

### 已完成的实现

- **1. 语义入口 API（头文件声明）**

  在 `include/cnlang/frontend/semantics.h` 中新增了作用域构建入口（并引入 AST 类型）：

  ```c
  #include "cnlang/frontend/ast.h"

  // 基于当前 AST 构建作用域链，返回全局作用域指针；失败时返回 NULL
  CnSemScope *cn_sem_build_scopes(CnAstProgram *program);
  ```

  - 接口语义：
    - 传入完整的 `CnAstProgram *program`。
    - 内部会创建一个 **全局作用域**，并为每个函数定义构建函数作用域、块作用域。
    - 返回值为最外层的 `CN_SEM_SCOPE_GLOBAL` 作用域；失败时返回 `NULL`。

- **2. 作用域构建实现文件**

  在 `src/semantics/resolution/` 下新增实现文件：

  - **文件**：`src/semantics/resolution/scope_builder.c`  
    - 头部包含：
      ```c
      #include "cnlang/frontend/semantics.h"

      #include <stdlib.h>
      ```

  - **对外实现的入口函数**

    ```c
    CnSemScope *cn_sem_build_scopes(CnAstProgram *program)
    {
        CnSemScope *global_scope;
        size_t i;

        if (!program) {
            return NULL;
        }

        global_scope = cn_sem_scope_new(CN_SEM_SCOPE_GLOBAL, NULL);
        if (!global_scope) {
            return NULL;
        }

        for (i = 0; i < program->function_count; ++i) {
            CnAstFunctionDecl *function_decl = program->functions[i];

            if (!function_decl) {
                continue;
            }

            cn_sem_scope_insert_symbol(global_scope,
                                       function_decl->name,
                                       function_decl->name_length,
                                       CN_SEM_SYMBOL_FUNCTION);

            cn_sem_build_function_scope(global_scope, function_decl);
        }

        return global_scope;
    }
    ```

    - 为每个函数：
      - 在 **全局作用域** 中插入一个 `CN_SEM_SYMBOL_FUNCTION` 符号。
      - 构建该函数自己的作用域链（见下）。

  - **函数作用域构建**

    ```c
    static void cn_sem_build_function_scope(CnSemScope *parent_scope,
                                            CnAstFunctionDecl *function_decl)
    {
        CnSemScope *function_scope;
        size_t i;

        if (!parent_scope || !function_decl) {
            return;
        }

        function_scope = cn_sem_scope_new(CN_SEM_SCOPE_FUNCTION, parent_scope);
        if (!function_scope) {
            return;
        }

        for (i = 0; i < function_decl->parameter_count; ++i) {
            CnAstParameter *param = &function_decl->parameters[i];

            cn_sem_scope_insert_symbol(function_scope,
                                       param->name,
                                       param->name_length,
                                       CN_SEM_SYMBOL_VARIABLE);
        }

        cn_sem_build_block_scope(function_scope, function_decl->body);
    }
    ```

    - 为当前函数创建 `CN_SEM_SCOPE_FUNCTION` 作用域，其父作用域为全局。
    - 将 **函数参数** 作为 `CN_SEM_SYMBOL_VARIABLE` 插入函数作用域。
    - 函数体 `{ ... }` 作为一个新的 **块作用域**，由 `cn_sem_build_block_scope` 继续处理。

  - **块作用域构建**

    ```c
    static void cn_sem_build_block_scope(CnSemScope *parent_scope,
                                         CnAstBlockStmt *block)
    {
        CnSemScope *block_scope;
        size_t i;

        if (!parent_scope || !block) {
            return;
        }

        block_scope = cn_sem_scope_new(CN_SEM_SCOPE_BLOCK, parent_scope);
        if (!block_scope) {
            return;
        }

        for (i = 0; i < block->stmt_count; ++i) {
            cn_sem_build_stmt(block_scope, block->stmts[i]);
        }
    }
    ```

    - 对每个块 `{ ... }`：
      - 创建 `CN_SEM_SCOPE_BLOCK`，父作用域是传入的 `parent_scope`。
      - 遍历块内所有语句 `stmts[i]`，逐个调用 `cn_sem_build_stmt`。

  - **语句级处理（声明插入 & 继续遍历）**

    ```c
    static void cn_sem_build_stmt(CnSemScope *scope, CnAstStmt *stmt)
    {
        if (!scope || !stmt) {
            return;
        }

        switch (stmt->kind) {
        case CN_AST_STMT_BLOCK:
            cn_sem_build_block_scope(scope, stmt->as.block);
            break;
        case CN_AST_STMT_VAR_DECL: {
            CnAstVarDecl *var_decl = &stmt->as.var_decl;

            cn_sem_scope_insert_symbol(scope,
                                       var_decl->name,
                                       var_decl->name_length,
                                       CN_SEM_SYMBOL_VARIABLE);

            cn_sem_build_expr(scope, var_decl->initializer);
            break;
        }
        case CN_AST_STMT_EXPR:
            cn_sem_build_expr(scope, stmt->as.expr.expr);
            break;
        case CN_AST_STMT_RETURN:
            cn_sem_build_expr(scope, stmt->as.return_stmt.expr);
            break;
        case CN_AST_STMT_IF:
            cn_sem_build_if_stmt(scope, &stmt->as.if_stmt);
            break;
        case CN_AST_STMT_WHILE:
            cn_sem_build_while_stmt(scope, &stmt->as.while_stmt);
            break;
        case CN_AST_STMT_FOR:
            cn_sem_build_for_stmt(scope, &stmt->as.for_stmt);
            break;
        case CN_AST_STMT_BREAK:
        case CN_AST_STMT_CONTINUE:
            break;
        }
    }
    ```

    - **变量声明**（`CN_AST_STMT_VAR_DECL`）：
      - 使用 `var_decl->name` / `name_length` 将变量插入当前 `scope`。
      - 同时递归遍历初始化表达式。
    - **复合语句**：
      - `if` / `while` / `for` 由专用的 helper 函数处理（见下），以保持单函数 < 50 行。
    - **其他语句**：遍历其中的表达式即可，不新建作用域。

  - **If / While / For 的作用域规则**

    - `if`：

      ```c
      static void cn_sem_build_if_stmt(CnSemScope *scope, CnAstIfStmt *if_stmt)
      {
          if (!scope || !if_stmt) {
              return;
          }

          cn_sem_build_expr(scope, if_stmt->condition);
          cn_sem_build_block_scope(scope, if_stmt->then_block);
          cn_sem_build_block_scope(scope, if_stmt->else_block);
      }
      ```

      - 条件表达式在当前作用域中解析。
      - then / else 块各自创建新的块作用域，父作用域为当前 `scope`。

    - `while`：

      ```c
      static void cn_sem_build_while_stmt(CnSemScope *scope, CnAstWhileStmt *while_stmt)
      {
          if (!scope || !while_stmt) {
              return;
          }

          cn_sem_build_expr(scope, while_stmt->condition);
          cn_sem_build_block_scope(scope, while_stmt->body);
      }
      ```

      - 条件表达式在当前 `scope`。
      - 循环体是一个新块作用域。

    - `for`：

      ```c
      static void cn_sem_build_for_stmt(CnSemScope *scope, CnAstForStmt *for_stmt)
      {
          CnSemScope *for_scope;

          if (!scope || !for_stmt) {
              return;
          }

          for_scope = cn_sem_scope_new(CN_SEM_SCOPE_BLOCK, scope);
          if (!for_scope) {
              return;
          }

          cn_sem_build_stmt(for_scope, for_stmt->init);
          cn_sem_build_expr(for_scope, for_stmt->condition);
          cn_sem_build_expr(for_scope, for_stmt->update);
          cn_sem_build_block_scope(for_scope, for_stmt->body);
      }
      ```

      - 整个 `for` 被视为一个新的块作用域：
        - `init` 语句、循环条件、更新表达式以及循环体都在 `for_scope` 下处理。
        - 这样 `for` 里的循环变量可以只在循环内部可见（接近 C 风格）。

  - **表达式遍历（目前只负责递归，不做检查）**

    ```c
    static void cn_sem_build_expr(CnSemScope *scope, CnAstExpr *expr)
    {
        size_t i;

        if (!scope || !expr) {
            return;
        }

        switch (expr->kind) {
        case CN_AST_EXPR_BINARY:
            cn_sem_build_expr(scope, expr->as.binary.left);
            cn_sem_build_expr(scope, expr->as.binary.right);
            break;
        case CN_AST_EXPR_CALL:
            cn_sem_build_expr(scope, expr->as.call.callee);
            for (i = 0; i < expr->as.call.argument_count; ++i) {
                cn_sem_build_expr(scope, expr->as.call.arguments[i]);
            }
            break;
        case CN_AST_EXPR_IDENTIFIER:
        case CN_AST_EXPR_INTEGER_LITERAL:
        case CN_AST_EXPR_STRING_LITERAL:
            break;
        case CN_AST_EXPR_ASSIGN:
            cn_sem_build_expr(scope, expr->as.assign.target);
            cn_sem_build_expr(scope, expr->as.assign.value);
            break;
        case CN_AST_EXPR_LOGICAL:
            cn_sem_build_expr(scope, expr->as.logical.left);
            cn_sem_build_expr(scope, expr->as.logical.right);
            break;
        case CN_AST_EXPR_UNARY:
            cn_sem_build_expr(scope, expr->as.unary.operand);
            break;
        }
    }
    ```

    - 目前只是 **遍历结构**，为后续类型推断和名称解析（使用处检查）打基础。
    - 真正的“未定义标识符/重复定义报错”会在后续 TODO 中加上 diagnostics 之后实现。

- **3. 已加入构建系统**

  在 `src/CMakeLists.txt` 中，把新的实现文件加入了 `cnc` 的源列表：

  ```cmake
  add_executable(cnc
      cli/cnc/main.c
      frontend/lexer/token.c
      frontend/lexer/lexer.c
      frontend/ast/ast.c
      frontend/parser/parser.c
      support/diagnostics/diagnostics.c
      semantics/symbols/symbol_table.c
      semantics/resolution/scope_builder.c
  )
  ```

  你后续在 `main.c` 或测试里调用 `cn_sem_build_scopes` 时，链接会是正常的。

---

### 针对「TODO 1」的结构化 TODO 列表（当前状态）

- **[已完成] TODO 1.1：在 semantics.h 中声明作用域构建入口**
  - 引入 `CnAstProgram` 类型。
  - 声明 `CnSemScope *cn_sem_build_scopes(CnAstProgram *program);`。

- **[已完成] TODO 1.2：在语义模块中实现 AST 遍历 + 作用域构建**
  - 新增 `scope_builder.c`，实现：
    - 全局作用域创建；
    - 函数作用域（参数插入）；
    - 块作用域（变量声明插入）；
    - if/while/for 的作用域和递归遍历。

- **[已完成] TODO 1.3：把语义构建模块加入编译目标**
  - 更新 `src/CMakeLists.txt`，加入 `semantics/resolution/scope_builder.c`。

- **[待做] TODO 1.4（建议下一步）：在前端主流程中调用语义构建**
  - 在合适的位置（例如 `main.c` 或未来的前端 pipeline）：
    - 在语法分析得到 `CnAstProgram *program` 后调用：
      ```c
      CnSemScope *global_scope = cn_sem_build_scopes(program);
      ```
    - 目前只构建作用域，不报错；后续再接 diagnostics 和类型系统。

- **[待做] TODO 1.5（对应文档“三、语义检查”的后续 TODO）**
  - 在当前遍历基础上：
    - 使用 `cn_sem_scope_lookup`/`lookup_shallow` 做 **重复定义检查**、**未定义标识符检查**；
    - 与 `diagnostics` 模块集成，按规范报错（这是下一批 TODO 的内容）。

---

### 使用建议

目前你可以在解析完成后这样试用这套接口（伪代码示例）：

```c
CnAstProgram *program = NULL;
CnSemScope *global_scope = NULL;

/* 已通过 parser 得到 program */

global_scope = cn_sem_build_scopes(program);
if (!global_scope) {
    /* TODO: 处理内存不足或其他错误 */
}

/* 之后可以用 cn_sem_scope_lookup(global_scope, ...) 做简单试验 */
```

如果你希望，下一步我可以把 **TODO 1.4** 也一起做掉（在 `main.c` 中串联词法 → 语法 → 作用域构建），或者开始做“三、语义检查”里的第一个子 TODO（重复定义/未定义检查 + diagnostics 集成）。