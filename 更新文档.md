
我会为 1.2 这三条 TODO 落实三块内容：1）在 config 模块里增加预设 target + 数据布局结构；2）在实现里填好 x86_64-elf 的具体数值；3）在 cnc 的 main.c 里增加 --target 选项解析，并默认一个合理的目标。然后补一个针对预设目标的数据布局单元测试。
I’ll add数据布局结构和预设目标到 config.h/target_triple.c，然后在 cnc 的 main 里接入 --target 解析。最后我会补一个针对预设布局的单元测试，并提醒你如何运行。
### 已完成的实现（对应 1.2 的 3 条 TODO）

#### 1. 定义 `x86_64-elf` 等用于 OS 开发的预设目标三元组

- **在 config 模块中保持使用字符串形式的预设**，核心是让 `x86_64-elf` 解析后得到一个稳定的三元组，并在此基础上提供数据布局：
  - `x86_64-elf` 现已由 `cn_support_target_triple_parse` 解析为：
    - `arch = CN_TARGET_ARCH_X86_64`
    - `vendor = CN_TARGET_VENDOR_UNKNOWN`
    - `os = CN_TARGET_OS_NONE`（裸机 / freestanding）
    - `abi = CN_TARGET_ABI_ELF`
  - 这是后续 OS/freestanding 场景的默认目标。

> 这一部分是在 1.1 中已经实现的，本次没有改动，只是作为预设目标的基础。

---

#### 2. 为预设目标补充数据布局信息

- **新增类型与 API（头文件 `include/cnlang/support/config.h`）**：
  - 新增结构体 **`CnTargetDataLayout`**，字段包括：
    - `pointer_size_in_bits`
    - `pointer_alignment_in_bits`
    - `int_size_in_bits`
    - `int_alignment_in_bits`
    - `long_size_in_bits`
    - `long_alignment_in_bits`
    - `long_long_size_in_bits`
    - `long_long_alignment_in_bits`
  - 新增函数声明：
    - **`bool cn_support_target_get_data_layout(const CnTargetTriple *triple, CnTargetDataLayout *out_layout);`**
      - 若对应目标有预设数据布局，返回 `true` 并填充 `out_layout`，否则返回 `false`。

- **实现预设数据布局（`src/support/config/target_triple.c`）**：
  - 新增内部函数：
    - `static void cn_support_target_fill_default_layout(const CnTargetTriple *triple, CnTargetDataLayout *layout);`
      - 当前实现只对 **`x86_64-elf`（arch=x86_64, os=NONE, abi=ELF）** 填充布局：
        - `pointer_size_in_bits = 64`
        - `pointer_alignment_in_bits = 64`
        - `int_size_in_bits = 32`
        - `int_alignment_in_bits = 32`
        - `long_size_in_bits = 64`
        - `long_alignment_in_bits = 64`
        - `long_long_size_in_bits = 64`
        - `long_long_alignment_in_bits = 64`
  - 新增对外 API 实现：
    - `bool cn_support_target_get_data_layout(const CnTargetTriple *triple, CnTargetDataLayout *out_layout)`
      - 参数校验：`triple` / `out_layout` 为 `NULL` 时返回 `false`。
      - 本地 `layout` 置零后，调用 `cn_support_target_fill_default_layout`。
      - 若结果中 `pointer_size_in_bits == 0`，说明没有匹配的预设布局，返回 `false`。
      - 否则拷贝到 `*out_layout` 并返回 `true`。

- **单元测试扩展（`tests/unit/support_target_triple_test.c`）**：
  - 新增测试函数 **`test_preset_x86_64_elf_layout`**：
    - 先 `cn_support_target_triple_parse("x86_64-elf", &triple)`，要求成功。
    - 再调用 `cn_support_target_get_data_layout(&triple, &layout)`，要求返回 `true`。
    - 断言所有布局字段符合上述预期（64 位指针，32 位 int，64 位 long/long long）。
  - 在 `main` 中增加调用：
    - `if (test_preset_x86_64_elf_layout() != 0) return 1;`
  - 仍复用已有的 CMake 配置（`tests/unit/CMakeLists.txt` 无需变更）。

---

#### 3. 在 CLI (`src/cli/cnc/main.c`) 中增加 `--target` 选项

- **引入 config 模块**：
  - 在头文件区域增加：
    - `#include "cnlang/support/config.h"`

- **增加默认目标三元组变量**：
  - 在 `main` 开头（变量区）添加：
    - `CnTargetTriple target_triple;`
  - 使用新 API 设置默认值（即预设 `x86_64-elf` 对应的语义）：
    - ```c
      target_triple = cn_support_target_triple_make(
          CN_TARGET_ARCH_X86_64,
          CN_TARGET_VENDOR_PC,
          CN_TARGET_OS_NONE,
          CN_TARGET_ABI_ELF);
      ```
    - 这为后续 freestanding/OS 开发提供一个合理的默认目标。

- **帮助信息中声明新选项**：
  - 在用法提示和 `--help` 输出中，都增加了一行：
    - `--target=<三元组>  指定编译目标 (例如 --target=x86_64-elf)`

- **解析 `--target` 命令行选项**（仍在 `main` 中的参数解析 for 循环里）：
  - 在现有 `-O<n>` 分支后增加一个分支：
    ```c
    } else if (strncmp(argv[i], "--target=", 9) == 0) {
        const char *triple_str = argv[i] + 9;
        CnTargetTriple parsed_triple;
        bool target_ok = cn_support_target_triple_parse(triple_str, &parsed_triple);
        if (!target_ok) {
            fprintf(stderr, "无效的目标三元组: %s\n", triple_str);
            return 1;
        }
        target_triple = parsed_triple;
        run_pipeline = true;
    }
    ```
  - 行为约定：
    - 若字符串无法解析为合法 target triple，则打印错误并立即退出（避免后续使用不明确目标）。
    - 否则更新 `target_triple`，为后续编译流程提供正确的目标信息。
  - 目前 `target_triple` 尚未传入 IR/C 后端，这一步会在后续阶段（与 ABI 映射、C 后端参数绑定等 TODO）中接上。

---

### 如何验证本次 1.2 的实现

- **编译和运行相关单元测试**（在你的构建目录中）：
  - `cmake --build .`
  - `ctest -R support_target_triple_test -V`
    - 这会同时验证：
      - 目标三元组解析（含 `x86_64-elf`）。
      - `to_string` round-trip。
      - **`x86_64-elf` 的预设数据布局**。

- **手动试一下 CLI 的 `--target` 选项**（示例）：
  - `cnc examples/hello_compile.cn --target=x86_64-elf -c`
    - 若 target 字符串合法，编译流程应照常进行（目前只是记录目标，还未深入影响后端）。
  - `cnc examples/hello_compile.cn --target=foo-bar  # 示例`
    - 应立即报错：`无效的目标三元组: foo-bar` 并退出。

---

如果你接下来希望把 `target_triple` 真正贯穿到 IR/C 后端（比如影响 C 代码里的 `#ifdef` 或数据布局），可以再开一个 TODO 小节，我可以按现有接口继续往下接。