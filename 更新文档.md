
### 1. TODO 1.1：支持 `整数` 变量声明

**目标**：让 `整数 a = 1;` 和 `变量 a = 1;` 在语法层面走同一套 VarDecl AST 逻辑，对应文档里的：

> VarDecl = ("整数" | "变量") Identifier "=" Expr ;

**具体实现**

- 在 [parser.c](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/src/frontend/parser/parser.c) 的 `parse_statement` 中，将原来只处理 `变量` 的分支扩展为同时处理 `整数`：

  ```c
  if (parser->current.kind == CN_TOKEN_KEYWORD_VAR ||
      parser->current.kind == CN_TOKEN_KEYWORD_INT) {
      const char *var_name;
      size_t var_name_length;
      CnAstExpr *initializer = NULL;

      parser_advance(parser);

      if (parser->current.kind != CN_TOKEN_IDENT) {
          parser->error_count++;
          return NULL;
      }

      var_name = parser->current.lexeme_begin;
      var_name_length = parser->current.lexeme_length;
      parser_advance(parser);

      if (parser->current.kind == CN_TOKEN_EQUAL) {
          parser_advance(parser);
          initializer = parse_expression(parser);
      }

      parser_expect(parser, CN_TOKEN_SEMICOLON);

      return make_var_decl_stmt(var_name, var_name_length, initializer);
  }
  ```

- AST 侧没有新类型区分 `整数`/`变量`，仍然统一用 `CN_AST_STMT_VAR_DECL` + `CnAstVarDecl`，这跟我们目前“类型系统还没做”的阶段是一致的，类型信息后续在语义阶段补充即可。

**效果**

- 现在以下语句都能被解析为变量声明语句：

  ```cn
  整数 x = 1;
  变量 y = 2;
  ```

- 对应 AST：都是 `CnAstStmt` kind = `CN_AST_STMT_VAR_DECL`。

---

### 2. TODO 1.2：支持字符串字面量表达式（让 `hello_world.cn` 可解析）

**目标**：按照 v0 语法，让 `"你好，世界！"` 这种字符串字面量可以作为表达式出现，尤其能作为 `打印(...)` 的实参，从而支持：

```cn
函数 主程序() {
    打印("你好，世界！");
    返回 0;
}
```

#### 2.1 扩展 AST 表达式种类

在 [ast.h](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/include/cnlang/frontend/ast.h) 中：

- **新增一个表达式 kind**：

  ```c
  typedef enum CnAstExprKind {
      CN_AST_EXPR_BINARY,
      CN_AST_EXPR_CALL,
      CN_AST_EXPR_IDENTIFIER,
      CN_AST_EXPR_INTEGER_LITERAL,
      CN_AST_EXPR_STRING_LITERAL,
      CN_AST_EXPR_ASSIGN,
      CN_AST_EXPR_LOGICAL,
      CN_AST_EXPR_UNARY
  } CnAstExprKind;
  ```

- **新增字符串字面量节点结构**：

  ```c
  typedef struct CnAstStringLiteralExpr {
      const char *value;
      size_t length;
  } CnAstStringLiteralExpr;
  ```

- **在 `CnAstExpr` 的 union 中挂上新节点**：

  ```c
  typedef struct CnAstExpr {
      CnAstExprKind kind;
      union {
          CnAstBinaryExpr binary;
          CnAstCallExpr call;
          CnAstIdentifierExpr identifier;
          CnAstIntegerLiteralExpr integer_literal;
          CnAstStringLiteralExpr string_literal;
          CnAstAssignExpr assign;
          CnAstLogicalExpr logical;
          CnAstUnaryExpr unary;
      } as;
  } CnAstExpr;
  ```

#### 2.2 更新 AST 释放逻辑

在 [ast.c](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/src/frontend/ast/ast.c) 的 `cn_frontend_ast_expr_free` 中，新增对 `CN_AST_EXPR_STRING_LITERAL` 的 case（字符串字面量本身不拥有字符串内存，只是指向源码，因此不用递归释放）：

```c
case CN_AST_EXPR_INTEGER_LITERAL:
    break;
case CN_AST_EXPR_STRING_LITERAL:
    break;
```

#### 2.3 Parser 中识别字符串字面量

在 [parser.c](file:///c:/Users/ChenChao/Documents/gitcode/CN_Language/src/frontend/parser/parser.c)：

- **声明构造函数**：

  ```c
  static CnAstExpr *make_integer_literal(long value);
  static CnAstExpr *make_string_literal(const char *value, size_t length);
  static CnAstExpr *make_identifier(const char *name, size_t length);
  ```

- **在 `parse_factor` 中处理 `CN_TOKEN_STRING_LITERAL`**：

  ```c
  static CnAstExpr *parse_factor(CnParser *parser)
  {
      CnAstExpr *expr = NULL;

      if (!parser->has_current) {
          parser_advance(parser);
      }

      if (parser->current.kind == CN_TOKEN_INTEGER) {
          long value = strtol(parser->current.lexeme_begin, NULL, 10);
          expr = make_integer_literal(value);
          parser_advance(parser);
      } else if (parser->current.kind == CN_TOKEN_STRING_LITERAL) {
          expr = make_string_literal(parser->current.lexeme_begin, parser->current.lexeme_length);
          parser_advance(parser);
      } else if (parser->current.kind == CN_TOKEN_IDENT) {
          expr = make_identifier(parser->current.lexeme_begin, parser->current.lexeme_length);
          parser_advance(parser);
      } else if (parser->current.kind == CN_TOKEN_LPAREN) {
          parser_advance(parser);
          expr = parse_expression(parser);
          parser_expect(parser, CN_TOKEN_RPAREN);
      } else {
          parser->error_count++;
          parser_advance(parser);
      }

      return expr;
  }
  ```

- **实现 `make_string_literal`**（紧跟 `make_integer_literal`）：

  ```c
  static CnAstExpr *make_integer_literal(long value)
  {
      CnAstExpr *expr = (CnAstExpr *)malloc(sizeof(CnAstExpr));
      if (!expr) {
          return NULL;
      }

      expr->kind = CN_AST_EXPR_INTEGER_LITERAL;
      expr->as.integer_literal.value = value;
      return expr;
  }

  static CnAstExpr *make_string_literal(const char *value, size_t length)
  {
      CnAstExpr *expr = (CnAstExpr *)malloc(sizeof(CnAstExpr));
      if (!expr) {
          return NULL;
      }

      expr->kind = CN_AST_EXPR_STRING_LITERAL;
      expr->as.string_literal.value = value;
      expr->as.string_literal.length = length;
      return expr;
  }
  ```

**效果**

- 现在字符串字面量会生成 `CN_AST_EXPR_STRING_LITERAL` 节点，并携带源码里的起始指针和长度。
- `打印("你好，世界！");` 会被解析为：
  - 一个 CallExpr：callee 为标识符 `打印`，arguments 数组的第一个元素为一个 `STRING_LITERAL` 表达式节点。
- 这为后续前端/后端根据 `value` + `length` 生成 C 字符串字面量打下基础。

---

### 3. TODO 1.1 + 1.2 的小结（给你一个简短 TODO 对勾）

- **[已完成] TODO 1.1**：`整数` 变量声明支持  
  - Parser 现在把 `整数` 和 `变量` 视为同一类变量声明语句，统一构造 `CN_AST_STMT_VAR_DECL`。
- **[已完成] TODO 1.2**：字符串字面量解析 + AST  
  - AST 新增 `CN_AST_EXPR_STRING_LITERAL` 和对应结构；  
  - Parser 能把 `CN_TOKEN_STRING_LITERAL` 转成 AST 节点；  
  - `hello_world.cn` 里的 `"你好，世界！"` 可以作为 `打印` 的参数参与解析。

---

### 下一步建议（可选）

如果你愿意继续往下推进，我建议下一步的 TODO 是：

1. **补一个专门针对 `examples/hello_world.cn` 的 parser 单元测试**（验证主程序函数名、语句结构、字符串字面量节点类型等）。  
2. 后面再进入我们的 TODO 2.x：设计最小版 Diagnostics 模块，让 Lexer/Parser 遇到错误时真正产生日志，而不是只靠 `error_count`。

你可以先自己编译 + 跑现有的单测看看是否正常，如果遇到具体错误（编译报错或运行时问题），把日志贴出来，我可以再帮你一起对。