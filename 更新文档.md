
### TODO 1.4 已完成：在前端主流程中调用语义作用域构建

下面是这次「TODO 1.4」对应的具体改动和后续可执行的 TODO 列表。

---

### 已做的代码改动

- **1. 在 `main.c` 中引入语义接口**

  文件：`src/cli/cnc/main.c`

  - 新增头文件引用：
    ```c
    #include "cnlang/frontend/lexer.h"
    #include "cnlang/frontend/parser.h"
    #include "cnlang/frontend/ast.h"
    #include "cnlang/frontend/semantics.h"
    #include "cnlang/support/diagnostics.h"
    ```

- **2. 在主函数中声明全局作用域指针**

  ```c
  CnLexer lexer;
  CnParser *parser;
  CnAstProgram *program = NULL;
  CnSemScope *global_scope = NULL;
  CnDiagnostics diagnostics;
  ```

- **3. 解析成功且无语法错误后，构建作用域链**

  在原先“解析成功 & 无错误”之后、打印函数摘要之前，插入调用：

  ```c
  if (diagnostics_has_error(&diagnostics)) {
      fprintf(stderr, "解析失败\n");
      print_diagnostics(&diagnostics);
      cn_frontend_ast_program_free(program);
      cn_frontend_parser_free(parser);
      cn_support_diagnostics_free(&diagnostics);
      free(source);
      return 1;
  }

  global_scope = cn_sem_build_scopes(program);
  if (!global_scope) {
      fprintf(stderr, "构建作用域失败\n");
      cn_frontend_ast_program_free(program);
      cn_frontend_parser_free(parser);
      cn_support_diagnostics_free(&diagnostics);
      free(source);
      return 1;
  }

  print_function_summary(program);
  print_diagnostics(&diagnostics);
  ```

  - 逻辑顺序：
    - **先**根据 diagnostics 判断是否有解析错误，有则直接退出；
    - **再**调用 `cn_sem_build_scopes(program)` 构建全局作用域和函数/块作用域链；
    - 构建失败（例如内存分配失败）时，打印“构建作用域失败”，并按统一流程释放资源后退出。

- **4. 在程序结束前释放作用域**

  在原本释放 AST / 解析器 / 诊断 / 源码之前，先释放作用域：

  ```c
  print_function_summary(program);
  print_diagnostics(&diagnostics);

  cn_sem_scope_free(global_scope);
  cn_frontend_ast_program_free(program);
  cn_frontend_parser_free(parser);
  cn_support_diagnostics_free(&diagnostics);
  free(source);
  ```

  - 语义：
    - `global_scope` 及其内部链表（函数作用域 / 块作用域中的符号列表）由 `cn_sem_scope_free` 统一释放；
    - AST 仍由原有的 `cn_frontend_ast_program_free` 管理，两者无所有权冲突。

---

### 与 TODO 1.4 对应的结构化 TODO 状态

- **[已完成] TODO 1.4.1：在前端主流程中串联语义作用域构建**
  - `cnc` 从“词法 → 语法 → 语义（作用域构建）”已经打通；
  - 目前语义阶段仅构建作用域链，不做错误检查。

- **[已完成] TODO 1.4.2：资源释放一致性**
  - 当作用域构建失败时，与解析失败同样走统一的释放路径；
  - 正常路径下先释放 `global_scope`，再释放 AST 及其他资源。

- **[待做] TODO 1.4.3（可选下一步）：在 main 中挂更多语义 pass**
  - 后续实现名称解析 / 类型检查后，可以在 `cn_sem_build_scopes` 调用之后，继续调用其它语义入口函数，比如：
    - `cn_sem_resolve_names(global_scope, program, &diagnostics);`
    - `cn_sem_check_types(global_scope, program, &diagnostics);`
  - 然后使用 diagnostics 决定是否继续后端/IR 等阶段。

---

### 下一步推荐 TODO（如果你想继续）

- **TODO 2.x：基于当前作用域链实现“名称解析与重复/未定义检查”**
  - 新增一个 `cn_sem_resolve_names` 接口：
    - 使用 `cn_sem_scope_lookup` 和 `cn_sem_scope_lookup_shallow` 进行符号使用检查；
    - 将“重复定义”“未定义标识符”等错误通过 diagnostics 报出。
  - 在 `main.c` 中，在 `cn_sem_build_scopes` 之后调用它，如有语义错误则打印后退出。

如果你希望下一步就是做“名称解析与重复/未定义检查”，可以直接告诉我“继续做名称解析 TODO”或指定文档里的某一条 TODO，我会按类似方式实现并更新 main / 测试。