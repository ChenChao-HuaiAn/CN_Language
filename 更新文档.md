### 一、目标三元组类型与 API（头文件）

- **新增头文件**：`include/cnlang/support/config.h`
  - 定义了枚举：
    - **架构**：`CnTargetArch`（`CN_TARGET_ARCH_UNKNOWN`/`X86_64`/`AARCH64`）
    - **厂商**：`CnTargetVendor`（`CN_TARGET_VENDOR_UNKNOWN`/`PC`）
    - **操作系统**：`CnTargetOS`（`UNKNOWN`/`NONE`/`LINUX`/`WINDOWS`，其中 `NONE` 用于裸机环境）
    - **ABI**：`CnTargetABI`（`UNKNOWN`/`SYSV`/`MSVC`/`ELF`/`GNU_EABI`）
  - 定义目标三元组结构体：
    - **`CnTargetTriple`**：包含 `arch`、`vendor`、`os`、`abi` 四个字段。
  - 声明了三类 API（带中文注释）：
    - **解析**：`bool cn_support_target_triple_parse(const char *str, CnTargetTriple *out);`
      - 支持形式：`"arch"`、`"arch-vendor-os-abi"`、`"arch-vendor-os"`、`"arch-vendor"`、`"arch-abi"`（如 `x86_64-elf`）。
      - 未识别字段会落到 `*_UNKNOWN` / `CN_TARGET_OS_NONE`，**架构无法识别则整体解析失败**。
    - **构造**：`CnTargetTriple cn_support_target_triple_make(...)` 用枚举直接构造结构体。
    - **格式化**：`int cn_support_target_triple_to_string(const CnTargetTriple *triple, char *buffer, size_t buffer_size);`
      - 始终输出规范形式 `"arch-vendor-os-abi"`，失败时返回 `-1`。

---

### 二、解析与格式化实现（源文件）

- **新增源文件**：`src/support/config/target_triple.c`
  - 内部辅助函数（字符串 ↔ 枚举）：
    - `cn_support_target_arch_from_string` / `*_vendor_from_string` / `*_os_from_string` / `*_abi_from_string`
      - 识别字符串：`"x86_64"`、`"aarch64"`、`"pc"`、`"unknown"`、`"none"`、`"freestanding"`、`"linux"`、`"windows"`、`"elf"`、`"sysv"`、`"msvc"`、`"gnueabi"` 等。
    - 对应的 `*_to_string` 版本，用于反向格式化。
  - 字符串拆分工具：
    - `cn_support_split_target_triple(const char *str, char parts[4][32], int *out_count)`
      - 使用 `'-'` 分割最多 4 段，截断超长段到 31 字节，保证安全。
  - **核心实现**：
    - `bool cn_support_target_triple_parse(const char *str, CnTargetTriple *out)`
      - 使用上面的 split 函数，将输入拆成 1–4 段：
        - `1 段`：只解析架构；其余保持 `UNKNOWN`。
        - `2 段`：视作 `arch-abi` 的 OS 开发简写形式（例如 `x86_64-elf`），设：
          - `vendor = CN_TARGET_VENDOR_UNKNOWN`
          - `os = CN_TARGET_OS_NONE`
          - `abi` 根据第二段解析。
        - `3 段`：视作 `arch-vendor-os`，ABI 使用默认值。
        - `≥4 段`：视作规范 `arch-vendor-os-abi`，仅取前 4 段。
      - 如果最终 `arch == CN_TARGET_ARCH_UNKNOWN`，则返回 `false`，表示解析失败。
    - `CnTargetTriple cn_support_target_triple_make(...)`
      - 简单地填充结构体字段并返回，用于构造预设目标。
    - `int cn_support_target_triple_to_string(...)`
      - 使用 `snprintf` 输出 `"arch-vendor-os-abi"` 形式。
      - 若缓冲区不足或写入失败，返回 `-1`；否则返回写入字符数（不含 `'\0'`）。

- **接入编译**：
  - 在 `src/CMakeLists.txt` 的 `cnc` 目标中增加：
    - **`support/config/target_triple.c`**

---

### 三、单元测试（round-trip 与典型用例）

- **新增测试文件**：`tests/unit/support_target_triple_test.c`
  - 引入头文件：`"cnlang/support/config.h"`，以及 `<stdio.h>`、`<string.h>`。
  - 定义 4 个子测试函数（`static int`）：
    - **`test_parse_simple_arch_abi`**
      - 输入：`"x86_64-elf"`
      - 期望：
        - `arch == CN_TARGET_ARCH_X86_64`
        - `vendor == CN_TARGET_VENDOR_UNKNOWN`
        - `os == CN_TARGET_OS_NONE`
        - `abi == CN_TARGET_ABI_ELF`
    - **`test_parse_full_triple`**
      - 输入：`"aarch64-unknown-linux-gnueabi"`
      - 期望：
        - `arch == CN_TARGET_ARCH_AARCH64`
        - `vendor == CN_TARGET_VENDOR_UNKNOWN`
        - `os == CN_TARGET_OS_LINUX`
        - `abi == CN_TARGET_ABI_GNU_EABI`
    - **`test_parse_invalid_arch`**
      - 输入：`"mips-unknown-elf"`
      - 期望：`cn_support_target_triple_parse` 返回 `false`，即非法架构解析失败。
    - **`test_to_string_round_trip`**
      - 构造：`cn_support_target_triple_make(CN_TARGET_ARCH_X86_64, CN_TARGET_VENDOR_PC, CN_TARGET_OS_NONE, CN_TARGET_ABI_ELF)`
      - 用 `cn_support_target_triple_to_string` 输出到缓冲区，再用 `cn_support_target_triple_parse` 解析回 `parsed`
      - 断言：`parsed` 的四个枚举字段与原始 `triple` 完全一致。
  - `main` 依次调用四个测试函数，任一失败则返回 `1`，全部成功时打印：
    - `support_target_triple_test: OK` 并返回 `0`。

- **接入 CTest**（`tests/unit/CMakeLists.txt`）：
  - 新增目标与测试：
    - **可执行文件**：
      - `add_executable(support_target_triple_test
          support_target_triple_test.c
          ../../src/support/config/target_triple.c
        )`
    - 包含目录：
      - `target_include_directories(support_target_triple_test PRIVATE ../../include)`
    - 测试：
      - `add_test(NAME support_target_triple_test COMMAND support_target_triple_test)`

---

### 四、你可以如何验证

- 在构建目录中执行（示例）：
  - **`cmake --build .`**
  - **`ctest -R support_target_triple_test -V`**
- 通过后，说明 1.1 小节的“目标三元组基础设施”已经具备：
  - 类型与 API 设计
  - 解析/构造/格式化实现
  - 基本单元测试与 round-trip 验证
