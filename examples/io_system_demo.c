/*
 * CN_Language 标准I/O系统演示程序
 * 演示文件操作、标准输入输出、格式化输入输出和缓冲区管理
 */

#include "cnlang/runtime/stdlib.h"
#include <stdio.h>
#include <string.h>

// 演示标准输入输出
void 演示标准输入输出(void)
{
    printf("\n=== 标准输入输出演示 ===\n");
    
    // 打印字符串
    打印字符串("欢迎使用CN语言标准I/O系统！");
    打印行("");  // 换行
    
    // 格式化打印
    格式化打印("当前版本: %d.%d.%d\n", 1, 0, 0);
    
    // 刷新输出缓冲
    打印字符串("刷新输出缓冲...");
    刷新输出();
    打印行(" 完成!");
}

// 演示文件写入操作
void 演示文件写入(const char* 文件名)
{
    printf("\n=== 文件写入演示 ===\n");
    
    // 打开文件用于写入
    void* 文件 = 打开文件(文件名, "w");
    if (文件 == NULL) {
        printf("错误: 无法打开文件 %s 进行写入\n", 文件名);
        return;
    }
    
    printf("成功打开文件: %s\n", 文件名);
    
    // 写入多行文本
    const char* 内容[] = {
        "CN语言标准I/O系统测试文件\n",
        "第一行: Hello World!\n",
        "第二行: 这是中文测试\n",
        "第三行: 数字测试 123456\n",
        "第四行: 符号测试 !@#$%^&*()\n"
    };
    
    size_t 总字节数 = 0;
    for (int i = 0; i < 5; i++) {
        size_t 长度 = 获取字符串长度(内容[i]);
        size_t 写入字节 = 写入文件(文件, 内容[i], 长度);
        总字节数 += 写入字节;
        printf("写入第 %d 行, %zu 字节\n", i + 1, 写入字节);
    }
    
    // 刷新文件缓冲
    刷新文件缓冲(文件);
    printf("已刷新文件缓冲\n");
    
    // 关闭文件
    关闭文件(文件);
    printf("文件已关闭，共写入 %zu 字节\n", 总字节数);
}

// 演示文件读取操作
void 演示文件读取(const char* 文件名)
{
    printf("\n=== 文件读取演示 ===\n");
    
    // 打开文件用于读取
    void* 文件 = 打开文件(文件名, "r");
    if (文件 == NULL) {
        printf("错误: 无法打开文件 %s 进行读取\n", 文件名);
        return;
    }
    
    printf("成功打开文件: %s\n", 文件名);
    
    // 读取文件内容
    char 缓冲区[1024];
    size_t 读取字节;
    int 行号 = 1;
    
    printf("\n文件内容:\n");
    printf("----------------------------------------\n");
    
    while (!判断文件结束(文件)) {
        读取字节 = 读取文件(文件, 缓冲区, sizeof(缓冲区) - 1);
        if (读取字节 > 0) {
            缓冲区[读取字节] = '\0';
            printf("%s", 缓冲区);
        }
    }
    
    printf("----------------------------------------\n");
    
    // 关闭文件
    关闭文件(文件);
    printf("文件已关闭\n");
}

// 演示文件定位操作
void 演示文件定位(const char* 文件名)
{
    printf("\n=== 文件定位演示 ===\n");
    
    // 打开文件
    void* 文件 = 打开文件(文件名, "r");
    if (文件 == NULL) {
        printf("错误: 无法打开文件 %s\n", 文件名);
        return;
    }
    
    // 移动到文件末尾
    文件定位(文件, 0, 2);  // SEEK_END = 2
    long 文件大小 = 获取文件位置(文件);
    printf("文件大小: %ld 字节\n", 文件大小);
    
    // 移动到文件开头
    文件定位(文件, 0, 0);  // SEEK_SET = 0
    printf("当前位置: %ld (文件开头)\n", 获取文件位置(文件));
    
    // 读取前20个字节
    char 缓冲区[21];
    size_t 读取字节 = 读取文件(文件, 缓冲区, 20);
    缓冲区[读取字节] = '\0';
    printf("前20字节: %s\n", 缓冲区);
    
    // 显示当前位置
    printf("读取后位置: %ld\n", 获取文件位置(文件));
    
    // 关闭文件
    关闭文件(文件);
}

// 演示缓冲区管理
void 演示缓冲区管理(const char* 文件名)
{
    printf("\n=== 缓冲区管理演示 ===\n");
    
    // 打开文件
    void* 文件 = 打开文件(文件名, "w");
    if (文件 == NULL) {
        printf("错误: 无法打开文件 %s\n", 文件名);
        return;
    }
    
    // 设置为无缓冲模式
    printf("设置为无缓冲模式\n");
    cn_rt_file_setbuf((CnRtFile)文件, NULL, 2, 0);  // mode=2: 无缓冲
    
    // 写入数据（无缓冲，立即写入磁盘）
    const char* 测试数据 = "无缓冲写入测试\n";
    写入文件(文件, 测试数据, 获取字符串长度(测试数据));
    printf("已写入数据（无缓冲模式）\n");
    
    关闭文件(文件);
    
    // 重新打开，设置为全缓冲模式
    文件 = 打开文件(文件名, "a");
    if (文件 != NULL) {
        printf("设置为全缓冲模式\n");
        char 自定义缓冲[4096];
        cn_rt_file_setbuf((CnRtFile)文件, 自定义缓冲, 0, sizeof(自定义缓冲));  // mode=0: 全缓冲
        
        测试数据 = "全缓冲写入测试\n";
        写入文件(文件, 测试数据, 获取字符串长度(测试数据));
        printf("已写入数据（全缓冲模式）\n");
        
        // 显式刷新
        刷新文件缓冲(文件);
        printf("已刷新缓冲区\n");
        
        关闭文件(文件);
    }
}

// 演示格式化输入输出
void 演示格式化输入输出(void)
{
    printf("\n=== 格式化输入输出演示 ===\n");
    
    // 格式化到字符串
    char 缓冲区[256];
    
    格式化字符串(缓冲区, "整数: %d, 浮点: %.2f, 字符串: %s", 
                  42, 3.14159, "测试");
    printf("格式化结果: %s\n", 缓冲区);
    
    // 安全格式化（带大小限制）
    char 小缓冲区[20];
    安全格式化字符串(小缓冲区, sizeof(小缓冲区), 
                      "这是一个很长的字符串，会被截断");
    printf("安全格式化（截断）: %s\n", 小缓冲区);
    
    // 格式化打印
    格式化打印("年份: %d, 月份: %d, 日期: %d\n", 2026, 1, 25);
}

// 演示实际应用：简单的日志系统
void 演示日志系统(const char* 日志文件)
{
    printf("\n=== 日志系统演示 ===\n");
    
    void* 文件 = 打开文件(日志文件, "a");  // 追加模式
    if (文件 == NULL) {
        printf("错误: 无法打开日志文件\n");
        return;
    }
    
    // 写入日志条目
    char 日志缓冲[256];
    
    安全格式化字符串(日志缓冲, sizeof(日志缓冲),
                      "[INFO] 系统启动\n");
    写入文件(文件, 日志缓冲, 获取字符串长度(日志缓冲));
    
    安全格式化字符串(日志缓冲, sizeof(日志缓冲),
                      "[DEBUG] 加载配置文件\n");
    写入文件(文件, 日志缓冲, 获取字符串长度(日志缓冲));
    
    安全格式化字符串(日志缓冲, sizeof(日志缓冲),
                      "[INFO] 初始化完成\n");
    写入文件(文件, 日志缓冲, 获取字符串长度(日志缓冲));
    
    // 刷新并关闭
    刷新文件缓冲(文件);
    关闭文件(文件);
    
    printf("日志已写入文件: %s\n", 日志文件);
    
    // 读取并显示日志
    文件 = 打开文件(日志文件, "r");
    if (文件 != NULL) {
        printf("\n日志内容:\n");
        printf("----------------------------------------\n");
        
        char 缓冲区[256];
        while (!判断文件结束(文件)) {
            size_t 读取 = 读取文件(文件, 缓冲区, sizeof(缓冲区) - 1);
            if (读取 > 0) {
                缓冲区[读取] = '\0';
                printf("%s", 缓冲区);
            }
        }
        
        printf("----------------------------------------\n");
        关闭文件(文件);
    }
}

// 主函数
int main(void)
{
    printf("\n");
    printf("========================================\n");
    printf("CN_Language 标准I/O系统演示程序\n");
    printf("========================================\n");
    
    const char* 测试文件 = "io_test.txt";
    const char* 日志文件 = "system.log";
    
    // 运行各个演示
    演示标准输入输出();
    演示格式化输入输出();
    演示文件写入(测试文件);
    演示文件读取(测试文件);
    演示文件定位(测试文件);
    演示缓冲区管理("buffer_test.txt");
    演示日志系统(日志文件);
    
    printf("\n========================================\n");
    printf("演示完成！\n");
    printf("生成的文件:\n");
    printf("  - %s (测试文件)\n", 测试文件);
    printf("  - buffer_test.txt (缓冲区测试)\n");
    printf("  - %s (日志文件)\n", 日志文件);
    printf("========================================\n\n");
    
    return 0;
}
