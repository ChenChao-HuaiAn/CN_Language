/*
 * CN Language 内存管理器演示程序
 * 
 * 本示例展示系统编程中的内存管理能力：
 * 1. 创建和管理内存分配器
 * 2. 使用不同策略的内存池
 * 3. 内存分配与释放
 * 4. 内存泄漏检测
 * 5. 内存使用统计
 * 6. 内存碎片整理
 * 
 * 这是阶段8系统编程能力的验收示例
 */

// ============================================
// 节点数据结构 - 用于演示内存分配
// ============================================
结构体 内存节点 {
    整数 编号;
    字符串 名称;
    内存节点* 下一个;
}

// ============================================
// 辅助函数：打印分隔线
// ============================================
函数 打印分隔线(字符串 标题) {
    打印("\n========================================");
    打印(标题);
    打印("========================================\n");
}

// ============================================
// 辅助函数：打印内存统计信息
// ============================================
函数 显示内存统计(CnAllocator* 分配器) {
    整数 总分配;
    整数 总释放;
    整数 当前使用;
    整数 峰值使用;
    
    cn_allocator_get_stats(分配器, &总分配, &总释放, &当前使用, &峰值使用);
    
    打印("内存统计：");
    打印("  总分配: " + 总分配 + " 字节");
    打印("  总释放: " + 总释放 + " 字节");
    打印("  当前使用: " + 当前使用 + " 字节");
    打印("  峰值使用: " + 峰值使用 + " 字节");
}

// ============================================
// 演示函数1：基本内存池操作
// ============================================
函数 演示基本内存池(CnAllocator* 分配器) {
    打印分隔线("演示1：基本内存池操作");
    
    // 创建一个内存池（使用首次适应策略）
    打印("创建内存池（首次适应策略）...");
    CnMemPool* 通用池 = cn_pool_create(
        分配器,
        "通用内存池",
        256 * 1024,  // 256KB
        CN_ALLOC_STRATEGY_FIRST_FIT
    );
    
    如果 (通用池 == NULL) {
        打印("错误：无法创建内存池");
        返回;
    }
    
    打印("内存池创建成功");
    
    // 从池中分配内存
    打印("\n分配内存节点...");
    内存节点* 节点1 = (内存节点*)cn_pool_alloc(通用池, sizeof(内存节点));
    节点1->编号 = 1;
    节点1->名称 = "节点A";
    节点1->下一个 = NULL;
    打印("分配节点1: 编号=" + 节点1->编号 + ", 名称=" + 节点1->名称);
    
    内存节点* 节点2 = (内存节点*)cn_pool_alloc(通用池, sizeof(内存节点));
    节点2->编号 = 2;
    节点2->名称 = "节点B";
    节点2->下一个 = NULL;
    打印("分配节点2: 编号=" + 节点2->编号 + ", 名称=" + 节点2->名称);
    
    // 打印池统计
    打印("\n内存池统计：");
    cn_pool_print_stats(通用池);
    
    // 释放内存
    打印("\n释放节点1...");
    cn_pool_free(通用池, 节点1);
    
    打印("释放节点2...");
    cn_pool_free(通用池, 节点2);
    
    打印("内存释放完成");
}

// ============================================
// 演示函数2：多种分配策略对比
// ============================================
函数 演示分配策略(CnAllocator* 分配器) {
    打印分隔线("演示2：多种分配策略");
    
    // 创建三个使用不同策略的内存池
    打印("创建三个内存池，使用不同的分配策略：");
    
    // 首次适应 - 速度快
    CnMemPool* 快速池 = cn_pool_create(
        分配器,
        "快速池-首次适应",
        128 * 1024,
        CN_ALLOC_STRATEGY_FIRST_FIT
    );
    打印("  1. 快速池（首次适应策略）- 优先速度");
    
    // 最佳适应 - 节省空间
    CnMemPool* 节约池 = cn_pool_create(
        分配器,
        "节约池-最佳适应",
        128 * 1024,
        CN_ALLOC_STRATEGY_BEST_FIT
    );
    打印("  2. 节约池（最佳适应策略）- 节省空间");
    
    // 最差适应 - 减少碎片
    CnMemPool* 平衡池 = cn_pool_create(
        分配器,
        "平衡池-最差适应",
        128 * 1024,
        CN_ALLOC_STRATEGY_WORST_FIT
    );
    打印("  3. 平衡池（最差适应策略）- 减少碎片");
    
    // 从不同池分配内存
    打印("\n从各个池分配内存...");
    
    整数* 数据1 = (整数*)cn_pool_alloc(快速池, 100 * sizeof(整数));
    打印("从快速池分配：100个整数");
    
    字符串* 文本1 = (字符串*)cn_pool_alloc(节约池, 50);
    打印("从节约池分配：50字节字符串");
    
    整数* 数组1 = (整数*)cn_pool_alloc(平衡池, 200 * sizeof(整数));
    打印("从平衡池分配：200个整数");
    
    // 打印各池统计
    打印("\n各池使用情况：");
    打印("快速池：");
    cn_pool_print_stats(快速池);
    
    打印("\n节约池：");
    cn_pool_print_stats(节约池);
    
    打印("\n平衡池：");
    cn_pool_print_stats(平衡池);
    
    // 清理
    cn_pool_free(快速池, 数据1);
    cn_pool_free(节约池, 文本1);
    cn_pool_free(平衡池, 数组1);
}

// ============================================
// 演示函数3：内存泄漏检测
// ============================================
函数 演示内存泄漏检测(CnAllocator* 分配器) {
    打印分隔线("演示3：内存泄漏检测");
    
    // 启用泄漏检测
    打印("启用内存泄漏检测...");
    cn_allocator_set_leak_detection(分配器, 真);
    打印("泄漏检测已启用");
    
    // 创建测试池
    CnMemPool* 测试池 = cn_pool_create(
        分配器,
        "泄漏检测测试池",
        64 * 1024,
        CN_ALLOC_STRATEGY_FIRST_FIT
    );
    
    // 分配一些内存
    打印("\n分配内存块...");
    整数* 块1 = (整数*)cn_pool_alloc(测试池, 100);
    打印("分配块1：100字节");
    
    整数* 块2 = (整数*)cn_pool_alloc(测试池, 200);
    打印("分配块2：200字节");
    
    整数* 块3 = (整数*)cn_pool_alloc(测试池, 300);
    打印("分配块3：300字节");
    
    // 只释放部分内存，模拟内存泄漏
    打印("\n释放块1...");
    cn_pool_free(测试池, 块1);
    打印("块2和块3未释放（模拟内存泄漏）");
    
    // 检查泄漏
    打印("\n检查内存泄漏...");
    整数 泄漏数量 = cn_allocator_check_leaks(分配器);
    打印("检测到 " + 泄漏数量 + " 个内存泄漏");
    
    // 打印泄漏报告
    如果 (泄漏数量 > 0) {
        打印("\n详细泄漏报告：");
        cn_allocator_print_leak_report(分配器);
    }
    
    // 修正泄漏：释放剩余内存
    打印("\n修正泄漏：释放所有未释放的内存...");
    cn_pool_free(测试池, 块2);
    cn_pool_free(测试池, 块3);
    
    泄漏数量 = cn_allocator_check_leaks(分配器);
    打印("泄漏修正后：剩余 " + 泄漏数量 + " 个泄漏");
}

// ============================================
// 演示函数4：内存碎片整理
// ============================================
函数 演示内存碎片整理(CnAllocator* 分配器) {
    打印分隔线("演示4：内存碎片整理");
    
    // 创建测试池
    CnMemPool* 碎片池 = cn_pool_create(
        分配器,
        "碎片整理测试池",
        256 * 1024,
        CN_ALLOC_STRATEGY_FIRST_FIT
    );
    
    打印("创建测试池并制造碎片...");
    
    // 分配多个块
    整数* 块数组[10];
    变量 i = 0;
    当 (i < 10) {
        块数组[i] = (整数*)cn_pool_alloc(碎片池, 1000);
        打印("分配块" + (i + 1) + ": 1000字节");
        i = i + 1;
    }
    
    // 释放部分块，制造碎片
    打印("\n释放部分块以制造内存碎片...");
    cn_pool_free(碎片池, 块数组[1]);
    cn_pool_free(碎片池, 块数组[3]);
    cn_pool_free(碎片池, 块数组[5]);
    cn_pool_free(碎片池, 块数组[7]);
    打印("释放了块2, 块4, 块6, 块8");
    
    // 打印碎片统计
    打印("\n碎片整理前的池状态：");
    cn_pool_print_stats(碎片池);
    
    // 执行碎片整理
    打印("\n执行内存碎片整理...");
    整数 合并数量 = cn_pool_merge_free_blocks(碎片池);
    打印("合并了 " + 合并数量 + " 个空闲块");
    
    // 打印整理后统计
    打印("\n碎片整理后的池状态：");
    cn_pool_print_stats(碎片池);
    
    // 清理剩余内存
    cn_pool_free(碎片池, 块数组[0]);
    cn_pool_free(碎片池, 块数组[2]);
    cn_pool_free(碎片池, 块数组[4]);
    cn_pool_free(碎片池, 块数组[6]);
    cn_pool_free(碎片池, 块数组[8]);
    cn_pool_free(碎片池, 块数组[9]);
}

// ============================================
// 演示函数5：综合性能测试
// ============================================
函数 演示性能测试(CnAllocator* 分配器) {
    打印分隔线("演示5：综合性能测试");
    
    // 创建性能测试池
    CnMemPool* 性能池 = cn_pool_create(
        分配器,
        "性能测试池",
        1024 * 1024,  // 1MB
        CN_ALLOC_STRATEGY_FIRST_FIT
    );
    
    打印("执行大量内存分配和释放操作...");
    
    // 分配大量小块
    打印("\n测试1：分配1000个小块（每块100字节）");
    整数* 小块数组[1000];
    变量 i = 0;
    当 (i < 1000) {
        小块数组[i] = (整数*)cn_pool_alloc(性能池, 100);
        i = i + 1;
    }
    打印("分配完成");
    
    // 打印中间统计
    打印("\n分配1000个小块后的统计：");
    cn_pool_print_stats(性能池);
    
    // 释放所有块
    打印("\n释放所有小块...");
    i = 0;
    当 (i < 1000) {
        cn_pool_free(性能池, 小块数组[i]);
        i = i + 1;
    }
    打印("释放完成");
    
    // 测试大块分配
    打印("\n测试2：分配10个大块（每块10KB）");
    整数* 大块数组[10];
    i = 0;
    当 (i < 10) {
        大块数组[i] = (整数*)cn_pool_alloc(性能池, 10 * 1024);
        i = i + 1;
    }
    打印("分配完成");
    
    // 释放大块
    i = 0;
    当 (i < 10) {
        cn_pool_free(性能池, 大块数组[i]);
        i = i + 1;
    }
    
    // 打印最终统计
    打印("\n性能测试完成后的统计：");
    cn_pool_print_stats(性能池);
}

// ============================================
// 主程序 - 内存管理器综合演示
// ============================================
函数 主程序() {
    打印分隔线("CN Language 内存管理器综合演示");
    打印("这是阶段8系统编程能力验收示例");
    打印("演示内存池管理、分配策略、泄漏检测等功能");
    
    // 1. 创建内存分配器
    打印("\n初始化：创建内存分配器...");
    CnAllocator* 分配器 = cn_allocator_create(
        2 * 1024 * 1024,  // 默认池大小：2MB
        CN_ALLOC_STRATEGY_FIRST_FIT
    );
    
    如果 (分配器 == NULL) {
        打印("错误：无法创建内存分配器");
        返回 1;
    }
    
    打印("内存分配器创建成功");
    打印("默认池大小：2MB");
    打印("默认策略：首次适应");
    
    // 2. 运行各个演示
    演示基本内存池(分配器);
    演示分配策略(分配器);
    演示内存泄漏检测(分配器);
    演示内存碎片整理(分配器);
    演示性能测试(分配器);
    
    // 3. 打印最终全局统计
    打印分隔线("最终统计报告");
    cn_allocator_print_stats(分配器);
    
    显示内存统计(分配器);
    
    // 4. 清理资源
    打印分隔线("清理资源");
    打印("销毁内存分配器...");
    cn_allocator_destroy(分配器);
    打印("内存分配器已销毁");
    打印("所有资源已释放");
    
    // 5. 完成
    打印分隔线("演示完成");
    打印("CN Language 内存管理器演示成功完成！");
    打印("这展示了系统编程所需的完整内存管理能力：");
    打印("  ✓ 内存池创建与管理");
    打印("  ✓ 多种分配策略支持");
    打印("  ✓ 内存泄漏检测");
    打印("  ✓ 内存碎片整理");
    打印("  ✓ 性能统计与分析");
    
    返回 0;
}
