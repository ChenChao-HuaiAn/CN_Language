// 并发控制综合测试
// 结合原子操作和锁机制的综合场景

整数 全局计数器 = 0;
整数 锁标志 = 0;
整数 操作成功次数 = 0;
整数 操作失败次数 = 0;

函数 整数 安全递增(整数 增量) {
    // 尝试获取锁
    如果 (锁标志 == 0) {
        锁标志 = 1;
        
        // 临界区：安全地修改共享变量
        整数 旧值 = 全局计数器;
        全局计数器 = 全局计数器 + 增量;
        
        打印("成功递增: ");
        打印整数(旧值);
        打印(" -> ");
        打印整数(全局计数器);
        打印换行();
        
        // 释放锁
        锁标志 = 0;
        操作成功次数 = 操作成功次数 + 1;
        返回 1;
    }
    
    操作失败次数 = 操作失败次数 + 1;
    返回 0;
}

函数 整数 批量操作(整数 次数, 整数 增量) {
    整数 i = 0;
    整数 成功 = 0;
    
    当 (i < 次数) {
        整数 结果 = 安全递增(增量);
        如果 (结果 == 1) {
            成功 = 成功 + 1;
        }
        i = i + 1;
    }
    
    返回 成功;
}

函数 主程序() {
    打印("=== 并发控制综合测试 ===");
    打印换行();
    
    // 初始化
    全局计数器 = 0;
    锁标志 = 0;
    操作成功次数 = 0;
    操作失败次数 = 0;
    
    打印("初始状态:");
    打印换行();
    打印("  全局计数器: ");
    打印整数(全局计数器);
    打印换行();
    
    // 测试场景1: 单次操作
    打印("测试单次原子递增...");
    打印换行();
    安全递增(5);
    
    // 测试场景2: 批量操作
    打印("测试批量操作(10次，每次+2)...");
    打印换行();
    整数 批量成功 = 批量操作(10, 2);
    打印("批量操作完成，成功: ");
    打印整数(批量成功);
    打印(" 次");
    打印换行();
    
    // 测试场景3: 混合操作
    打印("测试混合操作...");
    打印换行();
    安全递增(10);
    安全递增(3);
    批量操作(5, 1);
    
    // 显示最终统计
    打印("=== 测试完成统计 ===");
    打印换行();
    打印("最终计数器值: ");
    打印整数(全局计数器);
    打印换行();
    打印("操作成功次数: ");
    打印整数(操作成功次数);
    打印换行();
    打印("操作失败次数: ");
    打印整数(操作失败次数);
    打印换行();
    
    // 验证数据一致性
    整数 预期值 = 5 + 20 + 10 + 3 + 5;  // 各次增量之和
    如果 (全局计数器 == 预期值) {
        打印("✓ 数据一致性验证通过");
        打印换行();
    } 否则 {
        打印("✗ 数据一致性验证失败");
        打印换行();
        打印("预期值: ");
        打印整数(预期值);
        打印(", 实际值: ");
        打印整数(全局计数器);
        打印换行();
    }
    
    返回 0;
}
