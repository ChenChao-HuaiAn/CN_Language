/*
 * CN Language 任务调度器演示程序
 * 
 * 本示例展示系统编程中的并发控制能力：
 * 1. 任务队列管理
 * 2. 任务优先级调度
 * 3. 互斥锁保护临界区
 * 4. 自旋锁用于快速同步
 * 5. 读写锁实现多读单写
 * 6. 原子操作保证数据一致性
 * 
 * 这是阶段8系统编程能力验收的并发控制示例
 */

// ============================================
// 任务相关数据结构
// ============================================

// 任务优先级
枚举 任务优先级 {
    低优先级 = 1,
    普通优先级 = 2,
    高优先级 = 3,
    紧急优先级 = 4
}

// 任务状态
枚举 任务状态 {
    等待状态 = 0,
    运行状态 = 1,
    完成状态 = 2,
    取消状态 = 3
}

// 任务结构
结构体 任务 {
    整数 任务ID;
    字符串 任务名称;
    整数 优先级;
    整数 状态;
    整数 执行时间;
    任务* 下一个;
}

// 调度器统计信息
结构体 调度器统计 {
    整数 总任务数;
    整数 已完成任务数;
    整数 运行中任务数;
    整数 等待中任务数;
    整数 上下文切换次数;
}

// ============================================
// 全局变量 - 任务队列和统计
// ============================================

任务* 任务队列头 = NULL;
任务* 当前任务 = NULL;
调度器统计 统计信息;

// 并发控制变量
CnMutex 队列锁;
CnSpinlock 统计锁;
CnRwLock 任务锁;
CnAtomic32 任务ID计数器;

// ============================================
// 辅助函数
// ============================================

函数 打印分隔线(字符串 标题) {
    打印("\n========================================");
    打印(标题);
    打印("========================================\n");
}

函数 字符串 获取优先级名称(整数 优先级) {
    如果 (优先级 == 1) {
        返回 "低";
    } 否则 如果 (优先级 == 2) {
        返回 "普通";
    } 否则 如果 (优先级 == 3) {
        返回 "高";
    } 否则 如果 (优先级 == 4) {
        返回 "紧急";
    }
    返回 "未知";
}

函数 字符串 获取状态名称(整数 状态) {
    如果 (状态 == 0) {
        返回 "等待";
    } 否则 如果 (状态 == 1) {
        返回 "运行";
    } 否则 如果 (状态 == 2) {
        返回 "完成";
    } 否则 如果 (状态 == 3) {
        返回 "取消";
    }
    返回 "未知";
}

// ============================================
// 任务管理函数
// ============================================

函数 任务* 创建任务(字符串 名称, 整数 优先级, 整数 执行时间) {
    // 使用读写锁保护任务创建
    cn_rt_rwlock_write_lock(&任务锁);
    
    任务* 新任务 = (任务*)cn_rt_malloc(sizeof(任务));
    
    如果 (新任务 == NULL) {
        打印("错误：无法分配任务内存");
        cn_rt_rwlock_write_unlock(&任务锁);
        返回 NULL;
    }
    
    // 使用原子操作生成唯一任务ID
    新任务->任务ID = cn_rt_atomic32_fetch_add(&任务ID计数器, 1, CN_MEMORY_ORDER_SEQ_CST);
    新任务->任务名称 = 名称;
    新任务->优先级 = 优先级;
    新任务->状态 = 等待状态;
    新任务->执行时间 = 执行时间;
    新任务->下一个 = NULL;
    
    // 使用自旋锁更新统计（快速操作）
    cn_rt_spinlock_lock(&统计锁);
    统计信息.总任务数++;
    统计信息.等待中任务数++;
    cn_rt_spinlock_unlock(&统计锁);
    
    cn_rt_rwlock_write_unlock(&任务锁);
    
    打印("创建任务: [ID=" + 新任务->任务ID + "] " + 名称);
    打印("  优先级: " + 获取优先级名称(优先级));
    打印("  预计执行时间: " + 执行时间 + "ms");
    
    返回 新任务;
}

函数 添加任务到队列(任务* 新任务) {
    如果 (新任务 == NULL) {
        返回;
    }
    
    // 使用互斥锁保护队列操作
    cn_rt_mutex_lock(&队列锁);
    
    // 按优先级插入队列（优先级高的在前）
    如果 (任务队列头 == NULL 或者 新任务->优先级 > 任务队列头->优先级) {
        新任务->下一个 = 任务队列头;
        任务队列头 = 新任务;
        打印("任务添加到队列头部");
    } 否则 {
        任务* 当前 = 任务队列头;
        当 (当前->下一个 != NULL 并且 当前->下一个->优先级 >= 新任务->优先级) {
            当前 = 当前->下一个;
        }
        新任务->下一个 = 当前->下一个;
        当前->下一个 = 新任务;
        打印("任务按优先级插入队列");
    }
    
    cn_rt_mutex_unlock(&队列锁);
}

函数 任务* 获取下一个任务() {
    // 使用互斥锁保护队列操作
    cn_rt_mutex_lock(&队列锁);
    
    任务* 下一个任务 = 任务队列头;
    
    如果 (下一个任务 != NULL) {
        任务队列头 = 下一个任务->下一个;
        下一个任务->下一个 = NULL;
        
        // 更新统计
        cn_rt_spinlock_lock(&统计锁);
        统计信息.等待中任务数--;
        统计信息.运行中任务数++;
        统计信息.上下文切换次数++;
        cn_rt_spinlock_unlock(&统计锁);
    }
    
    cn_rt_mutex_unlock(&队列锁);
    
    返回 下一个任务;
}

函数 执行任务(任务* task) {
    如果 (task == NULL) {
        返回;
    }
    
    // 使用读写锁保护任务状态修改
    cn_rt_rwlock_write_lock(&任务锁);
    task->状态 = 运行状态;
    cn_rt_rwlock_write_unlock(&任务锁);
    
    打印("\n>>> 开始执行任务 [ID=" + task->任务ID + "] " + task->任务名称);
    打印("    优先级: " + 获取优先级名称(task->优先级));
    打印("    状态: " + 获取状态名称(task->状态));
    
    // 模拟任务执行（简化版，实际会有真实的工作负载）
    整数 进度 = 0;
    当 (进度 < task->执行时间) {
        // 模拟执行进度
        进度 = 进度 + 10;
        如果 (进度 > task->执行时间) {
            进度 = task->执行时间;
        }
        打印("    进度: " + (进度 * 100 / task->执行时间) + "%");
    }
    
    // 任务完成
    cn_rt_rwlock_write_lock(&任务锁);
    task->状态 = 完成状态;
    cn_rt_rwlock_write_unlock(&任务锁);
    
    // 更新统计
    cn_rt_spinlock_lock(&统计锁);
    统计信息.运行中任务数--;
    统计信息.已完成任务数++;
    cn_rt_spinlock_unlock(&统计锁);
    
    打印("<<< 任务完成 [ID=" + task->任务ID + "] " + task->任务名称);
}

函数 显示调度器统计() {
    // 使用读锁查看统计信息（允许多个读者）
    cn_rt_spinlock_lock(&统计锁);
    
    打印("\n=== 调度器统计信息 ===");
    打印("总任务数: " + 统计信息.总任务数);
    打印("已完成: " + 统计信息.已完成任务数);
    打印("运行中: " + 统计信息.运行中任务数);
    打印("等待中: " + 统计信息.等待中任务数);
    打印("上下文切换次数: " + 统计信息.上下文切换次数);
    
    整数 完成率 = 0;
    如果 (统计信息.总任务数 > 0) {
        完成率 = (统计信息.已完成任务数 * 100) / 统计信息.总任务数;
    }
    打印("完成率: " + 完成率 + "%");
    
    cn_rt_spinlock_unlock(&统计锁);
}

函数 显示任务队列() {
    打印("\n=== 当前任务队列 ===");
    
    // 使用互斥锁保护队列遍历
    cn_rt_mutex_lock(&队列锁);
    
    如果 (任务队列头 == NULL) {
        打印("队列为空");
    } 否则 {
        任务* 当前 = 任务队列头;
        整数 序号 = 1;
        
        当 (当前 != NULL) {
            打印(序号 + ". [ID=" + 当前->任务ID + "] " + 当前->任务名称);
            打印("   优先级: " + 获取优先级名称(当前->优先级) + 
                  ", 状态: " + 获取状态名称(当前->状态));
            当前 = 当前->下一个;
            序号++;
        }
    }
    
    cn_rt_mutex_unlock(&队列锁);
}

函数 清理所有任务() {
    cn_rt_mutex_lock(&队列锁);
    
    任务* 当前 = 任务队列头;
    当 (当前 != NULL) {
        任务* 下一个 = 当前->下一个;
        cn_rt_free(当前);
        当前 = 下一个;
    }
    任务队列头 = NULL;
    
    cn_rt_mutex_unlock(&队列锁);
}

// ============================================
// 演示场景
// ============================================

函数 演示基本任务调度() {
    打印分隔线("演示1：基本任务调度");
    
    // 创建不同优先级的任务
    任务* 任务1 = 创建任务("数据处理任务", 普通优先级, 30);
    任务* 任务2 = 创建任务("日志记录任务", 低优先级, 20);
    任务* 任务3 = 创建任务("中断响应任务", 紧急优先级, 10);
    
    // 添加到队列
    打印("\n添加任务到调度队列...");
    添加任务到队列(任务1);
    添加任务到队列(任务2);
    添加任务到队列(任务3);
    
    // 显示队列状态
    显示任务队列();
    
    // 执行所有任务
    打印("\n开始执行任务...");
    任务* 下一个;
    当 ((下一个 = 获取下一个任务()) != NULL) {
        执行任务(下一个);
        cn_rt_free(下一个);
    }
    
    显示调度器统计();
}

函数 演示优先级调度() {
    打印分隔线("演示2：优先级调度策略");
    
    // 创建多个任务，观察优先级效果
    打印("创建混合优先级任务...");
    
    任务* t1 = 创建任务("低优先级任务A", 低优先级, 15);
    任务* t2 = 创建任务("高优先级任务B", 高优先级, 25);
    任务* t3 = 创建任务("普通优先级任务C", 普通优先级, 20);
    任务* t4 = 创建任务("紧急优先级任务D", 紧急优先级, 10);
    任务* t5 = 创建任务("高优先级任务E", 高优先级, 15);
    
    打印("\n按创建顺序添加到队列...");
    添加任务到队列(t1);
    添加任务到队列(t2);
    添加任务到队列(t3);
    添加任务到队列(t4);
    添加任务到队列(t5);
    
    打印("\n队列自动按优先级排序：");
    显示任务队列();
    
    打印("\n执行顺序验证（应按优先级从高到低）：");
    任务* 下一个;
    当 ((下一个 = 获取下一个任务()) != NULL) {
        执行任务(下一个);
        cn_rt_free(下一个);
    }
    
    显示调度器统计();
}

函数 演示并发控制() {
    打印分隔线("演示3：并发控制机制");
    
    打印("展示各种锁的使用场景：");
    打印("1. 互斥锁 - 保护任务队列操作");
    打印("2. 自旋锁 - 保护统计信息（快速访问）");
    打印("3. 读写锁 - 保护任务状态（多读单写）");
    打印("4. 原子操作 - 生成唯一任务ID");
    
    // 测试锁的重入性
    打印("\n测试互斥锁可重入性...");
    cn_rt_mutex_lock(&队列锁);
    打印("第一次加锁成功");
    cn_rt_mutex_lock(&队列锁);
    打印("第二次加锁成功（可重入）");
    cn_rt_mutex_unlock(&队列锁);
    打印("第一次解锁");
    cn_rt_mutex_unlock(&队列锁);
    打印("第二次解锁");
    
    // 测试自旋锁
    打印("\n测试自旋锁...");
    cn_rt_spinlock_lock(&统计锁);
    打印("自旋锁加锁成功");
    cn_rt_spinlock_unlock(&统计锁);
    打印("自旋锁解锁成功");
    
    // 测试读写锁
    打印("\n测试读写锁多读者...");
    cn_rt_rwlock_read_lock(&任务锁);
    打印("读者1获取读锁");
    cn_rt_rwlock_read_lock(&任务锁);
    打印("读者2获取读锁（允许多个读者）");
    cn_rt_rwlock_read_unlock(&任务锁);
    打印("读者2释放读锁");
    cn_rt_rwlock_read_unlock(&任务锁);
    打印("读者1释放读锁");
    
    // 测试原子操作
    打印("\n测试原子操作...");
    整数 旧ID = cn_rt_atomic32_load(&任务ID计数器, CN_MEMORY_ORDER_SEQ_CST);
    整数 新ID = cn_rt_atomic32_fetch_add(&任务ID计数器, 10, CN_MEMORY_ORDER_SEQ_CST);
    打印("原子递增前: " + 旧ID);
    打印("原子递增后: " + (新ID + 10));
}

函数 演示压力测试() {
    打印分隔线("演示4：调度器压力测试");
    
    打印("创建大量任务进行压力测试...");
    
    // 创建50个随机优先级的任务
    整数 i = 0;
    当 (i < 50) {
        整数 优先级 = (i % 4) + 1;  // 循环使用1-4的优先级
        整数 执行时间 = 10 + (i % 3) * 10;  // 10-30ms
        
        字符串 任务名 = "压力测试任务" + i;
        任务* t = 创建任务(任务名, 优先级, 执行时间);
        添加任务到队列(t);
        
        i++;
    }
    
    打印("\n当前队列长度：");
    显示调度器统计();
    
    打印("\n开始批量执行...");
    整数 执行计数 = 0;
    任务* 下一个;
    当 ((下一个 = 获取下一个任务()) != NULL) {
        执行任务(下一个);
        cn_rt_free(下一个);
        执行计数++;
        
        // 每10个任务显示一次进度
        如果 (执行计数 % 10 == 0) {
            打印("\n--- 已执行 " + 执行计数 + " 个任务 ---");
            显示调度器统计();
        }
    }
    
    打印("\n压力测试完成！");
    显示调度器统计();
}

// ============================================
// 主程序
// ============================================

函数 主程序() {
    打印分隔线("CN Language 任务调度器演示");
    打印("这是阶段8系统编程能力验收的并发控制示例");
    打印("演示任务调度、优先级管理和并发控制功能");
    
    // 初始化并发控制原语
    打印("\n初始化调度器...");
    cn_rt_mutex_init(&队列锁);
    cn_rt_spinlock_init(&统计锁);
    cn_rt_rwlock_init(&任务锁);
    cn_rt_atomic32_init(&任务ID计数器, 1);
    
    // 初始化统计信息
    统计信息.总任务数 = 0;
    统计信息.已完成任务数 = 0;
    统计信息.运行中任务数 = 0;
    统计信息.等待中任务数 = 0;
    统计信息.上下文切换次数 = 0;
    
    打印("调度器初始化完成");
    打印("  互斥锁：已初始化（保护队列）");
    打印("  自旋锁：已初始化（保护统计）");
    打印("  读写锁：已初始化（保护任务）");
    打印("  原子计数器：已初始化（生成ID）");
    
    // 运行各个演示场景
    演示基本任务调度();
    演示优先级调度();
    演示并发控制();
    演示压力测试();
    
    // 清理资源
    打印分隔线("清理资源");
    打印("清理剩余任务...");
    清理所有任务();
    
    打印("销毁同步原语...");
    cn_rt_mutex_destroy(&队列锁);
    cn_rt_spinlock_destroy(&统计锁);
    cn_rt_rwlock_destroy(&任务锁);
    
    // 最终统计
    打印分隔线("最终统计报告");
    显示调度器统计();
    
    // 完成
    打印分隔线("演示完成");
    打印("CN Language 任务调度器演示成功完成！");
    打印("这展示了系统编程所需的完整并发控制能力：");
    打印("  ✓ 任务队列管理与优先级调度");
    打印("  ✓ 互斥锁保护共享资源");
    打印("  ✓ 自旋锁实现快速同步");
    打印("  ✓ 读写锁支持多读单写");
    打印("  ✓ 原子操作保证数据一致性");
    打印("  ✓ 完整的任务生命周期管理");
    
    返回 0;
}
